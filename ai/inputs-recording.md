# Input Recording Documentation

## Visual Timeline of Recording/Playback

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        COMPLETE TIMELINE EXAMPLE                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  TIME ──────────────────────────────────────────────────────────────────►   │
│                                                                             │
│  Frame:  0    10    20    30    40    50    60    70    80    90   100     │
│          │     │     │     │     │     │     │     │     │     │     │     │
│          ▼     ▼     ▼     ▼     ▼     ▼     ▼     ▼     ▼     ▼     ▼     │
│                                                                             │
│  ════════════════════════════════════════════════════════════════════════   │
│  PHASE 1: NORMAL GAMEPLAY                                                   │
│  ════════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  Player:  ●────────────────────►                                            │
│           (moving right)                                                    │
│                                                                             │
│  State:   IDLE                                                              │
│                                                                             │
│  ════════════════════════════════════════════════════════════════════════   │
│  PHASE 2: USER PRESSES 'L' AT FRAME 30                                      │
│  ════════════════════════════════════════════════════════════════════════   │
│                                                                             │
│                      [L]                                                    │
│                       │                                                     │
│                       ▼                                                     │
│  Action:        SAVE GAME STATE TO FILE                                     │
│                 ┌─────────────────────────────────────────┐                 │
│                 │ File: recording_1.hmi                   │                 │
│                 │ ┌─────────────────────────────────────┐ │                 │
│                 │ │ GAME STATE (player at position 30) │ │                 │
│                 │ └─────────────────────────────────────┘ │                 │
│                 └─────────────────────────────────────────┘                 │
│                                                                             │
│  State:   IDLE ──► RECORDING                                                │
│                                                                             │
│  ════════════════════════════════════════════════════════════════════════   │
│  PHASE 3: RECORDING (Frames 30-60)                                          │
│  ════════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  Player:                    ●────────────────────►                          │
│                             (user plays: right, jump, attack)               │
│                                                                             │
│  File grows:                                                                │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ GAME STATE │ Input30 │ Input31 │ Input32 │ ... │ Input59 │ Input60 │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  State:   RECORDING                                                         │
│                                                                             │
│  ════════════════════════════════════════════════════════════════════════   │
│  PHASE 4: USER PRESSES 'L' AT FRAME 60                                      │
│  ════════════════════════════════════════════════════════════════════════   │
│                                                                             │
│                                              [L]                            │
│                                               │                             │
│                                               ▼                             │
│  Actions:  1. STOP RECORDING (close file)                                   │
│            2. RESTORE GAME STATE FROM FILE                                  │
│            3. START PLAYBACK                                                │
│                                                                             │
│  Player:                                     ●                              │
│                                              │                              │
│                                              ▼                              │
│                      ●  (teleported back to position 30!)                   │
│                                                                             │
│  State:   RECORDING ──► PLAYBACK                                            │
│                                                                             │
│  ════════════════════════════════════════════════════════════════════════   │
│  PHASE 5: PLAYBACK LOOP (Frames 60-90, then 90-120, etc.)                   │
│  ════════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  Frame 60-90: Replay recorded inputs                                        │
│  Player:                    ●────────────────────►                          │
│                             (same movements as frames 30-60)                │
│                                                                             │
│  Frame 90: EOF reached!                                                     │
│            ┌──────────────────────────────────────────────────────┐        │
│            │ 1. Restore game state (player back to position 30)  │        │
│            │ 2. Seek file to first inputs                         │        │
│            │ 3. Continue playback                                 │        │
│            └──────────────────────────────────────────────────────┘        │
│                                                                             │
│  Frame 90-120: Replay again!                                                │
│  Player:                    ●────────────────────►                          │
│                             (same movements again)                          │
│                                                                             │
│  Frame 120: EOF reached! Loop again...                                      │
│                                                                             │
│  ════════════════════════════════════════════════════════════════════════   │
│  PHASE 6: LIVE CODE EDITING (while loop plays)                              │
│  ════════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  While the game loops:                                                      │
│                                                                             │
` change player speed from 4.0 to 8.0                        │`

│  1. Edit game.c
│  2. Save file                                                               │
│  3. Compiler rebuilds game.so                                               │
│  4. Hot reload detects change, loads new code                               │
│  5. Next loop iteration uses NEW code!                                      │
│                                                                             │
│  Player:                    ●════════════════════════════►                  │
│                             (now moves FASTER with same inputs!)            │
│                                                                             │
│  ════════════════════════════════════════════════════════════════════════   │
│  PHASE 7: USER PRESSES 'L' TO STOP                                          │
│  ════════════════════════════════════════════════════════════════════════   │
│                                                                             │
│                                                              [L]            │
│                                                               │             │
│                                                               ▼             │
│  Action:  STOP PLAYBACK                                                     │
│                                                                             │
│  State:   PLAYBACK ──► IDLE                                                 │
│                                                                             │
│  Game continues normally from wherever it was in the loop.                  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Memory Layout Deep Dive

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        MEMORY LAYOUT                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  GAME MEMORY (allocated at startup, never freed)                            │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  Address: 0x0000020000000000 (2 TB mark in debug builds)                    │
│           │                                                                 │
│           ▼                                                                 │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                                                                     │   │
│  │  PERMANENT STORAGE (64 MB)                                          │   │
│  │  ┌─────────────────────────────────────────────────────────────┐   │   │
│  │  │  GameState struct:                                          │   │   │
│  │  │  ├── player_x: 150                                          │   │   │
│  │  │  ├── player_y: 200                                          │   │   │
│  │  │  ├── health: 100                                            │   │   │
│  │  │  ├── score: 5000                                            │   │   │
│  │  │  ├── tone_hz: 512                                           │   │   │
│  │  │  ├── t_sine: 0.785                                          │   │   │
│  │  │  └── ... other game state ...                               │   │   │
│  │  └─────────────────────────────────────────────────────────────┘   │   │
│  │                                                                     │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │                                                                     │   │
│  │  TRANSIENT STORAGE (1 GB)                                           │   │
│  │  ┌─────────────────────────────────────────────────────────────┐   │   │
│  │  │  Loaded assets, scratch memory, temporary data              │   │   │
│  │  │  (This gets saved/restored too!)                            │   │   │
│  │  └─────────────────────────────────────────────────────────────┘   │   │
│  │                                                                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  Total: 64 MB + 1 GB = 1,073,741,824 + 67,108,864 = 1,140,850,688 bytes    │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  RECORDING FILE (on disk)                                                   │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  File: recording_1.hmi                                                      │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                                                                     │   │
│  │  Bytes 0 - 1,140,850,687:                                          │   │
│  │  ┌─────────────────────────────────────────────────────────────┐   │   │
│  │  │  GAME STATE SNAPSHOT                                        │   │   │
│  │  │  (exact copy of game memory at recording start)             │   │   │
│  │  │                                                             │   │   │
│  │  │  player_x: 150                                              │   │   │
│  │  │  player_y: 200                                              │   │   │
│  │  │  health: 100                                                │   │   │
│  │  │  ...                                                        │   │   │
│  │  └─────────────────────────────────────────────────────────────┘   │   │
│  │                                                                     │   │
│  │  Bytes 1,140,850,688 - 1,140,850,687 + sizeof(GameInput):          │   │
│  │  ┌─────────────────────────────────────────────────────────────┐   │   │
│  │  │  INPUT FRAME 0                                              │   │   │
│  │  │  controllers[0].move_right.ended_down = true                │   │   │
│  │  │  controllers[0].stick_avg_x = 0.75                          │   │   │
│  │  │  ...                                                        │   │   │
│  │  └─────────────────────────────────────────────────────────────┘   │   │
│  │                                                                     │   │
│  │  Next sizeof(GameInput) bytes:                                     │   │
│  │  ┌─────────────────────────────────────────────────────────────┐   │   │
│  │  │  INPUT FRAME 1                                              │   │   │
│  │  │  controllers[0].action_down.ended_down = true (jump!)       │   │   │
│  │  │  ...                                                        │   │   │
│  │  └─────────────────────────────────────────────────────────────┘   │   │
│  │                                                                     │   │
│  │  ... more inputs frames ...                                         │   │
│  │                                                                     │   │
│  │  Last sizeof(GameInput) bytes:                                     │   │
│  │  ┌─────────────────────────────────────────────────────────────┐   │   │
│  │  │  INPUT FRAME N                                              │   │   │
│  │  │  (last frame before user pressed L again)                   │   │   │
│  │  └─────────────────────────────────────────────────────────────┘   │   │
│  │                                                                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  File size = 1,140,850,688 + (N × sizeof(GameInput)) bytes                 │
│                                                                             │
│  Example: 30 frames at 30 FPS = 1 second of recording                       │
│           sizeof(GameInput) ≈ 500 bytes (rough estimate)                    │
│           File size ≈ 1.06 GB + 15 KB = ~1.06 GB                           │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## File I/O Byte-by-Byte

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        FILE I/O BYTE-BY-BYTE                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  STEP 1: OPEN FILE FOR WRITING                                              │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  Code: int fd = open("recording_1.hmi", O_WRONLY | O_CREAT | O_TRUNC, 0644) │
│                                                                             │
│  What happens:                                                              │
│                                                                             │
│  1. Kernel looks up "recording_1.hmi" in filesystem                         │
│  2. If exists: truncate to 0 bytes (O_TRUNC)                                │
│  3. If not exists: create new file (O_CREAT)                                │
│  4. Allocate file descriptor in process table                               │
│  5. Return fd (e.g., 3)                                                     │
│                                                                             │
│  Process FD Table:          Kernel File Table:                              │
│  ┌────┬─────────┐           ┌─────────────────────────────────┐            │
│  │ 0  │ stdin   │           │ recording_1.hmi                 │            │
│  │ 1  │ stdout  │           │ ├── position: 0                 │            │
│  │ 2  │ stderr  │           │ ├── size: 0                     │            │
│  │ 3  │ ────────┼──────────►│ └── mode: write-only            │            │
│  └────┴─────────┘           └─────────────────────────────────┘            │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│  STEP 2: WRITE GAME STATE                                                   │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  Code: write(fd, game_memory_base, total_size)                              │
│        // total_size = 1,140,850,688 bytes (~1.06 GB)                       │
│                                                                             │
│  What happens (simplified):                                                 │
│                                                                             │
│  Memory:                                                                    │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ game_memory_base                                                    │   │
│  │ ▼                                                                   │   │
│  │ [B0][B1][B2][B3][B4][B5]...[B1140850687]                            │   │
│  │  │   │   │   │   │   │         │                                    │   │
│  └──┼───┼───┼───┼───┼───┼─────────┼────────────────────────────────────┘   │
│     │   │   │   │   │   │         │                                        │
│     ▼   ▼   ▼   ▼   ▼   ▼         ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Kernel Buffer (copied from user space)                              │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│     │                                                                       │
│     ▼                                                                       │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Disk: recording_1.hmi                                               │   │
│  │ [B0][B1][B2][B3][B4][B5]...[B1140850687]                            │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  After write:                                                               │
│  - File size: 1,140,850,688 bytes                                          │
│  - File position: 1,140,850,688 (at end)                                   │
│  - Returns: 1,140,850,688 (bytes written)                                  │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│  STEP 3: WRITE INPUT FRAMES (each frame)                                    │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  Code: write(fd, inputs, sizeof(GameInput))                                  │
│        // sizeof(GameInput) ≈ 500 bytes                                     │
│                                                                             │
│  Frame 0:                                                                   │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ File before:                                                        │   │
│  │ [GAME STATE (1.06 GB)]                                              │   │
│  │                       ▲                                              │   │
│  │                       └── position                                   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ File after:                                                         │   │
│  │ [GAME STATE (1.06 GB)][INPUT 0 (500 B)]                             │   │
│  │                                        ▲                             │   │
│  │                                        └── position                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  Frame 1:                                                                   │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ [GAME STATE][INPUT 0][INPUT 1]                                      │   │
│  │                               ▲                                      │   │
│  │                               └── position                           │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  Frame N:                                                                   │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ [GAME STATE][INPUT 0][INPUT 1]...[INPUT N]                          │   │
│  │                                           ▲                          │   │
│  │                                           └── position (EOF)         │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│  STEP 4: CLOSE FILE                                                         │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  Code: close(fd)                                                            │
│                                                                             │
│  What happens:                                                              │
│  1. Flush any buffered data to disk                                         │
│  2. Release file descriptor                                                 │
│  3. fd is now invalid (can be reused by kernel)                            │
│                                                                             │
│  Process FD Table:                                                          │
│  ┌────┬─────────┐                                                          │
│  │ 0  │ stdin   │                                                          │
│  │ 1  │ stdout  │                                                          │
│  │ 2  │ stderr  │                                                          │
│  │ 3  │ (free)  │  ◄── No longer points to file                            │
│  └────┴─────────┘                                                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Playback File I/O

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        PLAYBACK FILE I/O                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  STEP 1: OPEN FILE FOR READING                                              │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  Code: int fd = open("recording_1.hmi", O_RDONLY)                           │
│                                                                             │
│  File state:                                                                │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ [GAME STATE][INPUT 0][INPUT 1][INPUT 2]...[INPUT N]                 │   │
│  │ ▲                                                                    │   │
│  │ └── position = 0                                                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│  STEP 2: READ GAME STATE (restore)                                          │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  Code: read(fd, game_memory_base, total_size)                               │
│                                                                             │
│  What happens:                                                              │
│                                                                             │
│  File:                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ [GAME STATE (1.06 GB)][INPUT 0][INPUT 1]...[INPUT N]                │   │
│  │ ├────────────────────┤                                               │   │
│  │ │ Read these bytes   │                                               │   │
│  │ └────────────────────┘                                               │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                         │                                                   │
│                         ▼                                                   │
│  Game Memory:                                                               │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ BEFORE: [CURRENT STATE - player at X=500, health=50]                │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                         │                                                   │
│                         ▼ OVERWRITTEN!                                      │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ AFTER:  [SAVED STATE - player at X=150, health=100]                 │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  File position after read:                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ [GAME STATE][INPUT 0][INPUT 1][INPUT 2]...[INPUT N]                 │   │
│  │             ▲                                                        │   │
│  │             └── position (ready to read inputs)                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│  STEP 3: READ INPUT FRAMES (each frame)                                     │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  Code: bytes_read = read(fd, inputs, sizeof(GameInput))                      │
│                                                                             │
│  Frame 0:                                                                   │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ [GAME STATE][INPUT 0][INPUT 1][INPUT 2]...[INPUT N]                 │   │
│  │             ├───────┤                                                │   │
│  │             │ Read  │                                                │   │
│  │             └───────┘                                                │   │
│  │                      ▲                                               │   │
│  │                      └── new position                                │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│  bytes_read = sizeof(GameInput) ✓                                          │
│                                                                             │
│  Frame 1:                                                                   │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ [GAME STATE][INPUT 0][INPUT 1][INPUT 2]...[INPUT N]                 │   │
│  │                      ├───────┤                                       │   │
│  │                      │ Read  │                                       │   │
│  │                      └───────┘                                       │   │
│  │                               ▲                                      │   │
│  │                               └── new position                       │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│  bytes_read = sizeof(GameInput) ✓                                          │
│                                                                             │
│  ... continues until ...                                                    │
│                                                                             │
│  Frame N (last frame):                                                      │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ [GAME STATE][INPUT 0][INPUT 1][INPUT 2]...[INPUT N]                 │   │
│  │                                           ├───────┤                  │   │
│  │                                           │ Read  │                  │   │
│  │                                           └───────┘                  │   │
│  │                                                    ▲                 │   │
│  │                                                    └── position=EOF  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│  bytes_read = sizeof(GameInput) ✓                                          │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│  STEP 4: EOF DETECTED (next read attempt)                                   │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  Code: bytes_read = read(fd, inputs, sizeof(GameInput))                      │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ [GAME STATE][INPUT 0][INPUT 1][INPUT 2]...[INPUT N]│                │   │
│  │                                                    ▲│               │   │
│  │                                                    └┼── EOF         │   │
│  │                                                     │               │   │
│  │                                          Nothing to read!           │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│  bytes_read = 0  ◄── This is how we detect end of recording!               │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│  STEP 5: LOOP (when EOF detected)                                           │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  When bytes_read == 0:                                                      │
│                                                                             │
│  1. Close file:  close(fd)                                                  │
│                                                                             │
│  2. Reopen file: fd = open("recording_1.hmi", O_RDONLY)                     │
│     ┌─────────────────────────────────────────────────────────────────┐    │
│     │ [GAME STATE][INPUT 0][INPUT 1]...[INPUT N]                      │    │
│     │ ▲                                                                │    │
│     │ └── position = 0 (back to start!)                                │    │
│     └─────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  3. Read game state: read(fd, game_memory_base, total_size)                 │
│     - Game memory restored to saved state                                   │
│     - Player teleports back to starting position                            │
│     ┌─────────────────────────────────────────────────────────────────┐    │
│     │ [GAME STATE][INPUT 0][INPUT 1]...[INPUT N]                      │    │
│     │             ▲                                                    │    │
│     │             └── position (ready for inputs again)                │    │
│     └─────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  4. Read first inputs: read(fd, inputs, sizeof(GameInput))                    │
│     - Now playing from beginning again!                                     │
│                                                                             │
│  This creates the INFINITE LOOP for live code editing!                      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Complete Code Summary

### Data Flow Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        COMPLETE DATA FLOW                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                         MAIN LOOP                                   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  1. PREPARE INPUT FRAME                                             │   │
│  │     prepare_input_frame(old_input, new_input)                       │   │
│  │     - Copy ended_down states                                        │   │
│  │     - Reset half_transition_counts                                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  2. GET INPUT                                                       │   │
│  │                                                                     │   │
│  │     ┌──────────────────┐     ┌──────────────────┐                  │   │
│  │     │ PLAYBACK MODE?   │────►│ YES: Read from   │                  │   │
│  │     │                  │     │ file             │                  │   │
│  │     └────────┬─────────┘     │                  │                  │   │
│  │              │ NO            │ playback_get_    │                  │   │
│  │              ▼               │ inputs(state,     │                  │   │
│  │     ┌──────────────────┐     │ new_input)       │                  │   │
│  │     │ Poll hardware:   │     └──────────────────┘                  │   │
│  │     │ - Keyboard       │              │                            │   │
│  │     │ - Joystick       │              │                            │   │
│  │     │ - Mouse          │              │                            │   │
│  │     └────────┬─────────┘              │                            │   │
│  │              │                        │                            │   │
│  │              ▼                        │                            │   │
│  │     ┌──────────────────┐              │                            │   │
│  │     │ RECORDING MODE?  │              │                            │   │
│  │     │                  │              │                            │   │
│  │     └────────┬─────────┘              │                            │   │
│  │              │ YES                    │                            │   │
│  │              ▼                        │                            │   │
│  │     ┌──────────────────┐              │                            │   │
│  │     │ Write to file:   │              │                            │   │
│  │     │ recording_record │              │                            │   │
│  │     │ _input(state,    │              │                            │   │
│  │     │ new_input)       │              │                            │   │
│  │     └──────────────────┘              │                            │   │
│  │              │                        │                            │   │
│  │              └────────────────────────┘                            │   │
│  │                         │                                          │   │
│  └─────────────────────────┼──────────────────────────────────────────┘   │
│                            ▼                                               │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  3. GAME UPDATE                                                     │   │
│  │     game.update_and_render(&memory, new_input, &backbuffer)         │   │
│  │                                                                     │   │
│  │     - Uses new_input (either real or recorded)                      │   │
│  │     - Updates game state in memory                                  │   │
│  │     - Renders to backbuffer                                         │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                            │                                               │
│                            ▼                                               │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  4. AUDIO                                                           │   │
│  │     game.get_audio_samples(&memory, &audio_buffer)                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                            │                                               │
│                            ▼                                               │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  5. DISPLAY                                                         │   │
│  │     opengl_display_buffer(&backbuffer)                              │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                            │                                               │
│                            ▼                                               │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  6. SWAP INPUTS                                                     │   │
│  │     temp = new_input                                                │   │
│  │     new_input = old_input                                           │   │
│  │     old_input = temp                                                │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                            │                                               │
│                            ▼                                               │
│                      NEXT FRAME                                            │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Key Insights

### Why This Works

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        KEY INSIGHTS                                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. DETERMINISM                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  If you give the game:                                                      │
│    - Same starting state                                                    │
│    - Same sequence of inputs                                                │
│                                                                             │
│  You get:                                                                   │
│    - Same exact behavior every time!                                        │
│                                                                             │
│  This is why recording/playback works:                                      │
│    State₀ + Input₀ → State₁                                                 │
│    State₁ + Input₁ → State₂                                                 │
│    State₂ + Input₂ → State₃                                                 │
│    ...                                                                      │
│                                                                             │
│  Same inputs + same starting state = same results                           │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│  2. MEMORY AS A SNAPSHOT                                                    │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  Game state is JUST BYTES in memory.                                        │
│                                                                             │
│  To save:  Copy bytes from memory → file                                    │
│  To load:  Copy bytes from file → memory                                    │
│                                                                             │
│  No serialization needed! No parsing! Just raw bytes.                       │
│                                                                             │
│  ┌────────────────────┐         ┌────────────────────┐                     │
│  │ Memory             │ ──────► │ File               │                     │
│  │ [raw bytes]        │  write  │ [same raw bytes]   │                     │
│  └────────────────────┘         └────────────────────┘                     │
│                                                                             │
│  ┌────────────────────┐         ┌────────────────────┐                     │
│  │ Memory             │ ◄────── │ File               │                     │
│  │ [restored bytes]   │  read   │ [saved bytes]      │                     │
│  └────────────────────┘         └────────────────────┘                     │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│  3. FILE POSITION IS AUTOMATIC                                              │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  Every read/write advances the file position automatically.                 │
│                                                                             │
│  write(fd, data, 100)  →  position += 100                                   │
│  read(fd, buf, 100)    →  position += 100                                   │
│                                                                             │
│  We don't need to manually track where we are in the file!                  │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│  4. EOF DETECTION                                                           │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  read() returns 0 when there's nothing left to read.                        │
│                                                                             │
│  This is NOT an error - it's how we know we've reached the end.             │
│                                                                             │
│  bytes_read = read(fd, buf, 100);                                           │
│  if (bytes_read == 0) {                                                     │
│      // End of file - time to loop!                                         │
│  }                                                                          │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│  5. WHY SLOTS?                                                              │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  Slots let you have multiple recordings:                                    │
│                                                                             │
│  Slot 1: "recording_1.hmi" - Test jumping                                   │
│  Slot 2: "recording_2.hmi" - Test combat                                    │
│  Slot 3: "recording_3.hmi" - Test edge case                                 │
│                                                                             │
│  You could bind different keys to different slots:                          │
│    F1 → Slot 1                                                              │
│    F2 → Slot 2                                                              │
│    F3 → Slot 3                                                              │
│                                                                             │
│  For now, we just use slot 1 with the L key.                                │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│  6. LIVE CODE EDITING                                                       │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  The magic happens because:                                                 │
│                                                                             │
│  1. Game code is in a shared library (.so / .dll)                           │
│  2. Hot reload replaces the code while running                              │
│  3. Playback loop keeps running with NEW code                               │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Loop iteration 1: game.so v1 (player speed = 4)                     │   │
│  │ Loop iteration 2: game.so v1 (player speed = 4)                     │   │
│  │ Loop iteration 3: game.so v1 (player speed = 4)                     │   │
│  │                                                                     │   │
│  │ --- You edit code, change speed to 8, save ---                      │   │
│  │ --- Hot reload detects change, loads new .so ---                    │   │
│  │                                                                     │   │
│  │ Loop iteration 4: game.so v2 (player speed = 8) ◄── NEW CODE!       │   │
│  │ Loop iteration 5: game.so v2 (player speed = 8)                     │   │
│  │ Loop iteration 6: game.so v2 (player speed = 8)                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  Same inputs, different code = different behavior!                          │
│  You can SEE your changes immediately without restarting.                   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Day 25 Updates: Memory-Mapped Replay Buffers

---

### The Performance Problem (Day 24)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    DAY 24 PERFORMANCE ISSUE                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  RECORDING START:                                                           │
│  ─────────────────                                                          │
│                                                                             │
│  User presses L → write(fd, game_memory, 1GB) → DISK                        │
│                                                                             │
│  ┌──────────────┐                           ┌──────────────┐               │
│  │ Game Memory  │ ════════════════════════► │  Disk File   │               │
│  │   (1+ GB)    │      write() syscall      │  (1+ GB)     │               │
│  └──────────────┘      2-5 SECONDS! ❌      └──────────────┘               │
│                                                                             │
│  User experience: GAME FREEZES for seconds!                                 │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  PLAYBACK LOOP:                                                             │
│  ──────────────                                                             │
│                                                                             │
│  End of inputs → read(fd, game_memory, 1GB) → RESTORE                       │
│                                                                             │
│  ┌──────────────┐                           ┌──────────────┐               │
│  │ Game Memory  │ ◄════════════════════════ │  Disk File   │               │
│  │   (1+ GB)    │      read() syscall       │  (1+ GB)     │               │
│  └──────────────┘      2-5 SECONDS! ❌      └──────────────┘               │
│                                                                             │
│  User experience: GAME FREEZES every loop iteration!                        │
│                                                                             │
│  For a 5-second recording looping continuously:                             │
│    - 5 seconds of gameplay                                                  │
│    - 3 seconds of freeze                                                    │
│    - 5 seconds of gameplay                                                  │
│    - 3 seconds of freeze...                                                 │
│                                                                             │
│  This makes live code editing PAINFUL! 😫                                   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### The Solution: Memory-Mapped Files (Day 25)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    DAY 25 SOLUTION: MMAP                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  CONCEPT:                                                                   │
│  ────────                                                                   │
│                                                                             │
│  Instead of reading/writing files, we create a MEMORY REGION that           │
│  the OS automatically syncs to a file in the background.                    │
│                                                                             │
│  For our use case, we don't even care about the file sync -                 │
│  we just need fast RAM-to-RAM copies!                                       │
│                                                                             │
│  ┌──────────────┐     ┌──────────────┐     ┌──────────────┐               │
│  │ Game Memory  │     │ Replay Buffer│     │  Disk File   │               │
│  │   (1+ GB)    │     │   (mmap'd)   │     │  (1+ GB)     │               │
│  └──────────────┘     └──────────────┘     └──────────────┘               │
│         │                    │                    │                        │
│         │    memcpy()        │    OS handles      │                        │
│         │ ═══════════►       │    sync lazily     │                        │
│         │  ~100ms! ✅        │    in background   │                        │
│         │                    │                    │                        │
│         │    memcpy()        │                    │                        │
│         │ ◄═══════════       │                    │                        │
│         │  ~100ms! ✅        │                    │                        │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  PERFORMANCE COMPARISON:                                                    │
│  ───────────────────────                                                    │
│                                                                             │
│  Operation          │ Day 24 (File I/O) │ Day 25 (mmap)  │ Speedup         │
│  ───────────────────┼───────────────────┼────────────────┼─────────────    │
│  Save 1GB state     │ 2-5 seconds       │ 50-100ms       │ 20-50x faster   │
│  Restore 1GB state  │ 2-5 seconds       │ 50-100ms       │ 20-50x faster   │
│  Loop iteration     │ PAINFUL           │ SMOOTH         │ ∞ better UX     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### Platform Abstraction Design

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    PLATFORM ABSTRACTION                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  replay-buffer.c uses your existing cross-platform APIs:                    │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                                                                     │   │
│  │  FROM _common/file.h:                                               │   │
│  │  ────────────────────                                               │   │
│  │  • de100_file_open()   - Create/open replay buffer files            │   │
│  │  • de100_file_close()  - Close file descriptors                     │   │
│  │  • de100_file_seek()   - Seek in input files                        │   │
│  │  • de100_file_read_all()  - Read input frames                       │   │
│  │  • de100_file_write_all() - Write input frames                      │   │
│  │                                                                     │   │
│  │  FROM _common/memory.h:                                             │   │
│  │  ──────────────────────                                             │   │
│  │  • de100_mem_copy()    - Fast memory copy for save/restore          │   │
│  │                                                                     │   │
│  │  PLATFORM-SPECIFIC (isolated in replay-buffer.c):                   │   │
│  │  ─────────────────────────────────────────────────                  │   │
│  │  • platform_mmap_file()    - mmap() / MapViewOfFile()               │   │
│  │  • platform_munmap_file()  - munmap() / UnmapViewOfFile()           │   │
│  │  • platform_file_resize()  - ftruncate() / SetEndOfFile()           │   │
│  │                                                                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  Only mmap/MapViewOfFile requires platform-specific code.                   │
│  Everything else uses _common/ abstractions.                                │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### Windows vs Linux Memory Mapping

```
┌─────────────────────────────────────────────────────────────────────────────┐
│              WINDOWS vs LINUX MEMORY MAPPING                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  WINDOWS (Casey's code):                                                    │
│  ───────────────────────                                                    │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Step 1: CreateFileA(filename, GENERIC_READ|GENERIC_WRITE, ...)      │   │
│  │         └─→ Returns: HANDLE to file                                 │   │
│  │                                                                     │   │
│  │ Step 2: CreateFileMapping(file_handle, NULL, PAGE_READWRITE,        │   │
│  │                           size_high, size_low, NULL)                │   │
│  │         └─→ Returns: HANDLE to mapping object                       │   │
│  │         └─→ NOTE: Size is specified HERE                            │   │
│  │                                                                     │   │
│  │ Step 3: MapViewOfFile(mapping_handle, FILE_MAP_ALL_ACCESS,          │   │
│  │                       0, 0, size)                                   │   │
│  │         └─→ Returns: void* pointer to mapped memory                 │   │
│  │                                                                     │   │
│  │ Usage:  memcpy(mapped_ptr, game_memory, size);  // Save             │   │
│  │         memcpy(game_memory, mapped_ptr, size);  // Restore          │   │
│  │                                                                     │   │
│  │ Cleanup: UnmapViewOfFile(mapped_ptr);                               │   │
│  │          CloseHandle(mapping_handle);                               │   │
│  │          CloseHandle(file_handle);                                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  LINUX (Our implementation):                                                │
│  ────────────────────────────                                               │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Step 1: de100_file_open(filename, DE100_FILE_READ | DE100_FILE_WRITE│   │
│  │                         | DE100_FILE_CREATE | DE100_FILE_TRUNCATE)  │   │
│  │         └─→ Returns: int file descriptor                           │   │
│  │                                                                     │   │
│  │ Step 2: ftruncate(fd, size)                                         │   │
│  │         └─→ CRITICAL: Set file size BEFORE mmap!                    │   │
│  │         └─→ Windows CreateFileMapping does this implicitly          │   │
│  │         └─→ Linux requires explicit sizing                          │   │
│  │                                                                     │   │
│  │ Step 3: mmap(NULL, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0)   │   │
│  │         └─→ Returns: void* pointer to mapped memory                 │   │
│  │         └─→ NULL = let OS choose address                            │   │
│  │         └─→ MAP_SHARED = changes written to file                    │   │
│  │                                                                     │   │
│  │ Usage:  de100_mem_copy(mapped_ptr, game_memory, size);  // Save     │   │
│  │         de100_mem_copy(game_memory, mapped_ptr, size);  // Restore  │   │
│  │                                                                     │   │
│  │ Cleanup: munmap(mapped_ptr, size);                                  │   │
│  │          de100_file_close(fd);                                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  KEY DIFFERENCE:                                                            │
│  ───────────────                                                            │
│                                                                             │
│  Windows: CreateFileMapping specifies size → file grows automatically       │
│  Linux:   mmap maps EXISTING file content → must ftruncate() first!         │
│                                                                             │
│  ❌ COMMON LINUX MISTAKE:                                                   │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ int fd = open("file.bin", O_RDWR | O_CREAT, 0644);                  │   │
│  │ void *ptr = mmap(NULL, 1GB, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);│  │
│  │ // FAILS or gives you 0 bytes! File is empty!                       │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ✅ CORRECT LINUX APPROACH:                                                 │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ int fd = open("file.bin", O_RDWR | O_CREAT | O_TRUNC, 0644);        │   │
│  │ ftruncate(fd, 1GB);  // ← CRITICAL: Set size first!                 │   │
│  │ void *ptr = mmap(NULL, 1GB, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);│  │
│  │ // Now ptr points to 1GB of usable memory                           │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### Replay Buffer Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    REPLAY BUFFER ARCHITECTURE                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  STRUCTURE (defined in _common/replay-buffer.h):                            │
│  ───────────────────────────────────────────────                            │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ ReplayBuffer                                                        │   │
│  │ ┌─────────────────────────────────────────────────────────────────┐ │   │
│  │ │ file_fd: 4                    // File descriptor                │ │   │
│  │ │ memory_block: 0x7f1234560000  // mmap'd region pointer          │ │   │
│  │ │ mapped_size: 1140850688       // Size of mapped region          │ │   │
│  │ │ filename: "/path/loop_edit_0_state.hmi"                         │ │   │
│  │ │ is_valid: true                // Ready for use?                 │ │   │
│  │ │ last_error: REPLAY_BUFFER_SUCCESS                               │ │   │
│  │ └─────────────────────────────────────────────────────────────────┘ │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  STORAGE IN GameMemoryState (game/memory.h):                                │
│  ───────────────────────────────────────────                                │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ GameMemoryState                                                     │   │
│  │ ┌─────────────────────────────────────────────────────────────────┐ │   │
│  │ │ total_size: 1,140,850,688 (permanent + transient)               │ │   │
│  │ │ game_memory: 0x20000000000 (pointer to game state)              │ │   │
│  │ │                                                                 │ │   │
│  │ │ recording_fd: 3 (file descriptor for input file)               │ │   │
│  │ │ input_recording_index: 1 (which slot, 0 = not recording)       │ │   │
│  │ │                                                                 │ │   │
│  │ │ playback_fd: -1 (not playing)                                  │ │   │
│  │ │ input_playing_index: 0 (not playing)                           │ │   │
│  │ │                                                                 │ │   │
│  │ │ replay_buffers[MAX_REPLAY_BUFFERS]:  ◄─── Day 25 addition      │ │   │
│  │ │ ┌─────────────────────────────────────────────────────────────┐│ │   │
│  │ │ │ [0] ReplayBuffer { fd=4, ptr=0x7f..., valid=true }          ││ │   │
│  │ │ │ [1] ReplayBuffer { fd=5, ptr=0x7f..., valid=true } ◄─DEFAULT││ │   │
│  │ │ │ [2] ReplayBuffer { fd=6, ptr=0x7f..., valid=true }          ││ │   │
│  │ │ │ [3] ReplayBuffer { fd=7, ptr=0x7f..., valid=true }          ││ │   │
│  │ │ └─────────────────────────────────────────────────────────────┘│ │   │
│  │ └─────────────────────────────────────────────────────────────────┘ │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  FILE LAYOUT (Day 25 - Separate Files):                                     │
│  ──────────────────────────────────────                                     │
│                                                                             │
│  Day 24 (single file):                                                      │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ loop_edit_1.hmi                                                     │   │
│  │ [GAME STATE (1GB)][INPUT 0][INPUT 1][INPUT 2]...[INPUT N]           │   │
│  │ ├────────────────┤├─────────────────────────────────────────┤       │   │
│  │ │ Written once   ││ Appended each frame                     │       │   │
│  │ │ (slow!)        ││ (fast, small)                           │       │   │
│  │ └────────────────┘└─────────────────────────────────────────┘       │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  Day 25 (separate files):                                                   │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ loop_edit_1_state.hmi (memory-mapped)                               │   │
│  │ [GAME STATE (1GB)]                                                  │   │
│  │ ├────────────────┤                                                  │   │
│  │ │ mmap'd region  │ ◄── de100_mem_copy to/from this (FAST!)          │   │
│  │ └────────────────┘                                                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ loop_edit_1_input.hmi (regular file)                                │   │
│  │ [INPUT 0][INPUT 1][INPUT 2]...[INPUT N]                             │   │
│  │ ├─────────────────────────────────────────┤                         │   │
│  │ │ Regular file I/O (small, fast enough)   │                         │   │
│  │ └─────────────────────────────────────────┘                         │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### API Reference: replay-buffer.h

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    REPLAY BUFFER API                                        │
│                    Location: project/engine/_common/replay-buffer.h         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  CONSTANTS:                                                                 │
│  ──────────                                                                 │
│                                                                             │
│  #define MAX_REPLAY_BUFFERS 4                                               │
│  #define REPLAY_BUFFER_FILENAME_MAX 256                                     │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  ERROR CODES:                                                               │
│  ────────────                                                               │
│                                                                             │
│  typedef enum {                                                             │
│      REPLAY_BUFFER_SUCCESS = 0,                                             │
│      REPLAY_BUFFER_ERROR_NULL_STATE,                                        │
│      REPLAY_BUFFER_ERROR_INVALID_SLOT,                                      │
│      REPLAY_BUFFER_ERROR_NO_GAME_MEMORY,                                    │
│      REPLAY_BUFFER_ERROR_FILE_CREATE_FAILED,                                │
│      REPLAY_BUFFER_ERROR_FILE_RESIZE_FAILED,                                │
│      REPLAY_BUFFER_ERROR_MMAP_FAILED,                                       │
│      REPLAY_BUFFER_ERROR_BUFFER_NOT_VALID,                                  │
│      REPLAY_BUFFER_ERROR_SAVE_FAILED,                                       │
│      REPLAY_BUFFER_ERROR_RESTORE_FAILED,                                    │
│  } ReplayBufferErrorCode;                                                   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  INITIALIZATION:                                                            │
│  ───────────────                                                            │
│                                                                             │
│  ReplayBufferInitResult replay_buffers_init(                                │
│      const char *exe_directory,                                             │
│      void *game_memory,                                                     │
│      uint64 total_size,                                                     │
│      ReplayBuffer *out_buffers);                                            │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Purpose: Create and mmap all replay buffer files                    │   │
│  │                                                                     │   │
│  │ Parameters:                                                         │   │
│  │   exe_directory - Where to create replay files                      │   │
│  │   game_memory   - Pointer to game memory block                      │   │
│  │   total_size    - Size of game memory (permanent + transient)       │   │
│  │   out_buffers   - Array of MAX_REPLAY_BUFFERS to initialize         │   │
│  │                                                                     │   │
│  │ When to call: After game memory is allocated, before main loop     │   │
│  │                                                                     │   │
│  │ Returns: ReplayBufferInitResult with:                               │   │
│  │   .success              - true if at least one buffer initialized   │   │
│  │   .error_code           - Error code if all failed                  │   │
│  │   .buffers_initialized  - Count of successful buffers               │   │
│  │                                                                     │   │
│  │ Example:                                                            │   │
│  │   ReplayBufferInitResult result = replay_buffers_init(              │   │
│  │       exe_dir, game_memory, total_size, state->replay_buffers);     │   │
│  │   if (!result.success) {                                            │   │
│  │       fprintf(stderr, "Warning: %s\n",                              │   │
│  │               replay_buffer_strerror(result.error_code));           │   │
│  │   }                                                                 │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  SHUTDOWN:                                                                  │
│  ─────────                                                                  │
│                                                                             │
│  void replay_buffers_shutdown(ReplayBuffer *buffers, uint64 total_size);    │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Purpose: Unmap and close all replay buffer files                    │   │
│  │                                                                     │   │
│  │ Parameters:                                                         │   │
│  │   buffers    - Array of replay buffers to shutdown                  │   │
│  │   total_size - Size that was mapped (needed for munmap)             │   │
│  │                                                                     │   │
│  │ When to call: During engine shutdown                                │   │
│  │                                                                     │   │
│  │ Note: Files remain on disk (can be reused next run)                 │   │
│  │       Safe to call multiple times (idempotent)                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  GET BUFFER:                                                                │
│  ───────────                                                                │
│                                                                             │
│  ReplayBuffer *replay_buffer_get(ReplayBuffer *buffers, int32 slot_index);  │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Purpose: Get pointer to a specific replay buffer slot               │   │
│  │                                                                     │   │
│  │ Parameters:                                                         │   │
│  │   buffers    - Array of replay buffers                              │   │
│  │   slot_index - Which slot (0 to MAX_REPLAY_BUFFERS-1)               │   │
│  │                                                                     │   │
│  │ Returns: Pointer to ReplayBuffer, or NULL if invalid index          │   │
│  │                                                                     │   │
│  │ Example:                                                            │   │
│  │   ReplayBuffer *buf = replay_buffer_get(state->replay_buffers, 1);  │   │
│  │   if (replay_buffer_is_valid(buf)) {                                │   │
│  │       // Use buf->memory_block                                      │   │
│  │   }                                                                 │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  SAVE STATE:                                                                │
│  ───────────                                                                │
│                                                                             │
│  ReplayBufferResult replay_buffer_save_state(                               │
│      ReplayBuffer *buffer,                                                  │
│      const void *game_memory,                                               │
│      uint64 total_size);                                                    │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Purpose: Snapshot game memory to replay buffer (FAST!)              │   │
│  │                                                                     │   │
│  │ Parameters:                                                         │   │
│  │   buffer      - Target replay buffer                                │   │
│  │   game_memory - Source game memory                                  │   │
│  │   total_size  - Size to copy                                        │   │
│  │                                                                     │   │
│  │ When to call: At start of recording                                 │   │
│  │                                                                     │   │
│  │ What it does:                                                       │   │
│  │   de100_mem_copy(buffer->memory_block, game_memory, total_size)     │   │
│  │                                                                     │   │
│  │ Performance: ~50-100ms for 1GB (vs 2-5 seconds with file I/O)       │   │
│  │                                                                     │   │
│  │ Returns: ReplayBufferResult with success status                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  RESTORE STATE:                                                             │
│  ──────────────                                                             │
│                                                                             │
│  ReplayBufferResult replay_buffer_restore_state(                            │
│      const ReplayBuffer *buffer,                                            │
│      void *game_memory,                                                     │
│      uint64 total_size);                                                    │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Purpose: Restore game memory from replay buffer (FAST!)             │   │
│  │                                                                     │   │
│  │ Parameters:                                                         │   │
│  │   buffer      - Source replay buffer                                │   │
│  │   game_memory - Destination game memory                             │   │
│  │   total_size  - Size to copy                                        │   │
│  │                                                                     │   │
│  │ When to call: At start of playback, and on each loop iteration      │   │
│  │                                                                     │   │
│  │ What it does:                                                       │   │
│  │   de100_mem_copy(game_memory, buffer->memory_block, total_size)     │   │
│  │                                                                     │   │
│  │ Performance: ~50-100ms for 1GB (vs 2-5 seconds with file I/O)       │   │
│  │                                                                     │   │
│  │ Returns: ReplayBufferResult with success status                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  UTILITY FUNCTIONS:                                                         │
│  ──────────────────                                                         │
│                                                                             │
│  bool replay_buffer_is_valid(const ReplayBuffer *buffer);                   │
│  const char *replay_buffer_strerror(ReplayBufferErrorCode code);            │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### Updated Input Recording Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    DAY 25 RECORDING FLOW                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  USER PRESSES 'L' (Start Recording):                                       │
│  ───────────────────────────────────                                        │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 1. input_recording_begin(exe_dir, state, slot=1)                    │   │
│  │    │                                                                │   │
│  │    ├─► Get replay buffer: replay_buffer_get(buffers, 1)             │   │
│  │    │   └─► Returns pointer to pre-initialized mmap'd buffer         │   │
│  │    │                                                                │   │
│  │    ├─► Open input file: de100_file_open("loop_edit_1_input.hmi")    │   │
│  │    │   └─► For recording input frames (small, regular file I/O)    │   │
│  │    │                                                                │   │
│  │    ├─► Save state: replay_buffer_save_state(buffer, game_mem, size) │   │
│  │    │   └─► de100_mem_copy(buffer->memory_block, game_memory, 1GB)   │   │
│  │    │   └─► ~100ms! (was 2-5 seconds)                                │   │
│  │    │                                                                │   │
│  │    └─► Set state->input_recording_index = 1                         │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  EACH FRAME (While Recording):                                              │
│  ─────────────────────────────                                              │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 2. input_recording_record_frame(state, input)                       │   │
│  │    │                                                                │   │
│  │    └─► de100_file_write_all(fd, input, sizeof(GameInput))           │   │
│  │        └─► ~500 bytes per frame (fast, no problem)                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  USER PRESSES 'L' AGAIN (Stop Recording, Start Playback):                   │
│  ────────────────────────────────────────────────────────                   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 3. input_recording_end(state)                                       │   │
│  │    └─► de100_file_close(recording_fd)                               │   │
│  │    └─► state->input_recording_index = 0                             │   │
│  │                                                                     │   │
│  │ 4. input_recording_playback_begin(exe_dir, state, slot=1)           │   │
│  │    │                                                                │   │
│  │    ├─► Get replay buffer: replay_buffer_get(buffers, 1)             │   │
│  │    │                                                                │   │
│  │    ├─► Open input file: de100_file_open("loop_edit_1_input.hmi")    │   │
│  │    │                                                                │   │
│  │    ├─► Restore state: replay_buffer_restore_state(buffer, ...)      │   │
│  │    │   └─► de100_mem_copy(game_memory, buffer->memory_block, 1GB)   │   │
│  │    │   └─► ~100ms! (was 2-5 seconds)                                │   │
│  │    │                                                                │   │
│  │    └─► Set state->input_playing_index = 1                           │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  EACH FRAME (While Playing):                                                │
│  ───────────────────────────                                                │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 5. input_recording_playback_frame(exe_dir, state, input)            │   │
│  │    │                                                                │   │
│  │    ├─► de100_file_read_all(fd, input, sizeof(GameInput))            │   │
│  │    │                                                                │   │
│  │    └─► If EOF (bytes_read == 0):                                    │   │
│  │        │                                                            │   │
│  │        ├─► de100_file_seek(fd, 0, SEEK_SET)  // Back to start       │   │
│  │        │                                                            │   │
│  │        ├─► replay_buffer_restore_state(buffer, game_memory, size)   │   │
│  │        │   └─► de100_mem_copy(game_memory, buffer->memory_block)    │   │
│  │        │   └─► ~100ms! SMOOTH LOOPING!                              │   │
│  │        │                                                            │   │
│  │        └─► de100_file_read_all(fd, input, sizeof(GameInput))        │   │
│  │            └─► Read first input frame                               │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  USER PRESSES 'L' AGAIN (Stop Playback):                                    │
│  ───────────────────────────────────────                                    │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 6. input_recording_playback_end(state)                              │   │
│  │    └─► de100_file_close(playback_fd)                                │   │
│  │    └─► state->input_playing_index = 0                               │   │
│  │    └─► Game continues from current state                            │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### State Machine (Updated for Day 25)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    STATE MACHINE (Day 25)                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                       ┌─────────────┐                                       │
│                       │             │                                       │
│           ┌──────────►│    IDLE     │◄──────────────┐                       │
│           │           │             │               │                       │
│           │           └──────┬──────┘               │                       │
│           │                  │                      │                       │
│           │           Press L│                      │                       │
│           │                  ▼                      │                       │
│           │           ┌─────────────┐               │                       │
│           │           │             │               │                       │
│           │           │  RECORDING  │               │                       │
│           │           │             │               │                       │
│           │           │ • Save state│               │                       │
│           │           │   to mmap   │               │                       │
│           │           │   (~100ms)  │               │                       │
│           │           │             │               │                       │
│           │           │ • Write     │               │                       │
│           │           │   inputs to │               │                       │
│           │           │   file      │               │                       │
│           │           │             │               │                       │
│           │           └──────┬──────┘               │                       │
│           │                  │                      │                       │
│           │           Press L│                      │                       │
│           │                  ▼                      │                       │
│           │           ┌─────────────┐               │                       │
│           │           │             │               │                       │
│           │   ┌──────►│  PLAYBACK   │───────────────┘                       │
│           │   │       │             │     Press L                           │
│           │   │       │ • Restore   │     (Day 25: Can exit!)               │
│           │   │       │   state from│                                       │
│           │   │       │   mmap      │                                       │
│           │   │       │   (~100ms)  │                                       │
│           │   │       │             │                                       │
│           │   │       │ • Read      │                                       │
│           │   │       │   inputs    │                                       │
│           │   │       │   from file │                                       │
│           │   │       │             │                                       │
│           │   │       └─────────────┘                                       │
│           │   │              │                                              │
│           │   │              │ EOF reached                                  │
│           │   │              │                                              │
│           │   └──────────────┘                                              │
│           │     Loop: restore state (~100ms)                                │
│           │            seek to start                                        │
│           │            continue playback                                    │
│           │                                                                 │
│           │                                                                 │
│           │   Day 24: Could NOT exit playback with L                        │
│           │   Day 25: CAN exit playback with L ◄─── NEW!                    │
│           │                                                                 │
└───────────┴─────────────────────────────────────────────────────────────────┘
```

---

### File Structure

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    FILE STRUCTURE                                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  project/engine/                                                            │
│  │                                                                          │
│  ├── _common/                                                               │
│  │   ├── file.h              (existing - file operations)                   │
│  │   ├── file.c              (existing)                                     │
│  │   ├── memory.h            (existing - memory operations)                 │
│  │   ├── memory.c            (existing)                                     │
│  │   ├── replay-buffer.h     (NEW - mmap API)                               │
│  │   └── replay-buffer.c     (NEW - mmap implementation)                    │
│  │                                                                          │
│  ├── game/                                                                  │
│  │   ├── memory.h            (MODIFIED - add replay_buffers array)          │
│  │   └── input.h             (existing)                                     │
│  │                                                                          │
│  ├── platforms/                                                             │
│  │   ├── _common/                                                           │
│  │   │   ├── input-recording.h   (MODIFIED - update signatures)             │
│  │   │   └── input-recording.c   (MODIFIED - use replay buffer API)         │
│  │   │                                                                      │
│  │   └── x11/                                                               │
│  │       └── backend.c           (MODIFIED - update playback_frame call)    │
│  │                                                                          │
│  └── engine.c                    (MODIFIED - init/shutdown replay buffers)  │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  RUNTIME FILES CREATED:                                                     │
│  ──────────────────────                                                     │
│                                                                             │
│  <exe_directory>/                                                           │
│  ├── loop_edit_0_state.hmi   (mmap'd, ~1GB, slot 0)                         │
│  ├── loop_edit_1_state.hmi   (mmap'd, ~1GB, slot 1) ◄── Default slot        │
│  ├── loop_edit_2_state.hmi   (mmap'd, ~1GB, slot 2)                         │
│  ├── loop_edit_3_state.hmi   (mmap'd, ~1GB, slot 3)                         │
│  │                                                                          │
│  ├── loop_edit_0_input.hmi   (regular file, small)                          │
│  ├── loop_edit_1_input.hmi   (regular file, small) ◄── Default slot         │
│  ├── loop_edit_2_input.hmi   (regular file, small)                          │
│  └── loop_edit_3_input.hmi   (regular file, small)                          │
│                                                                             │
│  Note: State files are created at engine init (pre-allocated)               │
│        Input files are created when recording starts                        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### Integration Checklist

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    INTEGRATION CHECKLIST                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  FILES TO CREATE:                                                           │
│  ─────────────────                                                          │
│  [ ] _common/replay-buffer.h                                                │
│  [ ] _common/replay-buffer.c                                                │
│                                                                             │
│  FILES TO MODIFY:                                                           │
│  ─────────────────                                                          │
│  [ ] game/memory.h                                                          │
│      • Add: #include "../_common/replay-buffer.h"                           │
│      • Add: ReplayBuffer replay_buffers[MAX_REPLAY_BUFFERS];                │
│                                                                             │
│  [ ] platforms/_common/input-recording.h                                    │
│      • Update: playback_frame signature (add exe_directory param)           │
│                                                                             │
│  [ ] platforms/_common/input-recording.c                                    │
│      • Add: #include "../../_common/replay-buffer.h"                        │
│      • Update: input_recording_begin() to use replay_buffer_save_state()    │
│      • Update: input_recording_playback_begin() to use restore              │
│      • Update: input_recording_playback_frame() to use restore on loop      │
│      • Update: get_input_filename() for separate input files                │
│                                                                             │
│  [ ] engine/engine.c                                                        │
│      • Add: #include "_common/replay-buffer.h"                              │
│      • Add: replay_buffers_init() call in engine_init()                     │
│      • Add: replay_buffers_shutdown() call in engine_shutdown()             │
│                                                                             │
│  [ ] platforms/x11/backend.c                                                │
│      • Update: input_recording_playback_frame() call signature              │
│                                                                             │
│  BUILD SCRIPT:                                                              │
│  ─────────────                                                              │
│  [ ] Add _common/replay-buffer.c to compilation                             │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  TESTING:                                                                   │
│  ────────                                                                   │
│  [ ] Engine starts without errors                                           │
│  [ ] "Replay buffers: 4/4 initialized" message appears                      │
│  [ ] Press L → Recording starts (no freeze!)                                │
│  [ ] Press L → Playback starts (no freeze!)                                 │
│  [ ] Playback loops smoothly (no freeze on loop!)                           │
│  [ ] Press L → Playback stops (Day 25 feature!)                             │
│  [ ] Engine shuts down cleanly                                              │
│  [ ] State files exist in exe directory (~1GB each)                         │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### Comparison: Day 24 vs Day 25

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    DAY 24 vs DAY 25 COMPARISON                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  FEATURE                    │ DAY 24              │ DAY 25                  │
│  ───────────────────────────┼─────────────────────┼─────────────────────────│
│  State storage              │ File I/O            │ Memory-mapped file      │
│  Save state time (1GB)      │ 2-5 seconds         │ 50-100ms                │
│  Restore state time (1GB)   │ 2-5 seconds         │ 50-100ms                │
│  Loop iteration feel        │ PAINFUL freeze      │ SMOOTH                  │
│  Exit playback with L       │ ❌ No               │ ✅ Yes                  │
│  File layout                │ Single file         │ Separate state/input    │
│  Startup cost               │ None                │ mmap 4 files (~4GB)     │
│  Disk space                 │ ~1GB per slot       │ ~1GB per slot (same)    │
│  Code complexity            │ Simple              │ Slightly more complex   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  WHY THE SPEEDUP?                                                           │
│  ────────────────                                                           │
│                                                                             │
│  Day 24 (File I/O):                                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ User Space          │ Kernel Space         │ Hardware               │   │
│  │                     │                      │                        │   │
│  │ write(fd, buf, 1GB) │                      │                        │   │
│  │        │            │                      │                        │   │
│  │        └───────────►│ Copy to page cache   │                        │   │
│  │                     │        │             │                        │   │
│  │                     │        └────────────►│ Write to disk          │   │
│  │                     │                      │ (or schedule write)    │   │
│  │                     │                      │                        │   │
│  │ BLOCKS until kernel │                      │                        │   │
│  │ copies all data     │                      │                        │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  Day 25 (mmap + memcpy):                                                    │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ User Space                                                          │   │
│  │                                                                     │   │
│  │ memcpy(mmap_region, game_memory, 1GB)                               │   │
│  │        │                                                            │   │
│  │        └─► Direct RAM-to-RAM copy                                   │   │
│  │            No syscalls!                                             │   │
│  │            No kernel involvement!                                   │   │
│  │            Just CPU + memory bus                                    │   │
│  │                                                                     │   │
│  │ OS syncs to disk LATER, in background                               │   │
│  │ (we don't care - we just need the RAM copy)                         │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  The mmap'd region IS memory. Writing to it is just writing to RAM.         │
│  The OS handles syncing to disk lazily, in the background.                  │
│  For our use case (looping replay), we never even need the disk sync!       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### Casey's Key Insight

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    CASEY'S KEY INSIGHT                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  "The file is just there so the OS has somewhere to page the memory         │
│   if it needs to. We're not actually using it as a file - we're using       │
│   it as a named chunk of virtual memory that happens to be backed by        │
│   disk storage."                                                            │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  MENTAL MODEL:                                                              │
│  ─────────────                                                              │
│                                                                             │
│  Think of mmap'd files as:                                                  │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                                                                     │   │
│  │  NOT: "A file that I can access like memory"                        │   │
│  │                                                                     │   │
│  │  BUT: "Memory that happens to be backed by a file"                  │   │
│  │                                                                     │   │
│  │  The file is an implementation detail.                              │   │
│  │  What you have is a pointer to a region of RAM.                     │   │
│  │  You can read/write it at full memory speed.                        │   │
│  │                                                                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  WEB DEVELOPER ANALOGY:                                                     │
│  ──────────────────────                                                     │
│                                                                             │
│  Day 24 (File I/O):                                                         │
│    Like using fetch() with await - blocking, goes to network/disk           │
│                                                                             │
│  Day 25 (mmap):                                                             │
│    Like using SharedArrayBuffer - direct memory access, no async            │
│                                                                             │
│  The mmap'd region is essentially a SharedArrayBuffer that the OS           │
│  automatically persists to disk when convenient.                            │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### Common Mistakes to Avoid

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    COMMON MISTAKES                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ❌ MISTAKE 1: Forgetting ftruncate() on Linux                              │
│  ─────────────────────────────────────────────                              │
│                                                                             │
│  // WRONG:                                                                  │
│  int fd = open("file.bin", O_RDWR | O_CREAT, 0644);                         │
│  void *ptr = mmap(NULL, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);     │
│  // ptr is valid but maps 0 bytes! File is empty!                           │
│                                                                             │
│  // CORRECT:                                                                │
│  int fd = open("file.bin", O_RDWR | O_CREAT | O_TRUNC, 0644);               │
│  ftruncate(fd, size);  // ← Set file size FIRST!                            │
│  void *ptr = mmap(NULL, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);     │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  ❌ MISTAKE 2: Using MAP_PRIVATE instead of MAP_SHARED                      │
│  ─────────────────────────────────────────────────────                      │
│                                                                             │
│  MAP_PRIVATE = Copy-on-write, changes NOT saved to file                     │
│  MAP_SHARED  = Changes written to file (what we want)                       │
│                                                                             │
│  For replay buffers, we want MAP_SHARED so the state persists.              │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  ❌ MISTAKE 3: Forgetting to munmap() before close()                        │
│  ────────────────────────────────────────────────────                       │
│                                                                             │
│  // WRONG:                                                                  │
│  close(fd);  // File closed but memory still mapped!                        │
│  // Accessing ptr now is undefined behavior                                 │
│                                                                             │
│  // CORRECT:                                                                │
│  munmap(ptr, size);  // Unmap first                                         │
│  close(fd);          // Then close                                          │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  ❌ MISTAKE 4: Not checking mmap() return value                             │
│  ──────────────────────────────────────────────                             │
│                                                                             │
│  // WRONG:                                                                  │
│  void *ptr = mmap(...);                                                     │
│  memcpy(ptr, data, size);  // Crash if mmap failed!                         │
│                                                                             │
│  // CORRECT:                                                                │
│  void *ptr = mmap(...);                                                     │
│  if (ptr == MAP_FAILED) {                                                   │
│      perror("mmap failed");                                                 │
│      return error;                                                          │
│  }                                                                          │
│  memcpy(ptr, data, size);                                                   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  ❌ MISTAKE 5: Wrong size to munmap()                                       │
│  ─────────────────────────────────────                                      │
│                                                                             │
│  // WRONG:                                                                  │
│  munmap(ptr, 0);  // Size 0 does nothing!                                   │
│                                                                             │
│  // CORRECT:                                                                │
│  munmap(ptr, original_mapped_size);  // Must match mmap size                │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### Performance Expectations

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    PERFORMANCE EXPECTATIONS                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  MEMORY COPY SPEED (approximate):                                           │
│  ─────────────────────────────────                                          │
│                                                                             │
│  Modern DDR4 RAM: ~25-50 GB/s bandwidth                                     │
│  memcpy 1GB: ~20-40ms theoretical minimum                                   │
│  Real-world with cache effects: ~50-100ms                                   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  DISK I/O SPEED (approximate):                                              │
│  ─────────────────────────────                                              │
│                                                                             │
│  HDD: ~100-200 MB/s → 1GB takes 5-10 seconds                                │
│  SATA SSD: ~500 MB/s → 1GB takes 2 seconds                                  │
│  NVMe SSD: ~2-3 GB/s → 1GB takes 300-500ms                                  │
│                                                                             │
│  But file I/O also has:                                                     │
│  • System call overhead                                                     │
│  • Kernel buffer copies                                                     │
│  • File system overhead                                                     │
│  • Potential disk seeks                                                     │
│                                                                             │
│  Real-world file write 1GB: 2-5 seconds (even on SSD)                       │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  EXPECTED RESULTS:                                                          │
│  ─────────────────                                                          │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Operation              │ Day 24        │ Day 25       │ Improvement │   │
│  │ ───────────────────────┼───────────────┼──────────────┼─────────────│   │
│  │ Start recording        │ 2-5 sec       │ 50-100ms     │ 20-50x      │   │
│  │ Start playback         │ 2-5 sec       │ 50-100ms     │ 20-50x      │   │
│  │ Loop iteration         │ 2-5 sec       │ 50-100ms     │ 20-50x      │   │
│  │ Record input frame     │ <1ms          │ <1ms         │ Same        │   │
│  │ Playback input frame   │ <1ms          │ <1ms         │ Same        │   │
│  │ Engine startup         │ ~0ms          │ ~100-500ms   │ Slower*     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  * Engine startup is slower because we pre-create and mmap 4 files          │
│    (~4GB total). This is a one-time cost that enables smooth looping.       │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  USER EXPERIENCE:                                                           │
│  ────────────────                                                           │
│                                                                             │
│  Day 24:                                                                    │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ [Play 5 sec][FREEZE 3 sec][Play 5 sec][FREEZE 3 sec][Play 5 sec]... │   │
│  │                                                                     │   │
│  │ "This is unusable for live code editing!"                           │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  Day 25:                                                                    │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ [Play 5 sec][tiny hiccup][Play 5 sec][tiny hiccup][Play 5 sec]...   │   │
│  │                                                                     │   │
│  │ "Smooth! I can edit code and see changes instantly!"                │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### Debugging Tips

````
┌─────────────────────────────────────────────────────────────────────────────┐
│                    DEBUGGING TIPS                                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  VERIFY MMAP IS WORKING:                                                    │
│  ───────────────────────                                                    │
│                                                                             │
│  Add timing to replay_buffer_save_state():                                  │
│                                                                             │
│  ```c                                                                       │
│  #include <time.h>                                                          │
│                                                                             │
│  ReplayBufferResult replay_buffer_save_state(...) {                         │
│      struct timespec start, end;                                            │
│      clock_gettime(CLOCK_MONOTONIC, &start);                                │
│                                                                             │
│      de100_mem_copy(buffer->memory_block, game_memory, total_size);         │
│                                                                             │
│      clock_gettime(CLOCK_MONOTONIC, &end);                                  │
│      double ms = (end.tv_sec - start.tv_sec) * 1000.0 +                     │
│                  (end.tv_nsec - start.tv_nsec) / 1000000.0;                 │
│      printf("[REPLAY] Save state: %.2f ms\n", ms);                          │
│      // Should be 50-100ms, NOT 2000-5000ms!                                │
│  }                                                                          │
│  ```                                                                        │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  CHECK MMAP FILES EXIST:                                                    │
│  ───────────────────────                                                    │
│                                                                             │
│  ```bash                                                                    │
│  $ ls -lh /path/to/exe/loop_edit_*                                          │
│  -rw-r--r-- 1 user user 1.1G Jan 15 10:00 loop_edit_0_state.hmi             │
│  -rw-r--r-- 1 user user 1.1G Jan 15 10:00 loop_edit_1_state.hmi             │
│  -rw-r--r-- 1 user user 1.1G Jan 15 10:00 loop_edit_2_state.hmi             │
│  -rw-r--r-- 1 user user 1.1G Jan 15 10:00 loop_edit_3_state.hmi             │
│  -rw-r--r-- 1 user user  15K Jan 15 10:05 loop_edit_1_input.hmi             │
│  ```                                                                        │
│                                                                             │
│  State files should be ~1GB each (your total_size)                          │
│  Input files should be small (sizeof(GameInput) * frame_count)              │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  CHECK MEMORY MAPPINGS:                                                     │
│  ──────────────────────                                                     │
│                                                                             │
│  ```bash                                                                    │
│  $ cat /proc/$(pgrep your_game)/maps | grep loop_edit                       │
│  7f1234560000-7f1678900000 rw-s 00000000 08:01 12345 /path/loop_edit_0.hmi  │
│  7f1678900000-7f1abcd00000 rw-s 00000000 08:01 12346 /path/loop_edit_1.hmi  │
│  ...                                                                        │
│  ```                                                                        │
│                                                                             │
│  The 'rw-s' means: read, write, shared (MAP_SHARED)                         │
│  The addresses show where the files are mapped in memory                    │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  COMMON ISSUES:                                                             │
│  ──────────────                                                             │
│                                                                             │
│  Issue: "mmap failed: No space left on device"                              │
│  Cause: Disk full, can't create 4GB of files                                │
│  Fix:   Free disk space or reduce MAX_REPLAY_BUFFERS                        │
│                                                                             │
│  Issue: "mmap failed: Cannot allocate memory"                               │
│  Cause: Not enough virtual address space (rare on 64-bit)                   │
│  Fix:   Check ulimit -v, or reduce buffer count                             │
│                                                                             │
│  Issue: State not restoring correctly                                       │
│  Cause: total_size mismatch between save and restore                        │
│  Fix:   Ensure same size passed to both functions                           │
│                                                                             │
│  Issue: Segfault when accessing buffer->memory_block                        │
│  Cause: mmap failed but not checked, or buffer not initialized              │
│  Fix:   Always check replay_buffer_is_valid() before use                    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
````

---

### Summary

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    DAY 25 SUMMARY                                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  WHAT WE LEARNED:                                                           │
│  ─────────────────                                                          │
│                                                                             │
│  1. File I/O is SLOW for large data (1GB+ takes seconds)                    │
│                                                                             │
│  2. Memory-mapped files give us RAM-speed access to file-backed memory      │
│                                                                             │
│  3. memcpy() between RAM regions is 20-50x faster than file I/O             │
│                                                                             │
│  4. The OS handles disk sync in the background (we don't wait for it)       │
│                                                                             │
│  5. Pre-allocating buffers at startup trades startup time for runtime       │
│     smoothness                                                              │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  WHAT WE BUILT:                                                             │
│  ───────────────                                                            │
│                                                                             │
│  1. replay-buffer.h/c - Platform-independent mmap abstraction               │
│     • Uses existing de100_file_* and de100_mem_* APIs                       │
│     • Only mmap/munmap is platform-specific                                 │
│                                                                             │
│  2. Updated input-recording.c to use replay buffers                         │
│     • Save state: memcpy to mmap'd region (~100ms)                          │
│     • Restore state: memcpy from mmap'd region (~100ms)                     │
│     • Smooth looping for live code editing!                                 │
│                                                                             │
│  3. Day 25 feature: Can exit playback with L key                            │
│     • Day 24: L during playback did nothing                                 │
│     • Day 25: L during playback stops playback                              │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  KEY TAKEAWAY:                                                              │
│  ─────────────                                                              │
│                                                                             │
│  "When you need fast access to large data, think about whether you          │
│   actually need FILE I/O, or whether you just need MEMORY that happens      │
│   to be backed by a file. Memory-mapped files give you the latter."         │
│                                                                             │
│                                                    - Casey Muratori         │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```
