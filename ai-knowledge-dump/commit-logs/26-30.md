# ğŸ“ Handmade Hero: Learning Notes _(LLM enerated from commits using VSCode Copilote/Claude Opus 4.5)_

## ğŸ“… Days Summary

### ğŸ“† Day 026-027: Introduction to Game Architecture & Exploration-based Architecture

**Focus:** Refactoring game architecture, cleaning up game state, and establishing exploration-based code structure with clear platform/game separation.

#### ğŸ—“ï¸ Commits

| Date       | Commit    | What Changed                                                       | What I Changed & Why                                                                                                                                                                  |
| ---------- | --------- | ------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 2026-02-10 | `0500f89` | Refactored platform organization, cleaned up game state management | Removed unused state structs (`GradientState`, `PixelState`, `PlayerState`), introduced `draw_rect()` for cleaner rendering, restructured README to document platform/game boundaries |

#### ğŸ“Š Architecture Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        EXPLORATION-BASED ARCHITECTURE               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚  engine/platforms/[platform]/          games/handmade-hero/src/     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ hooks/                  â”‚           â”‚ adapters/[platform]/    â”‚  â”‚
â”‚  â”‚   inputs/               â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚   inputs/               â”‚  â”‚
â”‚  â”‚     â”œâ”€â”€ joystick.h      â”‚  EXPOSES  â”‚     â”œâ”€â”€ joystick.c      â”‚  â”‚
â”‚  â”‚     â””â”€â”€ keyboard.h      â”‚  HEADERS  â”‚     â””â”€â”€ keyboard.c      â”‚  â”‚
â”‚  â”‚   utils.c               â”‚           â”‚                         â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚            â”‚                                      â”‚                 â”‚
â”‚            â–¼                                      â–¼                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Platform Reality        â”‚           â”‚ Game Logic              â”‚  â”‚
â”‚  â”‚ - Timing                â”‚           â”‚ - State management      â”‚  â”‚
â”‚  â”‚ - Audio backend         â”‚           â”‚ - Rendering             â”‚  â”‚
â”‚  â”‚ - Window management     â”‚           â”‚ - Input â†’ Actions       â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### ğŸ“ Directory Structure Changes

```
BEFORE (Day 25)                    AFTER (Day 26-27)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
engine/                            engine/
â”œâ”€â”€ platform/                      â”œâ”€â”€ platforms/           â† Renamed
â”‚   â””â”€â”€ x11/                       â”‚   â”œâ”€â”€ _common/         â† NEW: Shared logic
â”‚       â”œâ”€â”€ backend.c              â”‚   â”œâ”€â”€ x11/
â”‚       â””â”€â”€ audio.c                â”‚   â”‚   â”œâ”€â”€ backend.c
                                   â”‚   â”‚   â”œâ”€â”€ audio.c
                                   â”‚   â”‚   â””â”€â”€ hooks/       â† NEW
                                   â”‚   â”‚       â”œâ”€â”€ inputs/
                                   â”‚   â”‚       â”‚   â”œâ”€â”€ joystick.h
                                   â”‚   â”‚       â”‚   â””â”€â”€ keyboard.h
                                   â”‚   â”‚       â””â”€â”€ utils.c
                                   â”‚   â””â”€â”€ raylib/          â† NEW platform
                                   â”‚       â””â”€â”€ ...

games/handmade-hero/               games/handmade-hero/
â””â”€â”€ src/                           â””â”€â”€ src/
    â”œâ”€â”€ main.c                         â”œâ”€â”€ adapters/        â† NEW
    â”œâ”€â”€ main.h                         â”‚   â”œâ”€â”€ x11/inputs/
    â”œâ”€â”€ init.c                         â”‚   â””â”€â”€ raylib/inputs/
    â””â”€â”€ startup.c                      â”œâ”€â”€ init.c
                                       â”œâ”€â”€ inputs.h         â† NEW: Game actions
                                       â”œâ”€â”€ main.c
                                       â”œâ”€â”€ main.h
                                       â””â”€â”€ startup.c
```

#### ğŸ¯ Core Concepts

| Concept                        | Implementation                                                 | What I Learned / Adapted & Why                                                                                                                     |
| ------------------------------ | -------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |
| Exploration-based architecture | Code structured for experimentation, not premature abstraction | Casey advocates writing code first, abstracting later. I applied this by removing over-engineered state structs that weren't serving a purpose yet |
| Platform/Game separation       | `hooks/` expose headers, `adapters/` implement them            | Clear boundary: platform provides interface, game implements behavior. This allows swapping backends (X11â†”raylib) without touching game logic      |
| State cleanup                  | Removed `GradientState`, `PixelState`, `PlayerState`           | These were placeholder structures from early experimentation; keeping them added cognitive overhead without value                                  |
| Primitive rendering            | `draw_rect()` replaces complex `render_player()`               | Start with simplest possible primitive; build complexity as needed                                                                                 |

#### ğŸ’» Code Snippets with Explanations

**1. Simplified Rectangle Drawing**

```c
// filepath: games/handmade-hero/src/main.c

de100_file_scoped_fn void draw_rect(GameBackBuffer *backbuffer,
                                    f32 real_min_x, f32 real_min_y,
                                    f32 real_max_x, f32 real_max_y,
                                    u32 color) {
  // Clamp to buffer bounds - prevents out-of-bounds writes
  i32 min_x = real_min_x < 0 ? 0 : round_f32_to_int32(real_min_x);
  i32 min_y = real_min_y < 0 ? 0 : round_f32_to_int32(real_min_y);
  i32 max_x = real_max_x > backbuffer->width
                    ? backbuffer->width
                    : round_f32_to_int32(real_max_x);
  i32 max_y = real_max_y > backbuffer->height
                    ? backbuffer->height
                    : round_f32_to_int32(real_max_y);

  // Calculate starting memory position
  u8 *xy_mem_pos =
      (u8 *)backbuffer->memory.base +           // Base address
      backbuffer->bytes_per_pixel * min_x +        // X offset (columns)
      backbuffer->pitch * min_y;                   // Y offset (rows)

  // Fill rectangle row by row
  for (i32 y = min_y; y < max_y; ++y) {
    u32 *pixel_mem_pos = (u32 *)xy_mem_pos;
    for (i32 x = min_x; x < max_x; ++x) {
      *pixel_mem_pos++ = color;  // Write pixel, advance pointer
    }
    xy_mem_pos += backbuffer->pitch;  // Move to next row
  }
}
```

**Why this approach:**

- Uses `f32` for sub-pixel precision (future animation smoothness)
- Boundary clamping prevents buffer overflows
- Row-by-row traversal is cache-friendly (sequential memory access)
- Removed wrapping logic from `render_player()` - YAGNI until needed

**2. Memory Layout for Rectangle Fill**

```
Backbuffer Memory (width=960, height=540, pitch=3840)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Row 0: [pixel][pixel][pixel]...                    â”‚ â† pitch bytes
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Row 1: [pixel][pixel][pixel]...                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ...                                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Row min_y: â–‘â–‘â–‘â–‘[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ]â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘              â”‚ â† Start drawing
â”‚            â†‘   â†‘min_x      â†‘max_x                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Row ...:   â–‘â–‘â–‘â–‘[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ]â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Row max_y: â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘              â”‚ â† Stop drawing
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Starting offset = base + (bytes_per_pixel Ã— min_x) + (pitch Ã— min_y)
Next row        = current + pitch
```

**3. Cleaned Game State**

```c
// filepath: games/handmade-hero/src/main.h

// BEFORE (Day 25) - Over-engineered for exploration phase
typedef struct { i32 offset_x, offset_y; } GradientState;  // REMOVED
typedef struct { i32 offset_x, offset_y; } PixelState;     // REMOVED
typedef struct { i32 x, y; f32 t_jump; } PlayerState;   // REMOVED

// AFTER (Day 26-27) - Minimal state for current needs
typedef struct {
  GameAudioState audio;      // Essential: audio playback
  FILE *recording_handle;    // Debug: input recording
  FILE *playback_handle;     // Debug: input playback
  i32 speed;               // Minimal game state
} HandMadeHeroGameState;
```

**Why I removed these:**

- `GradientState`: Only used for debug gradient animation - can recreate if needed
- `PixelState`: Test animation state - not core game functionality
- `PlayerState`: Premature player abstraction - we don't know what player needs yet

**4. Audio Temporarily Silenced**

```c
// filepath: games/handmade-hero/src/main.c

for (int sample_index = 0; sample_index < audio_buffer->sample_count;
     ++sample_index) {
#if 0
  // Original sine wave generation - disabled for cleaner debugging
  f32 sine_value = sinf(tone->phase);
  i16 sample_value = (i16)(sine_value * sample_volume);
#endif
  i16 sample_value = 0 * sample_volume;  // Silent output
  // ...
}
```

**Why:** Focusing on architecture/rendering. Audio adds noise during debugging. `#if 0` preserves code for easy restoration.

**5. Rounding Helper**

```c
de100_file_scoped_fn i32 round_f32_to_int32(f32 num) {
  i32 result = (i32)(num + 0.5f);
  // TODO: Intrinsic????
  // Casey notes: Could use _mm_cvtss_si32 for SSE rounding
  // For now, simple cast-based rounding is sufficient
  return (result);
}
```

#### ğŸ”„ Before/After Comparison

| Aspect           | Before (Day 25)                 | After (Day 26-27)                     |
| ---------------- | ------------------------------- | ------------------------------------- |
| Rendering        | `render_player()` with wrapping | `draw_rect()` - simple primitive      |
| State            | 4 embedded structs              | 1 minimal struct                      |
| Platform dirs    | `engine/platform/`              | `engine/platforms/` (plural, clearer) |
| Input flow       | Implicit                        | Explicit hooks â†’ adapters pattern     |
| Audio            | Active sine wave                | Silenced (`0 * volume`)               |
| Control handling | Complex analog/digital paths    | Stubbed with `#if 0`                  |

#### ğŸ› Common Pitfalls

| Issue                         | Cause                                          | Fix                                                             | My Encountered Issues & Solutions                             |
| ----------------------------- | ---------------------------------------------- | --------------------------------------------------------------- | ------------------------------------------------------------- |
| Premature abstraction         | Creating structures before understanding needs | Delete unused code, rebuild when needed                         | Removed 3 state structs that added complexity without benefit |
| Tight coupling                | Platform code mixed with game logic            | Separate `hooks/` (interface) from `adapters/` (implementation) | New directory structure enforces boundaries                   |
| Over-commenting archived code | `#if 0` blocks with no context                 | Leave TODO explaining why disabled                              | Added comments explaining audio silence is intentional        |

#### âœ… Skills Acquired

- âœ… **Exploration-based architecture** - Write first, abstract later
- âœ… **Aggressive cleanup** - Removing code is as important as writing it
- âœ… **Platform abstraction pattern** - hooks (headers) + adapters (implementations)
- âœ… **Cache-friendly rendering** - Row-by-row buffer traversal
- âœ… **Boundary clamping** - Prevent buffer overflows in drawing routines
- âœ… **Real32 coordinates** - Sub-pixel precision for smooth future animation
- âœ… **Documentation structure** - Clear README showing architecture decisions

#### ğŸ“ Casey's Philosophy Applied

> "Don't write code you don't need yet."

This day exemplified removing speculative code:

- Removed player wrapping (no wraparound gameplay yet)
- Removed jump physics (no platforming yet)
- Removed analog deadzone processing (not testing controllers)
- Silenced audio (focusing on rendering)

The result: **~100 lines removed**, cleaner mental model, easier debugging.

### ğŸ“† Day 028: Drawing a Tile Map

**Focus:** Implementing tile-based world rendering with player movement and frame-time-independent controls.

#### ğŸ—“ï¸ Commits

| Date       | Commit    | What Changed                                          | What I Changed & Why                                                                                                                                          |
| ---------- | --------- | ----------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 2026-02-10 | `995c2c7` | Tile map rendering, player state, frame-time controls | Added `TileState` and `PlayerState` structures, implemented tile grid rendering, refactored `draw_rect()` to use RGBA floats, added hot-reload watcher script |

#### ğŸ“Š Tile Map Coordinate System

```
Screen Space (pixels)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (0,0)                                                              â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚    â”‚ upper_left_x=-30, upper_left_y=0                         â”‚    â”‚
â”‚    â”‚    â–¼                                                     â”‚    â”‚
â”‚    â”‚    â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”        â”‚    â”‚
â”‚    â”‚    â”‚ W  â”‚ W  â”‚ W  â”‚ W  â”‚ W  â”‚ W  â”‚ W  â”‚ W  â”‚    â”‚ ...    â”‚    â”‚
â”‚    â”‚    â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤        â”‚    â”‚
â”‚    â”‚    â”‚ W  â”‚ W  â”‚    â”‚    â”‚    â”‚ W  â”‚    â”‚    â”‚    â”‚ ...    â”‚    â”‚
â”‚    â”‚    â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤        â”‚    â”‚
â”‚    â”‚    â”‚ W  â”‚ W  â”‚    â”‚ ğŸŸ¡ â”‚    â”‚    â”‚    â”‚    â”‚ W  â”‚ ...    â”‚    â”‚
â”‚    â”‚    â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤        â”‚    â”‚
â”‚    â”‚    â”‚ W  â”‚    â”‚    â”‚    â”‚    â”‚    â”‚    â”‚    â”‚ W  â”‚ ...    â”‚    â”‚
â”‚    â”‚    â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜        â”‚    â”‚
â”‚    â”‚                                                          â”‚    â”‚
â”‚    â”‚    W = Wall (tile_id=1, gray=1.0)                        â”‚    â”‚
â”‚    â”‚      = Floor (tile_id=0, gray=0.5)                       â”‚    â”‚
â”‚    â”‚    ğŸŸ¡ = Player                                            â”‚    â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                        (960,540)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Tile Position Calculation:
  min_x = upper_left_x + col * tile_width
  min_y = upper_left_y + row * tile_height

Example: Tile at row=2, col=3 with tile_width=60:
  min_x = -30 + 3 * 60 = 150
  min_y =   0 + 2 * 60 = 120
```

#### ğŸ“Š Frame-Time Independent Movement

```
WRONG: Position-based (frame-rate dependent)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  60 FPS: player_x += 4 pixels/frame â†’ 240 pixels/second
  30 FPS: player_x += 4 pixels/frame â†’ 120 pixels/second âŒ

RIGHT: Velocity-based (frame-rate independent)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  d_player_x = direction * speed;           // pixels/second
  player_x += d_player_x * frame_time;      // Î”position

  60 FPS: player_x += 64 * 0.0166 = 1.06 pixels/frame â†’ 64 pixels/second âœ…
  30 FPS: player_x += 64 * 0.0333 = 2.13 pixels/frame â†’ 64 pixels/second âœ…
```

#### ğŸ¯ Core Concepts

| Concept             | Implementation                   | What I Learned / Adapted & Why                                           |
| ------------------- | -------------------------------- | ------------------------------------------------------------------------ |
| Tile map storage    | `u32 map[9][17]` fixed array     | Simple 2D array - no dynamic allocation needed for exploration           |
| Tile rendering      | Nested loops with position math  | `min_x = offset + col * width` pattern for grid positioning              |
| Frame-time movement | `position += velocity * dt`      | Decouples game speed from frame rate - essential for consistent gameplay |
| Color as floats     | `draw_rect(..., r, g, b, a)`     | More intuitive than hex, easier color math, portable across backends     |
| Player centering    | Position is center, not top-left | `left = x - width/2` makes rotation/scaling easier later                 |
| Hot reload watcher  | `entr` file watcher script       | Linux alternative to Visual Studio's auto-rebuild                        |

#### ğŸ’» Code Snippets with Explanations

**1. Tile Map Data Structure**

```c
// filepath: games/handmade-hero/src/main.h

typedef struct {
  u32 map[9][17];      // 9 rows Ã— 17 columns of tile IDs
  f32 upper_left_x;    // World offset for camera/scrolling
  f32 upper_left_y;
  f32 width;           // Tile dimensions in pixels
  f32 height;
} TileState;

// Initialization in init.c:
u32 temp_map[9][17] = {
    {1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1},  // Top wall with door
    {1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1},  // Room interior
    // ... more rows
    {1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1},  // Bottom wall
};
de100_mem_copy(game_state->tile_state.map, temp_map, sizeof(temp_map));
```

**Why this approach:**

- Fixed-size array avoids allocation complexity during exploration
- `0` = walkable floor, `1` = wall - simple collision check later
- `upper_left_x=-30` offsets the map slightly for visual padding

**2. Tile Map Rendering Loop**

```c
// filepath: games/handmade-hero/src/main.c

TileState *tile_state = &game_state->tile_state;
for (u32 row = 0; row < ArraySize(tile_state->map); ++row) {
    for (u32 col = 0; col < ArraySize(tile_state->map[0]); ++col) {
        u32 tile_id = tile_state->map[row][col];
        f32 gray = tile_id == 1 ? 1.0f : 0.5f;  // Wall=white, Floor=gray

        // Calculate screen position from tile coordinates
        f32 min_x = tile_state->upper_left_x + (f32)col * tile_state->width;
        f32 min_y = tile_state->upper_left_y + (f32)row * tile_state->height;
        f32 max_x = min_x + tile_state->width;
        f32 max_y = min_y + tile_state->height;

        draw_rect(buffer, min_x, min_y, max_x, max_y, gray, gray, gray, 1.0f);
    }
}
```

**Why this approach:**

- `ArraySize()` macro calculates dimensions at compile time
- Row-major traversal matches C array memory layout
- Colors as floats: `gray, gray, gray` is more readable than `0xFFAAAAAA`

**3. Float-Based Color in draw_rect()**

```c
// filepath: games/handmade-hero/src/main.c

de100_file_scoped_fn void draw_rect(GameBackBuffer *backbuffer,
                                    f32 real_min_x, f32 real_min_y,
                                    f32 real_max_x, f32 real_max_y,
                                    f32 r, f32 g, f32 b, f32 a) {
  // ... bounds clamping ...

  // Convert float [0.0-1.0] to packed AARRGGBB format
  u32 color =
      (round_f32_to_uint32(a * 255) << 24) |  // Alpha: bits 24-31
      (round_f32_to_uint32(r * 255) << 16) |  // Red:   bits 16-23
      (round_f32_to_uint32(g * 255) <<  8) |  // Green: bits  8-15
      (round_f32_to_uint32(b * 255));         // Blue:  bits  0-7

  // Fill pixels...
}
```

**Bit packing visualization:**

```
Example: r=1.0, g=0.5, b=0.0, a=1.0
         r=255, g=128, b=0,   a=255

  a << 24:  11111111 00000000 00000000 00000000  (0xFF000000)
  r << 16:  00000000 11111111 00000000 00000000  (0x00FF0000)
  g <<  8:  00000000 00000000 10000000 00000000  (0x00008000)
  b <<  0:  00000000 00000000 00000000 00000000  (0x00000000)
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  OR'ed:    11111111 11111111 10000000 00000000  (0xFFFF8000)
```

**4. Frame-Time Independent Player Movement**

```c
// filepath: games/handmade-hero/src/main.c

void handle_controls(GameControllerInput *inputs,
                     HandMadeHeroGameState *game_state, f32 frame_time) {
  // Digital input â†’ direction vector
  f32 d_player_x = 0.0f;
  f32 d_player_y = 0.0f;

  if (inputs->move_up.ended_down)    d_player_y = -1.0f;
  if (inputs->move_down.ended_down)  d_player_y =  1.0f;
  if (inputs->move_left.ended_down)  d_player_x = -1.0f;
  if (inputs->move_right.ended_down) d_player_x =  1.0f;

  // Scale by speed (pixels/second)
  d_player_x *= game_state->speed;  // speed = 64
  d_player_y *= game_state->speed;

  // TODO: Diagonal will be faster! Fix once we have vectors :)
  // Integrate velocity over time
  game_state->player_state.x += d_player_x * frame_time;
  game_state->player_state.y += d_player_y * frame_time;
}

// Called from update:
f32 frame_time = de100_get_frame_time();  // Seconds since last frame
handle_controls(active_controller, game_state, frame_time);
```

**Why `frame_time` matters:**

- At 30 FPS: `frame_time â‰ˆ 0.033s` â†’ moves 2.1 pixels/frame
- At 60 FPS: `frame_time â‰ˆ 0.016s` â†’ moves 1.0 pixels/frame
- Both achieve 64 pixels/second regardless of frame rate

**5. Player Rendering (Center-Based Position)**

```c
// Player position is CENTER, not top-left corner
f32 player_left = game_state->player_state.x -
                     game_state->player_state.width * 0.5f;
f32 player_top = game_state->player_state.y -
                    game_state->player_state.height * 0.5f;

draw_rect(buffer,
          player_left, player_top,
          player_left + game_state->player_state.width,
          player_top + game_state->player_state.height,
          game_state->player_state.color_r,
          game_state->player_state.color_g,
          game_state->player_state.color_b, 1.0f);
```

**Why center-based:**

```
Top-Left Based:          Center Based:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”
â”‚ â¬¤     â”‚ â† position        â”‚   â¬¤   â”‚ â† position
â”‚       â”‚   is corner        â”‚       â”‚   is center
â””â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”˜

Center-based makes rotation around the center trivial
```

#### ğŸ”§ Hot Reload Watcher Script

```bash
# filepath: games/handmade-hero/build-dev-game-watch.sh

#!/bin/bash
# Install: sudo apt install entr
# Watches src/ for changes, auto-rebuilds game library

find src include -type f \
  ! -path "." \
  | entr -c ./build-dev.sh --build-game
```

**Linux workflow comparison:**

| Windows (Visual Studio)    | Linux (entr)                             |
| -------------------------- | ---------------------------------------- |
| Built-in file watcher      | Manual setup with `entr`/`inotifywait`   |
| Auto-detects project files | Explicit `find` to specify watched files |
| IDE integration            | Terminal-based, runs build script        |

#### ğŸ› Common Pitfalls

| Issue                          | Cause                                       | Fix                                         | My Encountered Issues & Solutions                      |
| ------------------------------ | ------------------------------------------- | ------------------------------------------- | ------------------------------------------------------ |
| Movement speed varies with FPS | Using constant position delta               | Multiply by `frame_time`                    | Changed `player_x += 4` to `player_x += velocity * dt` |
| Diagonal movement too fast     | Adding x and y independently                | Need to normalize direction vector          | Added TODO comment - will fix with proper vector math  |
| Color format confusion         | Different backends expect different formats | Use AARRGGBB, works for both X11 and Raylib | Converted from hex to float colors, pack at draw time  |
| Map initialization             | Can't assign array directly                 | Use `de100_mem_copy()`                      | Copied temp array into game state                      |

#### ğŸ“Š State Structure Evolution

```
Day 26-27 (Removed)              Day 28 (Added)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€              â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- GradientState                  + TileState
- PixelState                       â”œâ”€â”€ map[9][17]
- PlayerState (simple)             â”œâ”€â”€ upper_left_x/y
                                   â””â”€â”€ width/height

                                 + PlayerState (expanded)
                                   â”œâ”€â”€ x, y (position)
                                   â”œâ”€â”€ width, height
                                   â”œâ”€â”€ t_jump
                                   â””â”€â”€ color_r/g/b/a
```

#### âœ… Skills Acquired

- âœ… **Tile map fundamentals** - 2D array storage and grid-based rendering
- âœ… **Frame-independent movement** - `position += velocity Ã— dt` pattern
- âœ… **Float color representation** - More intuitive than packed hex values
- âœ… **Center-based positioning** - Simpler rotation/scaling math
- âœ… **Coordinate transformation** - Tile coords â†’ screen pixels
- âœ… **Hot reload workflow** - `entr` for automatic rebuilds on Linux
- âœ… **Time utilities** - Added `platform_timespec_diff_milliseconds()` helper

#### ğŸ“ Configuration Changes

| Setting      | Before   | After             | Why                                             |
| ------------ | -------- | ----------------- | ----------------------------------------------- |
| Window size  | 1280Ã—720 | 960Ã—540           | Matches Casey's dimensions                      |
| Target FPS   | 60       | 30                | Slower for debugging, proves frame-independence |
| Player speed | 5        | 64                | Pixels/second, not pixels/frame                 |
| Player size  | 10Ã—10    | 0.75Ã—tile, 1Ã—tile | Proportional to tile grid                       |

#### ğŸ“ Casey's Philosophy Applied

> "Solve the problem at hand, don't abstract prematurely."

Tile map implementation is intentionally simple:

- Fixed 9Ã—17 array embedded directly in struct
- No tile map file format, no parser, no editor
- Colors computed inline (`tile_id == 1 ? white : gray`)
- Map data hardcoded in `init.c`

> "Make the game runnable as quickly as possible."

Frame-time-independence ensures:

- Game behavior is consistent regardless of hardware
- Easy to test at different frame rates (30 vs 60 FPS)
- No hidden timing bugs that only appear on slower machines

The result: **Visible, playable tile map in minimal code** - ready for iteration.

### ğŸ“† Day 029: Basic Tile Map Collision Checking

**Focus:** Implementing tile-based collision detection with multiple tile maps and dynamic tile storage using pointer-based arrays.

#### ğŸ—“ï¸ Commits

| Date       | Commit    | What Changed                                                                        | What I Changed & Why                                                                                                                                                                                                                          |
| ---------- | --------- | ----------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 2026-02-11 | `91f7db2` | Tile map collision system, multi-map world structure, centered backbuffer rendering | Refactored from fixed 2D array `map[9][17]` to pointer-based `u32 *tiles` for dynamic allocation, implemented collision checking at player edges, added world structure for multiple tile maps, fixed OpenGL viewport to handle window resize |

#### ğŸ“Š Tile Map Architecture Evolution

```
DAY 028 (Fixed Array)                 DAY 029 (Dynamic Pointer)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

typedef struct {                      typedef struct {
  u32 map[9][17];     â—„â”€â”€â”€â”€â”€â”€â”€â”€â–º     u32 *tiles;        â—„â”€ Pointer!
  f32 upper_left_x;                  u32 row_count;     â—„â”€ Runtime size
  f32 upper_left_y;                  u32 column_count;
  f32 width;                         f32 origin_x;
  f32 height;                        f32 origin_y;
} TileState;                            f32 width;
                                        f32 height;
                                      } TileMapState;

Memory Layout:                        Memory Layout:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ TileState            â”‚              â”‚ TileMapState         â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚              â”‚  tiles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚ â”‚ map[0][0..16]    â”‚ â”‚              â”‚  row_count      â”‚    â”‚
â”‚ â”‚ map[1][0..16]    â”‚ â”‚              â”‚  column_count   â”‚    â”‚
â”‚ â”‚ ...              â”‚ â”‚              â”‚  origin_x/y     â”‚    â”‚
â”‚ â”‚ map[8][0..16]    â”‚ â”‚              â”‚  width/height   â”‚    â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”´â”€â”€â”€â”€â”˜
â”‚ upper_left_x/y       â”‚                               â”‚
â”‚ width/height         â”‚                               â–¼
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                      â”‚ tiles00[9*17]        â”‚
Fixed size: 9Ã—17 = 153 tiles          â”‚ (static or allocated)â”‚
Embedded in struct                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                                      Size determined at runtime!
```

#### ğŸ“Š Multi-Tile Map World Structure

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         WORLD STATE STRUCTURE                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  WorldState                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ tile_map_count_x = 2                                            â”‚   â”‚
â”‚  â”‚ tile_map_count_y = 2                                            â”‚   â”‚
â”‚  â”‚ tile_maps â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                â”‚                                        â”‚
â”‚                                â–¼                                        â”‚
â”‚  tile_maps[2][2] (stored as 1D array, row-major)                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                               â”‚
â”‚  â”‚ tile_maps[0][0]  â”‚ tile_maps[0][1]  â”‚  â† Row 0 (screen Y=0)         â”‚
â”‚  â”‚ tiles â”€â”€â–º tiles00â”‚ tiles â”€â”€â–º tiles01â”‚                               â”‚
â”‚  â”‚ (has left door)  â”‚ (open room)      â”‚                               â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                               â”‚
â”‚  â”‚ tile_maps[1][0]  â”‚ tile_maps[1][1]  â”‚  â† Row 1 (screen Y=1)         â”‚
â”‚  â”‚ tiles â”€â”€â–º tiles10â”‚ tiles â”€â”€â–º tiles11â”‚                               â”‚
â”‚  â”‚ (open room)      â”‚ (open room)      â”‚                               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                               â”‚
â”‚       â†‘ Col 0             â†‘ Col 1                                      â”‚
â”‚    (screen X=0)       (screen X=1)                                     â”‚
â”‚                                                                         â”‚
â”‚  Door connections:                                                      â”‚
â”‚  tiles00[4][0] = 0 â—„â”€â”€â–º tiles10[4][16] = 0  (horizontal, row 4)        â”‚
â”‚  tiles00[8][8] = 0 â—„â”€â”€â–º tiles01[0][8] = 0   (vertical, col 8)          â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### ğŸ“Š Flat Array Access Pattern

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              2D ARRAY â†’ 1D POINTER ACCESS                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  Fixed 2D Array (Day 028):         Pointer + Index (Day 029):          â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€         â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€          â”‚
â”‚  map[row][col]                     tiles[row * column_count + col]     â”‚
â”‚                                                                         â”‚
â”‚  Example: Access tile at row=2, col=5 in 17-column map                 â”‚
â”‚                                                                         â”‚
â”‚  Day 028:                          Day 029:                             â”‚
â”‚  tile_state->map[2][5]             tiles[2 * 17 + 5] = tiles[39]       â”‚
â”‚                                                                         â”‚
â”‚  Memory layout (17 columns Ã— 3 rows shown):                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ [0] [1] [2] ... [16] â”‚ [17] [18] ... [33] â”‚ [34] [35] ... [50] â”‚    â”‚
â”‚  â”‚â†â”€â”€â”€â”€â”€â”€ Row 0 â”€â”€â”€â”€â”€â”€â”€â†’â”‚â†â”€â”€â”€â”€â”€â”€ Row 1 â”€â”€â”€â”€â”€â†’â”‚â†â”€â”€â”€â”€â”€â”€ Row 2 â”€â”€â”€â”€â”€â†’â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                    â†‘                                    â”‚
â”‚                               tiles[39] = tiles[2*17 + 5]              â”‚
â”‚                                                                         â”‚
â”‚  Helper function:                                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ u32 get_tile_value_unchecked(TileMapState *tile_map,         â”‚   â”‚
â”‚  â”‚                                  i32 col, i32 row) {        â”‚   â”‚
â”‚  â”‚     return tile_map->tiles[row * tile_map->column_count + col]; â”‚   â”‚
â”‚  â”‚ }                                                               â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### ğŸ“Š Player Collision Check Points

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    COLLISION CHECK POINTS                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  Player representation (origin at BOTTOM CENTER):                       â”‚
â”‚                                                                         â”‚
â”‚           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                               â”‚
â”‚           â”‚             â”‚                                               â”‚
â”‚           â”‚   Player    â”‚  height                                       â”‚
â”‚           â”‚   Sprite    â”‚                                               â”‚
â”‚           â”‚             â”‚                                               â”‚
â”‚           â””â”€â”€â”€â”€â”€â”€â—â”€â”€â”€â”€â”€â”€â”˜                                               â”‚
â”‚        â—„â”€â”€â”€â”€â–º    â†‘    â—„â”€â”€â”€â”€â–º                                            â”‚
â”‚       width/2  origin  width/2                                          â”‚
â”‚                (x, y)                                                   â”‚
â”‚                                                                         â”‚
â”‚  Collision check points:                                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                                                                 â”‚   â”‚
â”‚  â”‚  CHECK 1: Center (x, y)           - Player's feet/origin       â”‚   â”‚
â”‚  â”‚  CHECK 2: Left   (x - width/2, y) - Left edge of player        â”‚   â”‚
â”‚  â”‚  CHECK 3: Right  (x + width/2, y) - Right edge of player       â”‚   â”‚
â”‚  â”‚                                                                 â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚                      Tile Grid                                â”‚     â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¤     â”‚
â”‚  â”‚  W    â”‚  W    â”‚   â—â”€â”€â”€â”¼â”€â”€â”€â—â”€â”€â”€â”¼â”€â”€â”€â—   â”‚  W    â”‚  W    â”‚ W    â”‚     â”‚
â”‚  â”‚       â”‚       â”‚   â†‘   â”‚   â†‘   â”‚   â†‘   â”‚       â”‚       â”‚      â”‚     â”‚
â”‚  â”‚       â”‚       â”‚ Left  â”‚Center â”‚ Right â”‚       â”‚       â”‚      â”‚     â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”¤     â”‚
â”‚  â”‚                                                               â”‚     â”‚
â”‚  â”‚  All 3 checks must return EMPTY for movement to be valid     â”‚     â”‚
â”‚  â”‚                                                               â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### ğŸ¯ Core Concepts

| Concept               | Implementation                                   | What I Learned / Adapted & Why                                               |
| --------------------- | ------------------------------------------------ | ---------------------------------------------------------------------------- |
| Dynamic tile storage  | `u32 *tiles` instead of `u32 map[9][17]`         | Allows runtime-sized maps and pointer sharing between similar maps           |
| Flat array indexing   | `tiles[row * column_count + col]`                | C stores 2D arrays in row-major order; explicit math matches pointer storage |
| Multi-point collision | Check center, left edge, right edge              | Prevents player clipping through walls at corners                            |
| World abstraction     | `WorldState` containing array of `TileMapState*` | Separates world layout from individual map data                              |
| Centered backbuffer   | `offset_x = (window_width - buffer_width) / 2`   | Matches Casey's Windows `StretchDIBits` with offset parameters               |
| Static tile data      | `local_persist_var u32 tiles00[9][17]`           | No malloc needed; data lives in BSS segment with program lifetime            |

#### ğŸ’» Code Snippets with Explanations

**1. Flat Array Tile Access Helper**

```c
// filepath: games/handmade-hero/src/main.c

// Unchecked access - caller must verify bounds
de100_file_scoped_fn inline u32
get_tile_value_unchecked(TileMapState *tile_map, i32 tile_col, i32 tile_row) {
    // Formula: index = row * width + column
    // This is the ROW-MAJOR memory layout C uses for 2D arrays
    return tile_map->tiles[tile_row * tile_map->column_count + tile_col];
}

// Why this pattern:
// - Compiler generates identical code to map[row][col] for fixed arrays
// - Works with ANY size map (not just 9Ã—17)
// - Explicit math makes memory layout obvious
// - "Unchecked" name reminds caller to validate bounds first
```

**2. Tile Map Point Emptiness Check**

```c
// filepath: games/handmade-hero/src/main.c

de100_file_scoped_fn inline bool32
is_tile_map_point_empty(TileMapState *tile_map, u32 x, u32 y) {
    bool32 is_empty = false;

    // Convert pixel position to tile coordinates
    u32 tile_col = truncate_f32_to_int32(
        (x - tile_map->origin_x) / tile_map->width);
    u32 tile_row = truncate_f32_to_int32(
        (y - tile_map->origin_y) / tile_map->height);

    // Bounds check BEFORE array access (critical for safety!)
    if (tile_col >= 0 && tile_col < tile_map->column_count &&
        tile_row >= 0 && tile_row < tile_map->row_count) {

        // Get tile value using flat array formula
        i32 tile_value = get_tile_value_unchecked(tile_map, tile_col, tile_row);

        is_empty = (tile_value == 0);  // 0 = walkable, 1 = wall

#if DE100_INTERNAL
        if (!is_empty) {
            printf("Blocked by tile at (%d, %d) with value %d\n",
                   tile_col, tile_row, tile_value);
        }
#endif
    }

    return is_empty;
}
```

**Why `truncate_f32_to_int32` instead of `floor`:**

- For non-negative coordinates (player always positive in tile map), truncation works identically to floor
- Simpler, faster - just cast to int
- Would need `floorf()` if player could have negative coordinates (world space)

**3. Multi-Point Collision Check**

```c
// filepath: games/handmade-hero/src/main.c

// Calculate proposed new position
i32 new_player_x = game_state->player_state.x + (i32)(d_player_x * frame_time);
i32 new_player_y = game_state->player_state.y + (i32)(d_player_y * frame_time);

// Check THREE points to prevent corner clipping
if (
    // Check 1: Center point (player origin - bottom center)
    is_tile_map_point_empty(game_state->active_tile_map,
                            new_player_x, new_player_y) &&

    // Check 2: Left edge of player
    is_tile_map_point_empty(game_state->active_tile_map,
                            new_player_x - game_state->player_state.width * 0.5f,
                            new_player_y) &&

    // Check 3: Right edge of player
    is_tile_map_point_empty(game_state->active_tile_map,
                            new_player_x + game_state->player_state.width * 0.5f,
                            new_player_y)
) {
    // All checks passed - allow movement
    game_state->player_state.x = new_player_x;
    game_state->player_state.y = new_player_y;
}
```

**Why check multiple points:**

```
Single point check:              Multi-point check:
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”
     â”‚Player â”‚                        â”‚Player â”‚
     â”‚   â—   â”‚ â† Only center          â”‚ â— â— â— â”‚ â† 3 points at bottom
     â””â”€â”€â”€â”€â”€â”€â”€â”˜                        â””â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“                                â†“
     Can clip through wall           Blocked correctly
     at corners!                     Can't squeeze through!
```

**4. World and Tile Map Initialization**

```c
// filepath: games/handmade-hero/src/init.c

// Static tile data - lives in BSS, no malloc needed
local_persist_var u32 tiles00[TILE_MAP_ROW_COUNT][TILE_MAP_COLUMN_COUNT] = {
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},  // Row 0
    {1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1},
    // ... more rows ...
    {1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},  // Row 4: door on right
    // ...
};

// Similar for tiles01, tiles10, tiles11...

// Static array of tile map metadata
local_persist_var TileMapState tile_maps[2][2];

// Initialize first tile map with shared properties
tile_maps[0][0].column_count = TILE_MAP_COLUMN_COUNT;
tile_maps[0][0].row_count = TILE_MAP_ROW_COUNT;
tile_maps[0][0].origin_x = -30;
tile_maps[0][0].origin_y = 0;
tile_maps[0][0].width = 60;
tile_maps[0][0].height = 60;
tile_maps[0][0].tiles = (u32 *)tiles00;  // Cast 2D array to pointer!

// Copy shared properties, point to different tile data
tile_maps[0][1] = tile_maps[0][0];
tile_maps[0][1].tiles = (u32 *)tiles01;

tile_maps[1][0] = tile_maps[0][0];
tile_maps[1][0].tiles = (u32 *)tiles10;

tile_maps[1][1] = tile_maps[0][0];
tile_maps[1][1].tiles = (u32 *)tiles11;

// Set up world
game_state->world.tile_map_count_x = 2;
game_state->world.tile_map_count_y = 2;
game_state->world.tile_maps = (TileMapState *)tile_maps;

// Start player in first tile map
game_state->active_tile_map = &tile_maps[0][0];
```

**Why `(u32 *)tiles00` works:**

```
tiles00 declared as: u32 tiles00[9][17]
Memory layout:       [row0: 17 ints][row1: 17 ints]...[row8: 17 ints]
                     â†‘
                     This address is what (u32 *)tiles00 gives us

Same memory layout as: u32 *tiles pointing to 153 contiguous uint32s
```

**5. Centered Backbuffer Rendering (X11 OpenGL)**

```c
// filepath: engine/platforms/x11/backend.c

de100_file_scoped_fn inline void
opengl_display_buffer(GameBackBuffer *backbuffer, int window_width,
                      int window_height) {
    if (!de100_memory_is_valid(backbuffer->memory))
        return;

    // Center the backbuffer in the window
    int offset_x = (window_width - backbuffer->width) / 2;
    int offset_y = (window_height - backbuffer->height) / 2;

    // Alternative: Fixed offset like Casey's Windows version
    // int offset_x = 10;
    // int offset_y = 10;

    glClear(GL_COLOR_BUFFER_BIT);

    glBindTexture(GL_TEXTURE_2D, g_gl.texture_id);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, backbuffer->width, backbuffer->height,
                 0, GL_RGBA, GL_UNSIGNED_BYTE, backbuffer->memory.base);

    // Draw quad at OFFSET position, with BACKBUFFER dimensions
    glBegin(GL_QUADS);
    glTexCoord2f(0.0f, 0.0f); glVertex2f(offset_x, offset_y);
    glTexCoord2f(1.0f, 0.0f); glVertex2f(offset_x + backbuffer->width, offset_y);
    glTexCoord2f(1.0f, 1.0f); glVertex2f(offset_x + backbuffer->width,
                                          offset_y + backbuffer->height);
    glTexCoord2f(0.0f, 1.0f); glVertex2f(offset_x, offset_y + backbuffer->height);
    glEnd();

    glXSwapBuffers(g_gl.display, g_gl.window);
}
```

**Comparison with Casey's Windows code:**

```c
// Casey's StretchDIBits call (Windows):
StretchDIBits(DeviceContext,
              OffsetX, OffsetY,       // Destination position â—„â”€â”€ We match this!
              Buffer->Width,          // Destination width
              Buffer->Height,         // Destination height
              0, 0,                   // Source position
              Buffer->Width,          // Source width
              Buffer->Height,         // Source height
              Buffer->Memory,
              &Buffer->Info,
              DIB_RGB_COLORS, SRCCOPY);
```

**6. OpenGL Viewport Update on Resize**

```c
// filepath: engine/platforms/x11/backend.c

de100_file_scoped_fn inline void opengl_update_projection(int window_width,
                                                          int window_height) {
    // Tell OpenGL the NEW window size for rendering
    glViewport(0, 0, window_width, window_height);

    // Reset projection matrix to match new dimensions
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(0, window_width, window_height, 0, -1, 1);  // Y=0 at top

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

// Called when window is resized:
case ConfigureNotify: {
    int new_width = event->xconfigure.width;
    int new_height = event->xconfigure.height;
    if (new_width != g_last_window_width ||
        new_height != g_last_window_height) {
        g_last_window_width = new_width;
        g_last_window_height = new_height;

        // Update OpenGL projection to match new window size
        opengl_update_projection(new_width, new_height);
    }
    break;
}
```

#### ğŸ“Š Data Structure Comparison

| Feature         | Day 028 (`TileState`)     | Day 029 (`TileMapState`)                   |
| --------------- | ------------------------- | ------------------------------------------ |
| Tile storage    | `u32 map[9][17]` embedded | `u32 *tiles` pointer                       |
| Size known at   | Compile time              | Runtime (`row_count Ã— column_count`)       |
| Multiple maps   | Duplicate entire struct   | Share metadata, different `tiles` pointers |
| Memory location | Inside struct             | Anywhere (static, heap, arena)             |
| Access syntax   | `map[row][col]`           | `tiles[row * col_count + col]`             |
| Flexibility     | Fixed 9Ã—17 only           | Any size map                               |

#### ğŸ› Common Pitfalls

| Issue                                 | Cause                                  | Fix                                      | My Encountered Issues & Solutions                     |
| ------------------------------------- | -------------------------------------- | ---------------------------------------- | ----------------------------------------------------- |
| Player clips through corners          | Only checking center point             | Check left, center, right edges          | Added 3-point collision check                         |
| Array access crash                    | Wrong index order `[col][row]`         | Always use `[row * width + col]`         | Created `get_tile_value_unchecked()` helper           |
| Stretched rendering on resize         | OpenGL viewport not updated            | Call `glViewport()` on ConfigureNotify   | Added `opengl_update_projection()`                    |
| Backbuffer not centered               | Drawing at (0,0) always                | Calculate offset from window/buffer size | Added offset calculation in `opengl_display_buffer()` |
| Maps share same data                  | All point to same `tiles` array        | Each map needs its own `tiles` pointer   | Used separate `tiles00`, `tiles01`, etc.              |
| Compile error with `tiles = temp_map` | Can't assign array to pointer directly | Cast: `tiles = (u32 *)temp_map`          | Used cast when assigning 2D array to pointer          |

#### ğŸ“Š Knowledge Dump Files Created

This day I created extensive documentation for future reference:

| File                                                                             | Purpose                                                                                    |
| -------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ |
| `ai-knowledge-dump/mastering-array-indexing-and-coordinate-systems-in-c.md`      | ~3600 lines covering 2D array indexing, row/col confusion, debugging techniques, exercises |
| `ai-knowledge-dump/converting-games-handmade-hero-to-a-private-git-submodule.md` | Guide for separating game code as private submodule                                        |

**Key topics in array indexing guide:**

- Mental models for 2D array access
- Row-major vs column-major storage
- `floor()` vs `truncate()` for tile coordinates
- Debug visualization techniques
- Common bug patterns with solutions
- Exercises with hidden solutions

#### âœ… Skills Acquired

- âœ… **Pointer-based 2D array access** - `tiles[row * width + col]` pattern
- âœ… **Multi-point collision detection** - Preventing corner clipping
- âœ… **World/map abstraction** - Separating world structure from tile data
- âœ… **Static data initialization** - Using `local_persist_var` for no-malloc tile storage
- âœ… **OpenGL viewport management** - Updating projection on window resize
- âœ… **Centered rendering** - Matching Casey's offset-based buffer display
- âœ… **Row-major indexing** - Deep understanding of C array memory layout
- âœ… **Documentation writing** - Created comprehensive reference guide for future use

#### ğŸ“ Casey's Philosophy Applied

> "Write code that you understand completely."

This day emphasized understanding exactly how 2D arrays work in memory:

- No magic `[row][col]` syntax hiding pointer arithmetic
- Explicit `row * width + col` makes memory layout obvious
- Helper functions encapsulate the pattern but don't hide it

> "Don't solve problems you don't have."

- Used `local_persist_var` instead of malloc - game doesn't need dynamic map loading yet
- Multi-map structure prepared but only one map active - ready for expansion
- Collision checks 3 points - minimum needed, not over-engineered AABB

### ğŸ“† Day 030: Moving Between Tile Maps

**Focus:** Implementing coordinate canonicalization to allow seamless player movement across multiple tilemaps with proper collision detection.

#### ğŸ—“ï¸ Commits

| Date       | Commit    | What Changed                                                                           | What I Changed & Why                                                                                                                                                                                                                                                                        |
| ---------- | --------- | -------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 2026-02-12 | `6f42e56` | Tilemap transition system, coordinate canonicalization, renamed structures for clarity | Introduced `WorldCanonicalPosition` and `TilemapRelativePosition` types, implemented `get_canonical_pos()` for resolving overflow coordinates, refactored variable names from `tile_map` â†’ `tilemap` and `TileMapState` â†’ `Tilemap` for consistency, added extensive documentation comments |

#### ğŸ“Š Coordinate System Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    THREE COORDINATE SPACES                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  1. SCREEN SPACE (pixels)                                                   â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”‚
â”‚     â”‚ (0,0)                                    â”‚                            â”‚
â”‚     â”‚    â—â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚  X increases â†’             â”‚
â”‚     â”‚    â”‚                                     â”‚                            â”‚
â”‚     â”‚    â”‚     What we draw to backbuffer      â”‚                            â”‚
â”‚     â”‚    â”‚                                     â”‚                            â”‚
â”‚     â”‚    â–¼                                     â”‚                            â”‚
â”‚     â”‚    Y increases â†“                         â”‚                            â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                            â”‚
â”‚                                                                             â”‚
â”‚  2. RAW WORLD SPACE (TilemapRelativePosition)                               â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚     â”‚  tilemap_x: 0                                              â”‚          â”‚
â”‚     â”‚  tilemap_y: 0                                              â”‚          â”‚
â”‚     â”‚  offset_x: 1050  â† Can OVERFLOW tilemap bounds! (>1020px)  â”‚          â”‚
â”‚     â”‚  offset_y: 300                                             â”‚          â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                             â”‚
â”‚  3. CANONICAL WORLD SPACE (WorldCanonicalPosition)                          â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚     â”‚  tilemap_x: 1     â† Resolved to next tilemap               â”‚          â”‚
â”‚     â”‚  tilemap_y: 0                                              â”‚          â”‚
â”‚     â”‚  tile_x: 0        â† First tile in new tilemap              â”‚          â”‚
â”‚     â”‚  tile_y: 5        â† Same row                               â”‚          â”‚
â”‚     â”‚  tile_rel_offset_x: 30  â† Remainder within tile            â”‚          â”‚
â”‚     â”‚  tile_rel_offset_y: 0                                      â”‚          â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### ğŸ“Š Tilemap Transition Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CROSSING TILEMAP BOUNDARIES                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  Player movement: tilemap[0,0] â†’ tilemap[1,0] (moving RIGHT)                â”‚
â”‚                                                                             â”‚
â”‚  BEFORE (in tilemap[0,0]):                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚  tilemap[0,0]               â”‚â”‚  tilemap[1,0]               â”‚             â”‚
â”‚  â”‚                             â”‚â”‚                             â”‚             â”‚
â”‚  â”‚                 â—â”€â”€â–º Player â”‚â”‚                             â”‚             â”‚
â”‚  â”‚              at tile 16     â”‚â”‚                             â”‚             â”‚
â”‚  â”‚              offset_x=990   â”‚â”‚                             â”‚             â”‚
â”‚  â”‚                         â”€â”€â”€â”€â”¼â”¼â”€â”€â–º Moves right              â”‚             â”‚
â”‚  â”‚              17 tiles Ã— 60pxâ”‚â”‚                             â”‚             â”‚
â”‚  â”‚              = 1020px wide  â”‚â”‚                             â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                                                                             â”‚
â”‚  AFTER movement: offset_x = 1050 (OVERFLOW by 30px!)                        â”‚
â”‚                                                                             â”‚
â”‚  Canonicalization resolves this:                                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚  tilemap[0,0]               â”‚â”‚  tilemap[1,0]               â”‚             â”‚
â”‚  â”‚                             â”‚â”‚                             â”‚             â”‚
â”‚  â”‚                             â”‚â”‚ â—â†â”€â”€ Player now here        â”‚             â”‚
â”‚  â”‚                             â”‚â”‚   tile_x = 0                â”‚             â”‚
â”‚  â”‚                             â”‚â”‚   offset = 30px into tile   â”‚             â”‚
â”‚  â”‚                             â”‚â”‚                             â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### ğŸ“Š Canonical Position Calculation

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    get_canonical_pos() ALGORITHM                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  INPUT: TilemapRelativePosition { tilemap_x=0, tilemap_y=0,                 â”‚
â”‚                                   offset_x=150, offset_y=300 }              â”‚
â”‚                                                                             â”‚
â”‚  STEP 1: Subtract world origin                                              â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                          â”‚
â”‚    origin_x = -30 (tilemap starts 30px left of screen edge)                 â”‚
â”‚    tilemap_offset_x = 150 - (-30) = 180px into tilemap                      â”‚
â”‚    tilemap_offset_y = 300 - 0 = 300px into tilemap                          â”‚
â”‚                                                                             â”‚
â”‚  STEP 2: Calculate tile indices                                             â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                          â”‚
â”‚    tile_width = 60px                                                        â”‚
â”‚    tile_x = floor(180 / 60) = floor(3.0) = 3                                â”‚
â”‚    tile_y = floor(300 / 60) = floor(5.0) = 5                                â”‚
â”‚                                                                             â”‚
â”‚  STEP 3: Calculate sub-tile offset                                          â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                          â”‚
â”‚    tile_rel_offset_x = 180 - (3 Ã— 60) = 180 - 180 = 0                       â”‚
â”‚    tile_rel_offset_y = 300 - (5 Ã— 60) = 300 - 300 = 0                       â”‚
â”‚                                                                             â”‚
â”‚  STEP 4: Handle overflow/underflow                                          â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                          â”‚
â”‚    tile_x=3 is valid (0 â‰¤ 3 < 17) â†’ no tilemap change                       â”‚
â”‚    tile_y=5 is valid (0 â‰¤ 5 < 9)  â†’ no tilemap change                       â”‚
â”‚                                                                             â”‚
â”‚  OUTPUT: WorldCanonicalPosition { tilemap_x=0, tilemap_y=0,                 â”‚
â”‚                                   tile_x=3, tile_y=5,                       â”‚
â”‚                                   tile_rel_offset_x=0, tile_rel_offset_y=0 }â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### ğŸ“Š Data Structure Evolution

```
DAY 029                                    DAY 030
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€               â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

typedef struct {                           typedef struct {
  u32 *tiles;                             u32 *tiles;
  u32 row_count;            â”€â”€â”€â”€â”€â”€â–º     } Tilemap;  // Simplified!
  u32 column_count;
  f32 origin_x/y;                       // Dimensions moved to World:
  f32 width/height;                     typedef struct {
} TileMapState;                              f32 origin_x/y;
                                             f32 tilemap_width_px;   // Tile size!
                                             f32 tilemap_height_px;
                                             i32 tiles_per_map_x/y_count;
                                             i32 tilemaps_count_x/y;
                                             Tilemap *tilemaps;
                                           } World;

typedef struct {                           typedef struct {
  i32 x, y;                  â”€â”€â”€â”€â”€â”€â–º       i32 x, y;
  f32 t_jump;                             f32 t_jump;
  f32 width, height;                      f32 width, height;
  f32 color_r/g/b/a;                      f32 color_r/g/b/a;
} PlayerState;                               i32 tilemap_x, tilemap_y;  // NEW!
                                           } Player;

                               â”€â”€â”€â”€â”€â”€â–º     // NEW position types:
                                           typedef struct {
                                             i32 tilemap_x/y;
                                             i32 tile_x/y;
                                             f32 tile_rel_offset_x/y;
                                           } WorldCanonicalPosition;

                                           typedef struct {
                                             i32 tilemap_x/y;
                                             f32 offset_x/y;  // Can overflow!
                                           } TilemapRelativePosition;
```

#### ğŸ¯ Core Concepts

| Concept                     | Implementation                                                      | What I Learned / Adapted & Why                                                   |
| --------------------------- | ------------------------------------------------------------------- | -------------------------------------------------------------------------------- |
| Coordinate canonicalization | `get_canonical_pos()` converts raw â†’ canonical                      | Core insight: separate "where I want to go" from "resolved position"             |
| Position overflow handling  | Check if `tile_x < 0` or `>= tiles_per_map_x`, adjust tilemap index | Allows seamless world traversal without boundary checks everywhere               |
| Hierarchical coordinates    | tilemap â†’ tile â†’ sub-tile offset                                    | Like an address: Country â†’ City â†’ Street â†’ House Number                          |
| Shared tile dimensions      | Moved from `Tilemap` to `World` struct                              | All tilemaps share same tile size - no need to duplicate                         |
| Player tilemap tracking     | Added `tilemap_x/y` to `Player` struct                              | Player needs to know which "room" they're in                                     |
| `floor()` vs `truncate()`   | Changed to `floor_f32_to_int32()` using `floorf()`                  | Negative coordinates need floor (round toward -âˆ), not truncate (round toward 0) |

#### ğŸ’» Code Snippets with Explanations

**1. Coordinate Canonicalization Function**

```c
// filepath: games/handmade-hero/src/main.c

de100_file_scoped_fn inline WorldCanonicalPosition
get_canonical_pos(World *world, TilemapRelativePosition pos) {
  WorldCanonicalPosition result = {0};

  // Start with the same tilemap (might change if we overflow)
  result.tilemap_x = pos.tilemap_x;
  result.tilemap_y = pos.tilemap_y;

  // â”€â”€â”€ Step 1: Convert to tilemap-relative coordinates â”€â”€â”€
  // Subtract world origin to get position relative to tilemap[0,0]'s top-left
  f32 tilemap_offset_x = pos.offset_x - world->origin_x;
  f32 tilemap_offset_y = pos.offset_y - world->origin_y;

  // â”€â”€â”€ Step 2: Calculate tile indices using FLOOR â”€â”€â”€
  // floor() ensures negative values round toward negative infinity
  // This is CRITICAL for handling leftward/upward movement!
  //
  // Example: offset = -30, tile_width = 60
  //   truncate(-30 / 60) = truncate(-0.5) = 0   â† WRONG!
  //   floor(-30 / 60)    = floor(-0.5)    = -1  â† CORRECT!
  result.tile_x = floor_f32_to_int32(tilemap_offset_x / world->tilemap_width_px);
  result.tile_y = floor_f32_to_int32(tilemap_offset_y / world->tilemap_height_px);

  // â”€â”€â”€ Step 3: Calculate sub-tile offset (remainder) â”€â”€â”€
  result.tile_rel_offset_x = tilemap_offset_x - (result.tile_x * world->tilemap_width_px);
  result.tile_rel_offset_y = tilemap_offset_y - (result.tile_y * world->tilemap_height_px);

  // â”€â”€â”€ Step 4: Handle tilemap transitions â”€â”€â”€
  // If tile index is out of bounds, adjust tilemap and wrap tile index

  if (result.tile_x < 0) {
    // Moving LEFT off the tilemap
    result.tile_x = result.tile_x + world->tiles_per_map_x_count;
    --result.tilemap_x;
  }
  if (result.tile_x >= world->tiles_per_map_x_count) {
    // Moving RIGHT off the tilemap
    result.tile_x = result.tile_x - world->tiles_per_map_x_count;
    ++result.tilemap_x;
  }

  // Same for Y axis...
  if (result.tile_y < 0) {
    result.tile_y = result.tile_y + world->tiles_per_map_y_count;
    --result.tilemap_y;
  }
  if (result.tile_y >= world->tiles_per_map_y_count) {
    result.tile_y = result.tile_y - world->tiles_per_map_y_count;
    ++result.tilemap_y;
  }

  return result;
}
```

**Why `floor()` instead of `truncate()`:**

```
Truncate (toward zero):          Floor (toward -âˆ):
  truncate( 1.7) =  1              floor( 1.7) =  1
  truncate(-1.7) = -1  â† Problem!  floor(-1.7) = -2  â† Correct!

For tile indices, we need consistent "which tile contains this point":
  Point at -30px with 60px tiles:
  - truncate: tile 0 (wrong - that's 0-60px)
  - floor: tile -1 (correct - negative tile = previous tilemap)
```

**2. World Point Emptiness Check (High-Level)**

```c
// filepath: games/handmade-hero/src/main.c

de100_file_scoped_fn inline bool32
is_world_point_empty(World *world, TilemapRelativePosition pos) {
  bool32 is_empty = false;

  // Step 1: Resolve raw position to canonical (handles tilemap transitions)
  WorldCanonicalPosition canonical_pos = get_canonical_pos(world, pos);

  // Step 2: Get the tilemap at the canonical position
  // (might be NULL if we've left the world entirely)
  Tilemap *current_tilemap =
      get_tilemap(world, canonical_pos.tilemap_x, canonical_pos.tilemap_y);

  // Step 3: Check if the tile at that position is empty
  is_empty = check_if_tilemap_point_empty(
      world, current_tilemap, canonical_pos.tile_x, canonical_pos.tile_y);

  return is_empty;
}
```

**Collision flow visualization:**

```
is_world_point_empty()
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ get_canonical_pos()   â”‚ â† Resolve overflow
â”‚ raw â†’ canonical       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ get_tilemap()         â”‚ â† Find tilemap (or NULL)
â”‚ world â†’ Tilemap*      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ check_if_tilemap_     â”‚ â† Bounds check + tile lookup
â”‚ point_empty()         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
            â–¼
      true / false
```

**3. Player Movement with Tilemap Tracking**

```c
// filepath: games/handmade-hero/src/main.c

// Calculate proposed new position (RAW - might overflow)
TilemapRelativePosition player_bottom_center_pos = {
    .offset_x = game->player.x + (d_player_x * frame_time),
    .offset_y = game->player.y + (d_player_y * frame_time),
    .tilemap_x = game->player.tilemap_x,  // Current tilemap
    .tilemap_y = game->player.tilemap_y,
};

// Check collision at left, center, and right points...
if (is_world_point_empty(&game->world, player_bottom_center_pos) &&
    is_world_point_empty(&game->world, player_bottom_left_pos) &&
    is_world_point_empty(&game->world, player_bottom_right_pos)) {

    // Movement allowed! Canonicalize to get resolved position
    WorldCanonicalPosition canonical_pos =
        get_canonical_pos(&game->world, player_bottom_center_pos);

    // Update player's tilemap (might have changed!)
    game->player.tilemap_x = canonical_pos.tilemap_x;
    game->player.tilemap_y = canonical_pos.tilemap_y;

    // Convert canonical back to screen coordinates
    game->player.x = canonical_pos.tile_rel_offset_x +
                     (game->world.tilemap_width_px * canonical_pos.tile_x) +
                     game->world.origin_x;

    game->player.y = canonical_pos.tile_rel_offset_y +
                     (game->world.tilemap_width_px * canonical_pos.tile_y) +
                     game->world.origin_y;
}
```

**4. Enhanced ASSERT_MSG with Format String**

```c
// filepath: engine/_common/base.h

// BEFORE (Day 029):
#define ASSERT_MSG(expr, msg) \
  do { \
    if (!(expr)) { \
      fprintf(stderr, "Message: %s\n", msg); \
      // ...
    } \
  } while(0)

// AFTER (Day 030):
#define ASSERT_MSG(expr, fmt, ...) \
  do { \
    if (!(expr)) { \
      fprintf(stderr, \
              "ASSERTION FAILED\n" \
              "  Expression: %s\n" \
              "  Message: " fmt "\n" \
              "  File:Line: %s:%d\n", \
              #expr, ##__VA_ARGS__, __FILE__, __LINE__); \
      fflush(stderr); \
      DEBUG_BREAK(); \
    } \
  } while(0)

// Usage:
DEV_ASSERT_MSG((tile_x >= 0 && tile_x < world->tiles_per_map_x_count),
               "Tile x out of bounds! tile_x: %d, tiles_per_map_x_count: %d",
               tile_x, world->tiles_per_map_x_count);
```

**Why variadic ASSERT:** Allows printf-style formatting for detailed debug info.

**5. Tilemap Initialization with Consistent Naming**

```c
// filepath: games/handmade-hero/src/init.c

// World configuration (shared by all tilemaps)
game->world.tiles_per_map_x_count = TILES_PER_MAP_X_COUNT;  // 17
game->world.tiles_per_map_y_count = TILES_PER_MAP_Y_COUNT;  // 9
game->world.origin_x = -30;
game->world.origin_y = 0;
game->world.tilemap_width_px = 60;   // Tile width, NOT tilemap width!
game->world.tilemap_height_px = 60;
game->world.tilemaps_count_x = 2;
game->world.tilemaps_count_y = 2;

// Tile data arrays (Y_X naming convention for clarity)
local_persist_var u32 tiles_Y0_X0[TILES_PER_MAP_Y_COUNT][TILES_PER_MAP_X_COUNT] = {...};
local_persist_var u32 tiles_Y0_X1[TILES_PER_MAP_Y_COUNT][TILES_PER_MAP_X_COUNT] = {...};
local_persist_var u32 tiles_Y1_X0[TILES_PER_MAP_Y_COUNT][TILES_PER_MAP_X_COUNT] = {...};
local_persist_var u32 tiles_Y1_X1[TILES_PER_MAP_Y_COUNT][TILES_PER_MAP_X_COUNT] = {...};

// Tilemap structs (simplified - only tile pointer)
local_persist_var Tilemap tilemaps[TILE_MAPS_Y_COUNT][TILE_MAPS_X_COUNT];
tilemaps[0][0].tiles = (u32 *)tiles_Y0_X0;
tilemaps[0][1].tiles = (u32 *)tiles_Y0_X1;
tilemaps[1][0].tiles = (u32 *)tiles_Y1_X0;
tilemaps[1][1].tiles = (u32 *)tiles_Y1_X1;

game->world.tilemaps = (Tilemap *)tilemaps;

// Player starts with explicit tilemap position
game->player.tilemap_x = 0;
game->player.tilemap_y = 0;
```

#### ğŸ“Š Naming Convention Changes

| Day 029                     | Day 030                                          | Reason                                                 |
| --------------------------- | ------------------------------------------------ | ------------------------------------------------------ |
| `TileMapState`              | `Tilemap`                                        | Simpler, two words â†’ one                               |
| `tile_map` variables        | `tilemap`                                        | Consistency with new type                              |
| `map[9][17]`                | `tiles_Y0_X0[9][17]`                             | Clear which tilemap (Y,X order matches array indexing) |
| `column_count`, `row_count` | `tiles_per_map_x_count`, `tiles_per_map_y_count` | More explicit about what it counts                     |
| `width`, `height`           | `tilemap_width_px`, `tilemap_height_px`          | Clarifies these are TILE dimensions in pixels          |
| `tile_map_count_x`          | `tilemaps_count_x`                               | Consistent underscore removal                          |
| `player_state`              | `player`                                         | Simpler                                                |
| `active_tile_map`           | Removed                                          | Now use `get_tilemap(world, player.tilemap_x/y)`       |

#### ğŸ› Common Pitfalls

| Issue                                    | Cause                                                    | Fix                                                            | My Encountered Issues & Solutions                         |
| ---------------------------------------- | -------------------------------------------------------- | -------------------------------------------------------------- | --------------------------------------------------------- |
| Player teleports when crossing boundary  | Using truncate instead of floor for tile calculation     | Changed to `floor_f32_to_int32()` using `floorf()`             | Negative coordinates were being truncated toward zero     |
| Confusing tilemap vs tile dimensions     | Variable named `tilemap_width_px` is actually TILE width | Added `_px` suffix and documentation                           | Casey's naming is confusing - I documented it extensively |
| Off-by-one in boundary wrapping          | Inconsistent +1/-1 adjustment                            | Added TODO to verify against Casey's video                     | The `-1` in overflow handling seems suspicious            |
| Player clips into walls after transition | Not checking collision AFTER canonicalization            | Check collision on raw position, THEN canonicalize if valid    | Order matters: validate first, then resolve               |
| Redundant `engine_shutdown` under `#if`  | Cleanup code only ran in sanitize mode                   | Always call `engine_shutdown`, conditionally do memory cleanup | Shutdown logging was missing in release builds            |

#### ğŸ“Š Position Type Usage

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    WHEN TO USE EACH POSITION TYPE                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  TilemapRelativePosition (Raw)       WorldCanonicalPosition (Resolved)      â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€       â”‚
â”‚                                                                             â”‚
â”‚  âœ“ Movement calculations              âœ“ Collision tile lookup               â”‚
â”‚  âœ“ Input â†’ proposed position          âœ“ Rendering tile selection            â”‚
â”‚  âœ“ Can have negative offsets          âœ“ Player state storage (after move)   â”‚
â”‚  âœ“ Can overflow tilemap bounds        âœ“ Always valid indices                â”‚
â”‚                                                                             â”‚
â”‚  Flow:                                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   get_canonical_pos()   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ Raw Position     â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ Canonical Position    â”‚     â”‚
â”‚  â”‚ (might overflow) â”‚                         â”‚ (always valid)        â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚           â”‚                                              â”‚                  â”‚
â”‚           â–¼                                              â–¼                  â”‚
â”‚  Used for: "Where do I                        Used for: "Which tile am      â”‚
â”‚  want to move to?"                            I actually in?"               â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### âœ… Skills Acquired

- âœ… **Coordinate canonicalization** - Resolving overflow positions to valid tile coordinates
- âœ… **Hierarchical position systems** - tilemap â†’ tile â†’ sub-tile offset structure
- âœ… **`floor()` vs `truncate()`** - Understanding rounding direction for negative numbers
- âœ… **Position type separation** - Raw (for calculation) vs Canonical (for lookup)
- âœ… **Variadic macros** - `ASSERT_MSG` with printf-style formatting
- âœ… **Naming convention refactoring** - Consistent `tilemap` vs `tile_map` throughout
- âœ… **Documentation comments** - Extensive inline docs explaining coordinate math
- âœ… **Boundary transition handling** - Incrementing/decrementing tilemap indices on overflow

#### ğŸ“ Casey's Philosophy Applied

> "Make the code express the problem domain."

Position types now match how we think about the world:

- `TilemapRelativePosition`: "I'm in this room, this far from the corner" (can overflow)
- `WorldCanonicalPosition`: "I'm in room X, tile Y, at offset Z" (always valid)

> "Write code that explains itself."

Added extensive comments explaining:

- Why `floor()` instead of truncate
- ASCII diagrams of tile layouts
- Step-by-step algorithm breakdowns

#### ğŸ“ Confusing Naming Note

Casey's `tilemap_width_px` and `tilemap_height_px` are actually **TILE** dimensions, not **TILEMAP** dimensions. This caused confusion during implementation:

```c
// CONFUSING:
world->tilemap_width_px = 60;  // This is TILE width, not TILEMAP width!

// ACTUAL tilemap width would be:
f32 actual_tilemap_width = tiles_per_map_x_count * tilemap_width_px;
                            // 17 * 60 = 1020 pixels
```

I kept Casey's naming for compatibility but added documentation to clarify.
