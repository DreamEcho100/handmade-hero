# Unit 1, Lesson 1: Dynamic Linker Basics

> **Learning Goal:** Understand how dlopen/dlsym work and why Casey uses dynamic loading for DirectSound  
> **Time Estimate:** 45-60 minutes  
> **Prerequisite:** Basic C knowledge (pointers, functions)

---

## üéØ The Mystery You're Solving

In `audio.c:133-200`, you have this "magic incantation":

```c
void *alsa_lib = dlopen("libasound.so.2", RTLD_NOW);
*(void **)(&SndPcmOpen_) = dlsym(alsa_lib, "snd_pcm_open");
```

**Questions:**

- What is `dlopen()` actually DOING at runtime?
- Why not just `#include <alsa/asoundlib.h>` and link with `-lasound`?
- What's the difference between this and `import { sndPcmOpen } from 'alsa'` in JavaScript?

---

## üìö Core Concepts

### 1. Static Linking vs Dynamic Linking

**Static Linking** (Compile-Time):

```bash
# You write:
#include <alsa/asoundlib.h>

# Compiler embeds ALSA code INTO your executable:
gcc -o game game.c -lasound
# Result: game binary is ~5MB larger
#         Crashes if ALSA isn't on system
```

**Dynamic Linking** (Runtime):

```bash
# You write:
void *lib = dlopen("libasound.so.2", RTLD_NOW);

# Your executable stays small (~500KB)
# Loads ALSA ONLY when needed
# If ALSA missing: graceful fallback (no audio, but game runs!)
```

**Web Dev Analogy:**

```javascript
// Static = bundling entire React into your app.js (2MB bundle)
import React from "react";

// Dynamic = lazy loading (code splitting)
const React = await import("react"); // Loads at runtime
```

---

### 2. How `dlopen()` Works (The Linux Dynamic Linker)

**What happens when you call `dlopen("libasound.so.2", RTLD_NOW)`?**

1. **Search for the library** (in order):

   ```
   /usr/lib/x86_64-linux-gnu/libasound.so.2  ‚Üê Most common
   /lib/x86_64-linux-gnu/libasound.so.2
   /usr/local/lib/libasound.so.2
   (Also checks LD_LIBRARY_PATH environment variable)
   ```

2. **Load into memory**:

   - Linux `mmap()` maps the .so file into your process's address space
   - ALSA library code now lives at some memory address (e.g., `0x7f3a2c000000`)
   - **Web Dev Analogy:** Like downloading a script tag `<script src="alsa.js"></script>`

3. **Resolve dependencies**:

   - ALSA depends on libc, libpthread, etc.
   - Dynamic linker loads those too (recursively)
   - **Web Dev Analogy:** Webpack resolving `node_modules` dependencies

4. **Run initialization code**:

   - ALSA has constructor functions that run on load
   - Similar to Node.js running top-level code in a `require()`

5. **Return handle**:
   - `dlopen()` returns a `void *` pointer (opaque handle)
   - You can't dereference it‚Äîit's a magic cookie for the linker
   - **Web Dev Analogy:** Like a file descriptor in Node.js

**Flags:**

- `RTLD_NOW`: Resolve all symbols immediately (fail fast if something's missing)
- `RTLD_LAZY`: Resolve symbols when first called (faster load, but delayed errors)
- `RTLD_GLOBAL`: Make symbols available to other libraries (usually not needed)

---

### 3. How `dlsym()` Works (Symbol Lookup)

**What is a "symbol"?**

- In C, every function and global variable is a "symbol" with a name
- ALSA exports symbols like `snd_pcm_open`, `snd_pcm_writei`, etc.
- The `.so` file contains a **symbol table** (like a phonebook)

**Example symbol table (`objdump -T libasound.so.2 | grep snd_pcm_open`):**

```
0000000000045a10  T  snd_pcm_open
  ^               ^  ^
  Memory offset   |  Function name
                  Type (T = text/code)
```

**What `dlsym(alsa_lib, "snd_pcm_open")` does:**

1. **Looks up "snd_pcm_open" in ALSA's symbol table**

   ```
   Symbol table says: "snd_pcm_open lives at offset 0x45a10"
   ```

2. **Calculates absolute address**

   ```
   Base address (from dlopen): 0x7f3a2c000000
   Offset (from symbol table):      0x00045a10
   -------------------------------------------
   Actual function address:    0x7f3a2c045a10
   ```

3. **Returns address as `void *`**
   ```c
   void *func_ptr = dlsym(alsa_lib, "snd_pcm_open");
   // func_ptr now holds 0x7f3a2c045a10
   ```

**Web Dev Analogy:**

```javascript
// Symbol table = JavaScript object
const alsa = {
  snd_pcm_open: function () {
    /* ... */
  }, // Offset: memory address
  snd_pcm_close: function () {
    /* ... */
  },
};

// dlsym() = property lookup
const funcPtr = alsa["snd_pcm_open"]; // Returns function reference
```

---

### 4. The Double Pointer Cast (`*(void **)(&SndPcmOpen_)`)

**Why not just `SndPcmOpen_ = dlsym(...)`?**

Let's break down the types:

```c
// 1. SndPcmOpen_ is a function POINTER (not a function)
alsa_snd_pcm_open *SndPcmOpen_;
// Type: pointer to function returning int

// 2. dlsym returns void * (generic pointer to ANYTHING)
void *dlsym(void *handle, const char *symbol);

// 3. The problem: Can't directly assign void* to function pointer
SndPcmOpen_ = dlsym(alsa_lib, "snd_pcm_open"); // ‚ùå COMPILER ERROR!
// "ISO C forbids assignment between function pointer and void *"
```

**The workaround (Casey's pattern):**

```c
// Step 1: Take address of function pointer (now it's void** not function*)
&SndPcmOpen_
// Type: pointer to pointer to function

// Step 2: Cast to void** (generic pointer-to-pointer)
(void **)(&SndPcmOpen_)

// Step 3: Dereference and assign
*(void **)(&SndPcmOpen_) = dlsym(alsa_lib, "snd_pcm_open");
```

**Memory layout:**

```
Stack:
  SndPcmOpen_: [0x7f3a2c045a10]  ‚Üê Function pointer variable
               ^
               Points to actual function in ALSA library

Heap (ALSA library):
  0x7f3a2c045a10: [Assembly code for snd_pcm_open]
```

**Web Dev Analogy:**

```javascript
// In C, function pointers have strict types
let myFunc: (x: number) => number;

// dlsym returns "any" (like void*)
const funcFromLib: any = getSymbol("snd_pcm_open");

// TypeScript won't let you assign:
myFunc = funcFromLib; // ‚ùå Type error

// The cast is like `as` in TypeScript:
myFunc = funcFromLib as ((x: number) => number); // ‚úÖ
```

---

## üß™ Hands-On Exercises

### Exercise 1: See dlopen/dlsym in Action

Create `test_dlopen.c`:

```c
#include <stdio.h>
#include <dlfcn.h>

int main() {
    void *libasound = dlopen("libasound.so.2", RTLD_NOW);
    if (!libasound) {
        printf("Error loading ALSA: %s\n", dlerror());
        return 1;
    }

    int (*snd_pcm_open)(void **, const char *, int, int);
    *(void **)(&snd_pcm_open) = dlsym(libasound, "snd_pcm_open");
    if (!snd_pcm_open) {
        printf("Error finding symbol: %s\n", dlerror());
        dlclose(libasound);
        return 1;
    }

    // You would also need to dynamically load snd_pcm_close and snd_strerror if you use them.
    printf("snd_pcm_open loaded at address: %p\n", (void*)snd_pcm_open);

    dlclose(libasound);
    return 0;
}
```

**Compile and run:**

```bash
gcc -o test_dlopen test_dlopen.c -ldl
./test_dlopen
```

**Expected output:**

```
snd_pcm_open loaded at address: 0x7f3a2c045a10  ‚Üê Your address will differ
```

**Questions to answer:**

1. What happens if you change `"libm.so.6"` to `"libm.so.999"`?
2. What happens if you change `"cos"` to `"cosine"`?
3. What does `dlerror()` return in each case?

---

### Exercise 2: Compare Static vs Dynamic Linking

**A. Static linking (normal way):**

```c
// static_cos.c
// static_pcm_open.c
#include <stdio.h>
#include <alsa/asoundlib.h>

int main() {
  snd_pcm_t *handle;
  int err = snd_pcm_open(&handle, "default", SND_PCM_STREAM_PLAYBACK, 0);
  if (err < 0) {
      printf("Error opening PCM device: %s\n", snd_strerror(err));
      return 1;
  }
  printf("snd_pcm_open succeeded\n");
  snd_pcm_close(handle);
  return 0;
}
```

```bash
gcc -o static_pcm_open static_pcm_open.c -lasound
ls -lh static_pcm_open  # Note size
ldd static_pcm_open     # Shows shared libraries
```

**B. Dynamic loading (Casey's way):**

```c
// Use test_dlopen.c from Exercise 1
```

**Compare:**

```bash
ls -lh test_dlopen  # Size similar to static_cos
ldd test_dlopen     # Does NOT show libm! (loaded at runtime)
```

**Question:** Why does Casey prefer B for audio libraries?

<details>
<summary>Answer</summary>
If ALSA isn't installed, the game still runs (without audio). With static linking, it would crash immediately.
</details>

---

### Exercise 3: Debug Symbol Resolution

**Add debug prints to your ALSA loading code:**

```c
void linux_load_alsa(void) {
  printf("üîç Attempting to load ALSA...\n");

  void *alsa_lib = dlopen("libasound.so.2", RTLD_NOW);
  if (!alsa_lib) {
    printf("‚ùå dlopen failed: %s\n", dlerror());
    // Try alternative name
    alsa_lib = dlopen("libasound.so", RTLD_NOW);
    if (!alsa_lib) {
      printf("‚ùå Also tried libasound.so: %s\n", dlerror());
      return;
    }
  }
  printf("‚úÖ ALSA loaded at: %p\n", alsa_lib);

  // Load each symbol with debug output
  printf("üîç Looking up snd_pcm_open...\n");
  *(void **)(&SndPcmOpen_) = dlsym(alsa_lib, "snd_pcm_open");
  if (!SndPcmOpen_) {
    printf("‚ùå Symbol not found: %s\n", dlerror());
  } else {
    printf("‚úÖ snd_pcm_open found at: %p\n", (void*)SndPcmOpen_);
  }

  // Repeat for other symbols...
}
```

**Run and observe:**

- Which symbols are found?
- What are their memory addresses?
- Are they close together? (They should be‚Äîfunctions in same .so)

---

## üéì Comprehension Check

**Before moving to L1.2, answer these:**

1. **Awareness:** In `audio.c`, find the line where `dlopen()` is called. What file is it loading?

2. **Comprehension:** Explain in your own words: Why does `dlsym()` return `void *` instead of a function pointer?

3. **Application:** Modify `audio.c` to try loading `"libasound.so"` (without `.2`) if `"libasound.so.2"` fails.

4. **Analysis:** If you see "symbol lookup error" at runtime, is it a dlopen or dlsym failure? How would you debug it?

5. **Synthesis:** Write pseudocode for a `load_library()` function that takes a library name and symbol name, and returns a function pointer.

---

## üîó Connection to Next Lesson

**L1.2: Symbol Tables**

- We glossed over "symbol tables" here
- Next lesson: HOW does `dlsym()` actually search the table?
- What's the performance cost of symbol lookup?
- Why does Casey cache function pointers instead of calling `dlsym()` every frame?

---

## üìù Reflection Questions (Write in UNITS-TRACKER.md)

1. **Aha Moment:** What clicked for you in this lesson?

2. **Web Dev Connection:** What's the closest JavaScript/Node.js equivalent you've used?

3. **Still Confusing:** What part still feels like magic?

4. **Real-World Question:** When would you choose static linking over dynamic loading?

---

**When you're ready, update UNITS-TRACKER.md and move to L1.2!** ‚úÖ
