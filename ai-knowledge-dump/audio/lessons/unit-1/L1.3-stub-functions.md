# Unit 1, Lesson 3: Stub Functions Pattern

> **Learning Goal:** Understand why Casey uses stub functions for graceful degradation  
> **Time Estimate:** 30-45 minutes  
> **Prerequisite:** L1.2 (Symbol Tables)

---

## üéØ The Mystery You're Solving

In `audio.c:73-130`, you see stub functions like this:

```c
ALSA_SND_PCM_OPEN(AlsaSndPcmOpenStub) {
  (void)pcm; (void)device; (void)stream; (void)mode;
  return -1;  // Why -1? Why not crash?
}

// Global function pointer - starts pointing to stub
alsa_snd_pcm_open *SndPcmOpen_ = AlsaSndPcmOpenStub;
```

**Questions:**
- Why not just leave function pointers NULL?
- What happens if we call a stub function?
- How does this enable "graceful degradation"?
- Why `(void)pcm` for unused parameters?

---

## üìö Core Concepts

### 1. The Problem: NULL Pointers Crash

**Naive approach (NO stubs):**
```c
// Start with NULL pointers
alsa_snd_pcm_open *SndPcmOpen_ = NULL;

void linux_load_alsa(void) {
  void *alsa = dlopen("libasound.so.2", RTLD_NOW);
  if (!alsa) {
    printf("ALSA not found, audio disabled\n");
    return;  // SndPcmOpen_ still NULL!
  }
  *(void **)(&SndPcmOpen_) = dlsym(alsa, "snd_pcm_open");
}

// Later in code:
bool init_audio() {
  snd_pcm_t *handle;
  int err = SndPcmOpen_(&handle, "default", 0, 0);  // üí• SEGFAULT!
  //        ^--- Calling NULL pointer!
}
```

**What happens:**
```
Segmentation fault (core dumped)
```

**Web Dev Analogy:**
```javascript
// JavaScript equivalent
let audioAPI = null;

async function loadAudio() {
  try {
    audioAPI = await import('audio-lib');
  } catch (e) {
    console.log("Audio library not found");
    // audioAPI still null!
  }
}

// Later...
audioAPI.init();  // ‚ùå TypeError: Cannot read property 'init' of null
```

---

### 2. The Solution: Stub Functions

**Casey's pattern (WITH stubs):**
```c
// Stub returns error instead of crashing
ALSA_SND_PCM_OPEN(AlsaSndPcmOpenStub) {
  (void)pcm; (void)device; (void)stream; (void)mode;
  return -1;  // ALSA error code for "operation not supported"
}

// Start pointing to stub (NOT NULL)
alsa_snd_pcm_open *SndPcmOpen_ = AlsaSndPcmOpenStub;

void linux_load_alsa(void) {
  void *alsa = dlopen("libasound.so.2", RTLD_NOW);
  if (!alsa) {
    // Keep pointing to stub - no crash!
    return;
  }
  *(void **)(&SndPcmOpen_) = dlsym(alsa, "snd_pcm_open");
  // Now points to real function
}

// Later in code:
bool init_audio() {
  snd_pcm_t *handle;
  int err = SndPcmOpen_(&handle, "default", 0, 0);
  if (err < 0) {
    printf("Audio init failed (ALSA not loaded)\n");
    return false;  // Graceful fallback!
  }
  return true;
}
```

**What happens:**
```
Audio init failed (ALSA not loaded)
Game continues without audio ‚úÖ
```

**Web Dev Analogy:**
```javascript
// Stub = default implementation
const audioStub = {
  init: () => ({ success: false, error: "Not loaded" }),
  play: () => {},
  stop: () => {}
};

let audioAPI = audioStub;  // Start with stub

async function loadAudio() {
  try {
    audioAPI = await import('audio-lib');
  } catch (e) {
    // Keep using stub - no crash!
    console.log("Audio disabled");
  }
}

// Later...
const result = audioAPI.init();  // ‚úÖ Returns error, doesn't crash
if (!result.success) {
  console.log("Audio not available, continuing...");
}
```

---

### 3. Why `(void)parameter` for Unused Parameters?

**The compiler warning:**
```c
ALSA_SND_PCM_OPEN(AlsaSndPcmOpenStub) {
  return -1;  // ‚ö†Ô∏è Warning: unused parameter 'pcm'
              // ‚ö†Ô∏è Warning: unused parameter 'device'
              // ‚ö†Ô∏è Warning: unused parameter 'stream'
              // ‚ö†Ô∏è Warning: unused parameter 'mode'
}
```

**Why these warnings?**
- Compiler thinks: "You declared these parameters but never use them‚Äîtypo?"
- In release builds: No performance cost (parameters not used = optimized away)
- But warnings clutter build output

**Casey's solution:**
```c
ALSA_SND_PCM_OPEN(AlsaSndPcmOpenStub) {
  (void)pcm;      // Tell compiler: "I know I'm not using this"
  (void)device;   // Not a typo, intentionally unused
  (void)stream;
  (void)mode;
  return -1;
}
```

**Alternative (GCC/Clang):**
```c
ALSA_SND_PCM_OPEN(AlsaSndPcmOpenStub) {
  __attribute__((unused)) pcm;
  __attribute__((unused)) device;
  // ... more verbose
  return -1;
}
```

**Why Casey's way is better:**
- Shorter, cleaner
- Works on all compilers (MSVC, GCC, Clang)
- Zero runtime cost (optimized to nothing)

---

### 4. Stub Return Values: Error Codes vs Success

**ALSA convention:**
- `0` = Success
- `-1` or negative = Error (errno style)

**Stub functions mimic errors:**
```c
// Returns error code
ALSA_SND_PCM_OPEN(AlsaSndPcmOpenStub) {
  return -1;  // "Operation not permitted"
}

// Returns 0 (pretend success for cleanup)
ALSA_SND_PCM_CLOSE(AlsaSndPcmCloseStub) {
  return 0;  // Closing nothing is "successful"
}

// Returns empty string (not NULL!)
ALSA_SND_STRERROR(AlsaSndStrerrorStub) {
  return "ALSA not loaded";  // Safe to printf()
}

// Returns 0 frames written
ALSA_SND_PCM_WRITEI(AlsaSndPcmWriteiStub) {
  return 0;  // Wrote 0 samples (audio disabled)
}
```

**Pattern:**
- **Write operations:** Return 0 (nothing written)
- **Read operations:** Return 0 (nothing read)
- **Init operations:** Return -1 (failed)
- **Cleanup operations:** Return 0 (nothing to clean)
- **String operations:** Return safe default (not NULL)

---

## üß™ Hands-On Exercises

### Exercise 1: Test Stub Behavior

Create `test_stubs.c`:
```c
#include <stdio.h>

// Stub function
int my_stub_function(int a, int b) {
  (void)a;
  (void)b;
  printf("Stub called! Returning -1\n");
  return -1;
}

// Function pointer (starts pointing to stub)
int (*MyFunc)(int, int) = my_stub_function;

int main() {
  // Call through pointer (currently stub)
  int result = MyFunc(10, 20);
  printf("Result: %d\n\n", result);
  
  // Simulate loading real function
  int real_add(int x, int y) { return x + y; }
  MyFunc = real_add;
  
  // Call again (now real function)
  result = MyFunc(10, 20);
  printf("Result: %d\n", result);
  
  return 0;
}
```

**Compile and run:**
```bash
gcc -o test_stubs test_stubs.c
./test_stubs
```

**Expected output:**
```
Stub called! Returning -1
Result: -1

Result: 30
```

**Questions:**
1. What happens if you don't cast `real_add` to the function pointer type?
2. Can you switch back to the stub at runtime? Try it!
3. What if `real_add` had different parameters? (Try it and see compiler error)

---

### Exercise 2: Compare NULL vs Stub

Create `compare_null_stub.c`:
```c
#include <stdio.h>

// A. NULL pointer approach
int (*NullFunc)(int) = NULL;

// B. Stub approach
int stub(int x) {
  (void)x;
  return -1;
}
int (*StubFunc)(int) = stub;

int main() {
  // Test NULL pointer
  printf("Testing NULL pointer:\n");
  if (NullFunc != NULL) {
    int result = NullFunc(42);
    printf("Result: %d\n", result);
  } else {
    printf("Function is NULL, skipping call\n");
  }
  
  // Test stub
  printf("\nTesting stub:\n");
  int result = StubFunc(42);  // No NULL check needed!
  if (result < 0) {
    printf("Function failed (returned %d)\n", result);
  }
  
  // Uncomment to see crash:
  // printf("\nCrashing with NULL:\n");
  // NullFunc(42);  // üí• SEGFAULT
  
  return 0;
}
```

**Compile and run:**
```bash
gcc -o compare_null_stub compare_null_stub.c
./compare_null_stub
```

**Expected output:**
```
Testing NULL pointer:
Function is NULL, skipping call

Testing stub:
Function failed (returned -1)
```

**Question:** What's the advantage of stub over NULL check?
<details>
<summary>Answer</summary>
No need for NULL checks everywhere! Caller doesn't need to know if library loaded. Just check return value like normal error handling.
</details>

---

### Exercise 3: Add Stub Diagnostics

**Modify your stubs to track calls:**

```c
#if HANDMADE_INTERNAL
static int g_stub_call_count = 0;
#endif

ALSA_SND_PCM_OPEN(AlsaSndPcmOpenStub) {
  (void)pcm; (void)device; (void)stream; (void)mode;
  
  #if HANDMADE_INTERNAL
  g_stub_call_count++;
  if (g_stub_call_count == 1) {
    printf("‚ö†Ô∏è  snd_pcm_open stub called (ALSA not loaded)\n");
  }
  #endif
  
  return -1;
}

ALSA_SND_PCM_WRITEI(AlsaSndPcmWriteiStub) {
  (void)pcm; (void)backbuffer; (void)frames;
  
  #if HANDMADE_INTERNAL
  static int write_stub_calls = 0;
  if (++write_stub_calls <= 5) {  // Only log first 5 calls
    printf("‚ö†Ô∏è  Audio write stub called (frame %d)\n", write_stub_calls);
  }
  #endif
  
  return 0;
}
```

**Build and run:**
```bash
# Temporarily rename libasound.so.2 to force stubs
sudo mv /usr/lib/x86_64-linux-gnu/libasound.so.2{,.backup}

# Run your game
./handmade

# Restore library
sudo mv /usr/lib/x86_64-linux-gnu/libasound.so.2{.backup,}
```

**Expected output:**
```
‚ö†Ô∏è  snd_pcm_open stub called (ALSA not loaded)
‚ö†Ô∏è  Audio write stub called (frame 1)
‚ö†Ô∏è  Audio write stub called (frame 2)
‚ö†Ô∏è  Audio write stub called (frame 3)
Game continues without audio...
```

---

### Exercise 4: Implement Stub Pattern for Custom API

**Create a plugin system using stubs:**

```c
#include <stdio.h>

// Plugin API
#define PLUGIN_INIT(name) int name(const char *config)
typedef PLUGIN_INIT(plugin_init_fn);

#define PLUGIN_UPDATE(name) void name(float dt)
typedef PLUGIN_UPDATE(plugin_update_fn);

// Stubs (plugin not loaded)
PLUGIN_INIT(PluginInitStub) {
  (void)config;
  printf("[Stub] Plugin not loaded\n");
  return -1;
}

PLUGIN_UPDATE(PluginUpdateStub) {
  (void)dt;
  // Silent no-op (no spam in game loop)
}

// Function pointers (start with stubs)
plugin_init_fn *PluginInit = PluginInitStub;
plugin_update_fn *PluginUpdate = PluginUpdateStub;

// Simulate loading plugin
void load_plugin() {
  // In real code: dlopen + dlsym
  PLUGIN_INIT(RealPluginInit) {
    printf("[Plugin] Initialized with config: %s\n", config);
    return 0;
  }
  
  PLUGIN_UPDATE(RealPluginUpdate) {
    printf("[Plugin] Update dt=%.3f\n", dt);
  }
  
  PluginInit = RealPluginInit;
  PluginUpdate = RealPluginUpdate;
}

int main() {
  // Try to init before loading (uses stub)
  int result = PluginInit("test.cfg");
  if (result < 0) {
    printf("Plugin init failed, continuing without plugin\n");
  }
  
  // Game loop (stub does nothing)
  for (int i = 0; i < 3; i++) {
    PluginUpdate(0.016f);
  }
  
  printf("\n--- Loading plugin ---\n\n");
  load_plugin();
  
  // Try again (now uses real plugin)
  result = PluginInit("test.cfg");
  
  // Game loop (real plugin)
  for (int i = 0; i < 3; i++) {
    PluginUpdate(0.016f);
  }
  
  return 0;
}
```

**Compile and run:**
```bash
gcc -o plugin_stubs plugin_stubs.c
./plugin_stubs
```

**Expected output:**
```
[Stub] Plugin not loaded
Plugin init failed, continuing without plugin

--- Loading plugin ---

[Plugin] Initialized with config: test.cfg
[Plugin] Update dt=0.016
[Plugin] Update dt=0.016
[Plugin] Update dt=0.016
```

---

## üéì Comprehension Check

**Before moving to L1.4, answer these:**

1. **Awareness:** Find all stub functions in `audio.c`. How many are there?

2. **Comprehension:** Why return `-1` from init stubs but `0` from write stubs?

3. **Application:** Add a debug counter to track how many times stubs are called.

4. **Analysis:** What happens if you forget the `(void)param` casts? Try it!

5. **Synthesis:** Design stubs for a graphics API (OpenGL). What should `glDrawArrays` stub return?

6. **Evaluation:** Could you use C++ exceptions instead of stubs? Pros/cons?

---

## üîó Connection to Next Lesson

**L1.4: Macro Pattern (Casey's Style)**
- You've seen `ALSA_SND_PCM_OPEN(name)` macro
- Next: Why macros instead of plain function pointers?
- How does this make code more maintainable?

---

## üìù Reflection Questions (Write in UNITS-TRACKER.md)

1. **Aha Moment:** When did the "graceful degradation" concept click?

2. **Debugging Insight:** How would stub diagnostics help you?

3. **Web Dev Connection:** Is this like try/catch with default values?

4. **Design Decision:** When would you NOT want stubs? (Hint: critical systems)

---

**When ready, update UNITS-TRACKER.md and move to L1.4!** ‚úÖ
