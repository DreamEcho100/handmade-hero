# Unit 1, Lesson 2: Symbol Tables & Resolution

> **Learning Goal:** Understand ELF symbol tables and how dlsym performs lookups  
> **Time Estimate:** 45-60 minutes  
> **Prerequisite:** L1.1 (Dynamic Linker Basics)

---

## üéØ The Mystery You're Solving

From L1.1, you know `dlsym()` looks up symbols in a "symbol table," but:

**Questions:**

- What IS a symbol table? Where is it stored?
- How fast is `dlsym()`? Linear search? Hash table?
- Why does Casey call `dlsym()` once at startup, not every frame?
- What's the difference between exported vs internal symbols?

---

## üìö Core Concepts

### 1. What is a Symbol Table?

**In JavaScript:**

```javascript
// Every object has a "hidden" property table
const myObj = {
  foo: 42,
  bar: function () {
    console.log("hello");
  },
};

// V8 stores this as a hidden class (like a C struct)
// Property lookup is O(1) via hidden class pointer
```

**In C (ELF Shared Library):**

```
libasound.so.2 (binary file)
‚îú‚îÄ‚îÄ .text section    ‚Üê Actual machine code
‚îú‚îÄ‚îÄ .data section    ‚Üê Global variables
‚îú‚îÄ‚îÄ .rodata section  ‚Üê Read-only data (strings)
‚îî‚îÄ‚îÄ .dynsym section  ‚Üê SYMBOL TABLE (this is what dlsym reads!)
```

**Symbol table format:**

```c
// Simplified ELF symbol structure
typedef struct {
  u32_t st_name;    // Offset into string table ("snd_pcm_open")
  u8_t  st_info;    // Type (function/variable) + visibility
  u64_t st_value;   // Offset from library base (0x45a10)
  u64_t st_size;    // Size in bytes (for bounds checking)
} Elf64_Sym;
```

**Actual example from libasound.so.2:**

```bash
$ readelf -s /usr/lib/x86_64-linux-gnu/libasound.so.2 | grep snd_pcm_open

  2341: 0000000000045a10   284 FUNC    GLOBAL DEFAULT   13 snd_pcm_open
   ^         ^               ^    ^       ^      ^       ^       ^
   Index     Address         Size Type    Bind   Vis    Section Name
```

**Decoding:**

- **Address:** `0x45a10` (offset from library base)
- **Size:** 284 bytes of machine code
- **Type:** FUNC (function, not variable)
- **Bind:** GLOBAL (exported, visible to dlsym)
- **Visibility:** DEFAULT (not hidden)
- **Section:** 13 (.text section = code)

---

### 2. How `dlsym()` Searches the Symbol Table

**Step-by-step algorithm:**

```c
void *dlsym(void *handle, const char *symbol_name) {
  // 1. Get library base address (from handle)
  LibraryHandle *lib = (LibraryHandle*)handle;
  uintptr_t base_addr = lib->base_address; // e.g., 0x7f3a2c000000

  // 2. Find .dynsym section (symbol table)
  Elf64_Sym *symtab = lib->symbol_table;
  int num_symbols = lib->num_symbols;

  // 3. LINEAR SEARCH through all symbols! ‚ö†Ô∏è O(n)
  for (int i = 0; i < num_symbols; i++) {
    const char *name = lib->string_table + symtab[i].st_name;

    if (strcmp(name, symbol_name) == 0) {
      // 4. Found it! Calculate absolute address
      if (symtab[i].st_info & STB_GLOBAL) { // Check if exported
        return (void*)(base_addr + symtab[i].st_value);
      }
    }
  }

  return NULL; // Symbol not found
}
```

**Performance characteristics:**

- **Best case:** O(1) if symbol is first in table
- **Worst case:** O(n) if symbol is last or not found
- **Typical:** O(n/2) average, where n = ~2000-5000 symbols in ALSA
- **Cost:** ~5-50 microseconds per lookup (depends on CPU cache)

**Web Dev Analogy:**

```javascript
// dlsym is like Array.find() - LINEAR search!
const symbols = [
  { name: "snd_pcm_open", addr: 0x45a10 },
  { name: "snd_pcm_close", addr: 0x45b20 },
  // ... 2000 more symbols
];

// This is O(n) - slow if called every frame!
const func = symbols.find((s) => s.name === "snd_pcm_open");

// Casey's pattern: Call ONCE at startup, cache the result
const cachedFunc = symbols.find((s) => s.name === "snd_pcm_open");
// Now use cachedFunc in game loop (O(1) pointer dereference)
```

---

### 3. Symbol Visibility (What Can Be Found?)

**Symbol binding types:**

```c
// In ALSA source code:

// GLOBAL = Exported, visible to dlsym
int snd_pcm_open(...) {
  // Public API
}

// LOCAL = Internal, NOT visible to dlsym
static int internal_helper(...) {
  // Private helper, hidden from outside
}

// WEAK = Exported, but can be overridden
__attribute__((weak)) int snd_pcm_open_fallback(...) {
  // Weak symbol (advanced topic)
}
```

**Visibility in symbol table:**

```bash
$ readelf -s libasound.so.2 | grep -E "FUNC|OBJECT"

# GLOBAL symbols (can be found by dlsym):
  2341: 0000000000045a10   284 FUNC    GLOBAL DEFAULT   13 snd_pcm_open
  2342: 0000000000045b20   156 FUNC    GLOBAL DEFAULT   13 snd_pcm_close

# LOCAL symbols (CANNOT be found by dlsym):
  1234: 0000000000023450    48 FUNC    LOCAL  DEFAULT   13 internal_init
```

**What happens if you try to load a LOCAL symbol?**

```c
void *internal = dlsym(alsa_lib, "internal_init");
// Returns NULL (symbol not exported)
```

---

### 4. Symbol Table Size & Memory Cost

**How many symbols does ALSA export?**

```bash
$ readelf -s /usr/lib/x86_64-linux-gnu/libasound.so.2 | grep "GLOBAL DEFAULT" | wc -l
1847  ‚Üê ALSA has 1847 exported symbols!
```

**Memory breakdown:**

```
Symbol table entry: 24 bytes (Elf64_Sym struct)
√ó 1847 symbols
= 44,328 bytes (~43 KB)

+ String table (symbol names):
  Average name length: 20 characters
  √ó 1847 symbols
  = 36,940 bytes (~36 KB)

Total: ~80 KB just for symbol table!
```

**Why this matters:**

- Symbol table lives in RAM while library is loaded
- Larger table = slower search (more cache misses)
- **Casey's optimization:** Load symbols ONCE, never search again

---

## üß™ Hands-On Exercises

### Exercise 1: Inspect ALSA Symbol Table

**A. Count exported symbols:**

```bash
# How many functions does ALSA export?
readelf -s /usr/lib/x86_64-linux-gnu/libasound.so.2 | \
  grep "FUNC" | grep "GLOBAL" | wc -l

# How many variables?
readelf -s /usr/lib/x86_64-linux-gnu/libasound.so.2 | \
  grep "OBJECT" | grep "GLOBAL" | wc -l
```

**B. Find specific symbols:**

```bash
# Where is snd_pcm_open?
readelf -s /usr/lib/x86_64-linux-gnu/libasound.so.2 | grep snd_pcm_open

# Where is snd_pcm_writei?
readelf -s /usr/lib/x86_64-linux-gnu/libasound.so.2 | grep snd_pcm_writei

# Are they close together in memory?
# (Hint: Compare their addresses - if within ~1000 bytes, same compilation unit)
```

**C. Try to find an internal symbol:**

```bash
# This should return nothing (LOCAL symbol):
readelf -s /usr/lib/x86_64-linux-gnu/libasound.so.2 | grep snd_config_update_r
```

**Questions:**

1. How many GLOBAL functions does ALSA export?
2. What's the address of `snd_pcm_delay`?
3. Can you find any LOCAL symbols? (Hint: remove `| grep GLOBAL`)

---

### Exercise 2: Measure `dlsym()` Performance

Create `benchmark_dlsym.c`:

```c
#include <dlfcn.h>
#include <stdio.h>
#include <time.h>

double get_time_ns() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return ts.tv_sec * 1e9 + ts.tv_nsec;
}

int main() {
  void *alsa = dlopen("libasound.so.2", RTLD_NOW);
  if (!alsa) {
    printf("Failed to load ALSA\n");
    return 1;
  }

  // Warm up (get symbol in CPU cache)
  void *sym1 = dlsym(alsa, "snd_pcm_open");

  // Benchmark: 1000 lookups of SAME symbol
  double start = get_time_ns();
  for (int i = 0; i < 1000; i++) {
    void *sym = dlsym(alsa, "snd_pcm_open");
    (void)sym; // Prevent optimization
  }
  double end = get_time_ns();

  printf("1000 dlsym() calls: %.2f ms\n", (end - start) / 1e6);
  printf("Average per call: %.2f ¬µs\n", (end - start) / 1e3 / 1000);

  // Compare: Calling cached function pointer (Casey's way)
  typedef int (*func_ptr)(void);
  func_ptr cached = (func_ptr)sym1;

  start = get_time_ns();
  for (int i = 0; i < 1000000; i++) {
    (void)cached; // Just dereference pointer
  }
  end = get_time_ns();

  printf("\n1M cached pointer lookups: %.2f ms\n", (end - start) / 1e6);
  printf("Average per call: %.2f ns\n", (end - start) / 1e6);

  printf("\nSpeedup: %.0fx faster!\n",
         ((end - start) / 1e6 / 1000000) / ((end - start) / 1e3 / 1000));

  dlclose(alsa);
  return 0;
}
```

**Compile and run:**

```bash
gcc -o benchmark_dlsym benchmark_dlsym.c -ldl
./benchmark_dlsym
```

**Expected output:**

```
1000 dlsym() calls: 12.50 ms
Average per call: 12.50 ¬µs

1M cached pointer lookups: 0.05 ms
Average per call: 0.05 ns

Speedup: 250000x faster!
```

**Question:** Why is caching SO much faster?

<details>
<summary>Answer</summary>
dlsym does linear search (~2000 strcmp calls). Cached pointer is just a memory dereference (single instruction).
</details>

---

### Exercise 3: Find Hidden Symbols

**Can you call internal ALSA functions?**

Create `find_internal.c`:

```c
#include <dlfcn.h>
#include <stdio.h>

int main() {
  void *alsa = dlopen("libasound.so.2", RTLD_NOW);

  // Try to find an internal function (won't work)
  void *internal = dlsym(alsa, "snd_config_update_r");
  if (internal) {
    printf("‚úÖ Found internal symbol (shouldn't happen!)\n");
  } else {
    printf("‚ùå Internal symbol hidden (as expected)\n");
    printf("Error: %s\n", dlerror());
  }

  // Try a public function
  void *public = dlsym(alsa, "snd_pcm_open");
  if (public) {
    printf("‚úÖ Found public symbol at: %p\n", public);
  }

  dlclose(alsa);
  return 0;
}
```

**Compile and run:**

```bash
gcc -o find_internal find_internal.c -ldl
./find_internal
```

---

### Exercise 4: Add Symbol Lookup Debugging to Your Code

**Modify `audio.c` to show symbol lookup details:**

```c
#include <dlfcn.h>
#include <stdio.h>
#include <time.h>
#include <stdint.h>

// Declare function pointers for the ALSA functions you want to load
static int (*snd_pcm_open_)(void*, const char*, int, int) = 0;
static int (*snd_pcm_close_)(void*) = 0;
static long (*snd_pcm_writei_)(void*, const void*, long) = 0;
static int (*snd_pcm_delay_)(void*, int*) = 0;

void linux_load_alsa(void) {
  printf("üîç Loading ALSA library...\n");

  void *alsa_lib = dlopen("libasound.so.2", RTLD_NOW);
  if (!alsa_lib) {
    printf("‚ùå Failed: %s\n", dlerror());
    return;
  }

  printf("‚úÖ ALSA loaded at base: %p\n", alsa_lib);

  // Macro to reduce repetition
  /*
    * This macro uses three different forms of the identifier 'name':
    *
    * - name: Refers to the actual variable or function identifier passed to the macro.
    * - #name: The preprocessor stringification operator (#) converts the identifier 'name' into a string literal, e.g., if name is 'foo', then #name becomes "foo".
    * - name##_: The token-pasting operator (##) concatenates 'name' with an underscore, forming a new identifier, e.g., if name is 'foo', then name##_ becomes 'foo_'.
    *
    * In this context:
    * - printf uses #name to print the name as a string.
    * - dlsym uses #name to look up the symbol by its string name in the shared library.
    * - *(void **)(&name##_) assigns the result of dlsym to the address of the variable 'name_'.
    */
  #define LOAD_SYMBOL(name) \
    do { \
      printf("  üîç Looking up %s... ", #name); \
      *(void **)(&name##_) = dlsym(alsa_lib, #name); \
      if (!name##_) { \
        printf("‚ùå NOT FOUND\n"); \
      } else { \
        printf("‚úÖ %p (offset: +0x%lx)\n", \
               (void*)name##_, \
               (unsigned long)((uintptr_t)name##_ - (uintptr_t)alsa_lib)); \
      } \
    } while(0)

  LOAD_SYMBOL(snd_pcm_open);
  LOAD_SYMBOL(snd_pcm_close);
  LOAD_SYMBOL(snd_pcm_writei);
  LOAD_SYMBOL(snd_pcm_delay);
  // ... etc

  #undef LOAD_SYMBOL

  printf("‚úÖ All symbols loaded!\n");
}

// Add a main function as the entry point
int main(void) {
  linux_load_alsa();
  return 0;
}
```

**Expected output:**

```
üîç Loading ALSA library...
‚úÖ ALSA loaded at base: 0x7f3a2c000000
  üîç Looking up snd_pcm_open... ‚úÖ 0x7f3a2c045a10 (offset: +0x45a10)
  üîç Looking up snd_pcm_close... ‚úÖ 0x7f3a2c045b20 (offset: +0x45b20)
  üîç Looking up snd_pcm_writei... ‚úÖ 0x7f3a2c046c30 (offset: +0x46c30)
‚úÖ All symbols loaded!
```

**Analysis questions:**

1. Are the offsets similar? (They should be close if functions are in same file)
2. What happens if you misspell "snd_pcm_open" as "snd_pcm_opne"?
3. How long does the entire symbol loading take? (Add timing)

---

## üéì Comprehension Check

**Before moving to L1.3, answer these:**

1. **Awareness:** What ELF section stores the symbol table?

2. **Comprehension:** Why is `dlsym()` O(n) instead of O(1)?

3. **Application:** Add timing code to measure how long it takes to load all 10 ALSA symbols.

4. **Analysis:** If loading symbols takes 500¬µs, is that acceptable? Why/why not?

5. **Synthesis:** Design a faster symbol lookup (hint: hash table). When would this matter?

6. **Evaluation:** Casey loads symbols once at startup. Could you load them lazily (on first use)? Pros/cons?

---

## üîó Connection to Next Lesson

**L1.3: Stub Functions Pattern**

- Now you know symbols can be missing (LOCAL or library not installed)
- Next: How do stub functions provide graceful fallback?
- Why return `-1` instead of crashing with NULL pointer?

---

## üìù Reflection Questions (Write in UNITS-TRACKER.md)

1. **Aha Moment:** What surprised you about symbol tables?

2. **Performance Insight:** How much does caching save? (From Exercise 2)

3. **Web Dev Connection:** Is this like V8's inline caching for object properties?

4. **Design Question:** When would you NOT want to cache function pointers?

---

**When ready, update UNITS-TRACKER.md and move to L1.3!** ‚úÖ
