# Unit 1, Lesson 4: Macro Pattern (Casey's Style)

> **Learning Goal:** Understand Casey's macro pattern for type-safe function pointer APIs  
> **Time Estimate:** 45-60 minutes  
> **Prerequisite:** L1.3 (Stub Functions)

---

## üéØ The Mystery You're Solving

In `audio.h:58-99`, you see this pattern repeated 10 times:

```c
#define ALSA_SND_PCM_OPEN(name) \
  int name(snd_pcm_t **pcm, const char *device, int stream, int mode)
typedef ALSA_SND_PCM_OPEN(alsa_snd_pcm_open);

// Stub
ALSA_SND_PCM_OPEN(AlsaSndPcmOpenStub) { /*...*/ }

// Global pointer
alsa_snd_pcm_open *SndPcmOpen_;
```

**Questions:**

- Why use macros instead of writing function signatures directly?
- What's the `typedef` doing?
- How does this prevent bugs?
- Why `SndPcmOpen_` with underscore?

---

## üìö Core Concepts

### 1. The Problem: Repetitive Function Pointer Code

**Naive approach (NO macros):**

```c
// Define signature manually
typedef int (*alsa_snd_pcm_open)(snd_pcm_t **pcm, const char *device,
                                  int stream, int mode);

// Stub (must match signature EXACTLY)
int AlsaSndPcmOpenStub(snd_pcm_t **pcm, const char *device,
                       int stream, int mode) {
  (void)pcm; (void)device; (void)stream; (void)mode;
  return -1;
}

// Global pointer
alsa_snd_pcm_open *SndPcmOpen_ = AlsaSndPcmOpenStub;

// Repeat 10 times for each function... üò´
```

**Problems:**

1. **Repetition:** Function signature appears 3 times (typedef, stub, declaration)
2. **Error-prone:** Typo in stub params = hard-to-find bug
3. **Maintenance:** Change signature = update 3 places
4. **Readability:** Lots of boilerplate obscures intent

---

### 2. Casey's Solution: Macro Pattern

**Step 1: Define signature ONCE in a macro**

```c
// Macro = "signature template"
#define ALSA_SND_PCM_OPEN(name) \
  int name(snd_pcm_t **pcm, const char *device, int stream, int mode)
//  ^               ^
//  Return type     Parameters (defined ONCE)
```

**Step 2: Create typedef using macro**

```c
typedef ALSA_SND_PCM_OPEN(alsa_snd_pcm_open);
// Expands to:
// typedef int alsa_snd_pcm_open(snd_pcm_t **pcm, const char *device,
//                                int stream, int mode);
```

**Step 3: Create stub using macro**

```c
ALSA_SND_PCM_OPEN(AlsaSndPcmOpenStub) {
  (void)pcm; (void)device; (void)stream; (void)mode;
  return -1;
}
// Expands to:
// int AlsaSndPcmOpenStub(snd_pcm_t **pcm, const char *device,
//                        int stream, int mode) { ... }
```

**Step 4: Declare function pointer**

```c
alsa_snd_pcm_open *SndPcmOpen_;
// Type comes from typedef (guaranteed to match!)
```

**Benefits:**

- ‚úÖ Signature defined ONCE (DRY principle)
- ‚úÖ Stub signature always matches (compiler enforced)
- ‚úÖ Easy to change signature (update macro only)
- ‚úÖ Clear intent ("this is an ALSA function")

---

### 3. Macro Expansion: What the Compiler Sees

**Your code:**

```c
#define ALSA_SND_PCM_OPEN(name) \
  int name(snd_pcm_t **pcm, const char *device, int stream, int mode)

typedef ALSA_SND_PCM_OPEN(alsa_snd_pcm_open);

ALSA_SND_PCM_OPEN(AlsaSndPcmOpenStub) {
  return -1;
}

alsa_snd_pcm_open *SndPcmOpen_;
```

**After preprocessor (what compiler sees):**

```c
// typedef ALSA_SND_PCM_OPEN(alsa_snd_pcm_open); becomes:
typedef int alsa_snd_pcm_open(snd_pcm_t **pcm, const char *device,
                               int stream, int mode);

// ALSA_SND_PCM_OPEN(AlsaSndPcmOpenStub) becomes:
int AlsaSndPcmOpenStub(snd_pcm_t **pcm, const char *device,
                       int stream, int mode) {
  return -1;
}

// Pointer declaration unchanged:
alsa_snd_pcm_open *SndPcmOpen_;
```

**See it yourself:**

```bash
# Run preprocessor only
gcc -E audio.h | grep -A5 "AlsaSndPcmOpenStub"
```

---

### 4. The `typedef` Pattern Explained

**What does the typedef do?**

```c
typedef ALSA_SND_PCM_OPEN(alsa_snd_pcm_open);
```

**Expands to:**

```c
typedef int alsa_snd_pcm_open(snd_pcm_t **pcm, const char *device,
                               int stream, int mode);
```

**This creates a TYPE (not a variable!):**

```c
// alsa_snd_pcm_open is now a TYPE representing this function signature

// You can use it to declare function pointers:
alsa_snd_pcm_open *SndPcmOpen_;     // Pointer to function
alsa_snd_pcm_open *SndPcmClose_;    // Another pointer (different function)

// Or regular functions:
alsa_snd_pcm_open MyCustomOpen;     // Function (not pointer)
```

**Web Dev Analogy:**

```typescript
// TypeScript type alias
type AudioInitFn = (config: string) => number;

// Use it to declare variables
const init1: AudioInitFn = (config) => 0;
const init2: AudioInitFn = (config) => -1;

// Type system ensures all match signature
const badInit: AudioInitFn = () => "oops"; // ‚ùå Type error!
```

---

### 5. Macro + Underscore Pattern: Detailed Explanation

#### What are the options?

**Option 1: Just a function pointer variable (no macro, no underscore, no alias)**

This is the simplest and most direct approach. You just declare a function pointer variable and use it everywhere, with no macro and no underscore. This is what most C programmers do for function pointers unless they need extra flexibility.

**How it looks:**

```c
typedef int alsa_snd_pcm_open(snd_pcm_t **pcm, const char *device, int stream, int mode);
alsa_snd_pcm_open *SndPcmOpen; // Function pointer variable

// Assign at runtime (e.g. after dlsym):
SndPcmOpen = dlsym(alsa_lib, "snd_pcm_open");

// Call it like a normal function:
int err = SndPcmOpen(&handle, "default", 0, 0);
```

**What happens:**

- `SndPcmOpen` is a variable that holds a function pointer. You assign it at runtime, and you call it just like a function.
- There is no macro, no alias, and no underscore. The name you use everywhere is always `SndPcmOpen`.

**Pros:**

- Simple, direct, and easy to understand‚Äîno macro tricks, no naming confusion.
- No extra boilerplate or naming conventions.
- Easy to debug: when you see `SndPcmOpen`, you know it‚Äôs a variable, not a macro.
- Perfect for small codebases or when you don‚Äôt need to swap implementations.

**Cons:**

- If you ever want to swap implementations (e.g. use a stub, add logging, or test double), you must change every call site or rename the variable.
- No indirection for testing, logging, or API changes. You can‚Äôt globally redirect all calls to a new function without editing every usage.
- Less flexible for large codebases or when you want to change behavior everywhere with one change.

**Summary:**
If you don‚Äôt need to swap implementations or add wrappers, this is the best and least confusing choice. If you want flexibility for testing, logging, or swapping implementations everywhere, consider the macro+underscore pattern below.

---

**Option 2: Macro alias with underscore variable (Casey's pattern)**

```c
typedef int alsa_snd_pcm_open(snd_pcm_t **pcm, const char *device, int stream, int mode);
alsa_snd_pcm_open *SndPcmOpen_; // Actual variable
#define SndPcmOpen SndPcmOpen_  // Macro alias

// Assign at runtime:
SndPcmOpen_ = dlsym(alsa_lib, "snd_pcm_open");

// Call it:
int err = SndPcmOpen(&handle, "default", 0, 0); // Expands to SndPcmOpen_(&handle, ...)
```

**Pros:**

- You can change the macro to point to a different implementation (e.g., a logging wrapper, a stub, a test double) without changing every call site
- Clean API: code looks like a normal function call
- Avoids recursive macro errors (macro and variable have different names)
- Can access the real variable (`SndPcmOpen_`) directly if needed

**Cons:**

- Slightly more complex to understand
- Adds an extra layer of indirection
- Can be confusing if you forget which is the macro and which is the variable

---

**Option 3: Macro alias with same name (DO NOT DO THIS)**

```c
alsa_snd_pcm_open *SndPcmOpen;
#define SndPcmOpen SndPcmOpen // ‚ùå Recursive macro! Causes compiler error
```

**This does NOT work!** The preprocessor will endlessly expand `SndPcmOpen` to itself, causing an error.

---

#### Why use the macro+underscore pattern?

- **Flexibility:** You can swap out the implementation everywhere by changing one macro definition. For example, in tests:
  ```c
  #define SndPcmOpen SndPcmOpenStub
  ```
  In production:
  ```c
  #define SndPcmOpen SndPcmOpen_
  ```
- **Logging/Instrumentation:** You can add a wrapper for logging or debugging:
  ```c
  int SndPcmOpenLogging(snd_pcm_t **pcm, const char *device, int stream, int mode) {
      printf("SndPcmOpen called!\n");
      return SndPcmOpen_Stub(pcm, device, stream, mode);
  }
  #define SndPcmOpen SndPcmOpenLogging
  ```
- **No name collision:** The macro and the variable have different names, so the preprocessor doesn't get stuck.

#### Concrete Example: Swapping Implementations

Suppose you want to use a stub for testing:

```c
int SndPcmOpenStub(snd_pcm_t **pcm, const char *device, int stream, int mode) { return -1; }
alsa_snd_pcm_open *SndPcmOpen_ = SndPcmOpenStub;
#define SndPcmOpen SndPcmOpen_
```

Now, all your code that calls `SndPcmOpen(...)` will use the stub.

Later, you want to add logging:

```c
int SndPcmOpenLogging(snd_pcm_t **pcm, const char *device, int stream, int mode) {
    printf("SndPcmOpen called!\n");
    return SndPcmOpen_(pcm, device, stream, mode);
}
#undef SndPcmOpen
#define SndPcmOpen SndPcmOpenLogging
```

Now, all your code uses the logging wrapper, with no changes to call sites.

#### When is the pattern NOT needed?

- If you never need to swap implementations, add logging, or use stubs, just use the function pointer variable directly (Option 1).
- For small projects or one-off code, the macro+underscore is overkill.

#### When is the pattern USEFUL?

- Large codebases where you want to swap implementations for testing, logging, or platform differences
- When you want to keep your API looking like normal function calls, even if they're function pointers
- When you want to avoid editing every call site if you change the implementation

#### Summary Table

| Pattern                                   | Macro? | Underscore? | Flexible? | Simple? | Usage in code     |
| ----------------------------------------- | ------ | ----------- | --------- | ------- | ----------------- |
| `alsa_snd_pcm_open *SndPcmOpen`           | No     | No          | No        | Yes     | `SndPcmOpen(...)` |
| `alsa_snd_pcm_open *SndPcmOpen_;` + macro | Yes    | Yes         | Yes       | No      | `SndPcmOpen(...)` |

#### Final Analogy

- The macro+underscore is like a ‚Äúredirect‚Äù sign: you can point all traffic (calls) to a new destination (implementation) instantly, without changing every road (call site).
- If you don‚Äôt need to redirect, just use the road directly!

---

## üß™ Hands-On Exercises

### Exercise 1: Expand Macros Manually

**Given:**

```c
#define MY_FUNC(name) void name(int x, int y)

typedef MY_FUNC(my_func_type);

MY_FUNC(MyStub) {
  (void)x; (void)y;
  printf("Stub called\n");
}

my_func_type *MyPtr = MyStub;
```

**Questions:**

1. What does `typedef MY_FUNC(my_func_type);` expand to?
2. What does `MY_FUNC(MyStub) { ... }` expand to?
3. Write the fully-expanded code (no macros).

<details>
<summary>Answer</summary>

```c
// After expansion:
typedef void my_func_type(int x, int y);

void MyStub(int x, int y) {
  (void)x; (void)y;
  printf("Stub called\n");
}

my_func_type *MyPtr = MyStub;
```

</details>

---

### Exercise 2: Use Preprocessor to See Expansions

Create `macro_test.h`:

```c
#define AUDIO_INIT(name) int name(const char *device, int rate)

typedef AUDIO_INIT(audio_init_fn);

AUDIO_INIT(AudioInitStub) {
  (void)device;
  (void)rate;
  return -1;
}

audio_init_fn *AudioInit_;
#define AudioInit AudioInit_
```

**Run preprocessor:**

```bash
gcc -E macro_test.h > expanded.c
cat expanded.c | grep -v "^#" | grep -v "^$"
```

**Expected output:**

```c
typedef int audio_init_fn(const char *device, int rate);

int AudioInitStub(const char *device, int rate) {
  (void)device;
  (void)rate;
  return -1;
}

audio_init_fn *AudioInit_;
```

**Questions:**

1. Where did the `#define` lines go?
2. What happened to `AUDIO_INIT(AudioInitStub)`?
3. Why is `#define AudioInit AudioInit_` missing from output?

---

### Exercise 3: Catch Type Mismatch Bug

**Without macros (bug-prone):**

```c
typedef int (*audio_init)(const char *device, int rate);

// Oops! Stub has wrong signature
int AudioInitStub(const char *device) {  // Missing 'rate' param!
  (void)device;
  return -1;
}

audio_init AudioInit = AudioInitStub;  // ‚ùå Compiler error!
```

**Compile:**

```bash
gcc -c bug_test.c
```

**Error:**

```
error: initialization of 'audio_init' from incompatible pointer type
```

**With macros (bug prevented):**

```c
#define AUDIO_INIT(name) int name(const char *device, int rate)

typedef AUDIO_INIT(audio_init);

AUDIO_INIT(AudioInitStub) {  // MUST have correct params!
  (void)device;
  (void)rate;  // Compiler enforces this exists
  return -1;
}
```

**Question:** Can you make the stub compile with wrong parameters? Try it!

---

### Exercise 4: Refactor Your Own Code

**Before (no macros):**

```c
// graphics_api.h
typedef void (*draw_rect_fn)(int x, int y, int w, int h, u32_t color);
typedef void (*draw_circle_fn)(int cx, int cy, int radius, u32_t color);
typedef void (*draw_line_fn)(int x1, int y1, int x2, int y2, u32_t color);

void DrawRectStub(int x, int y, int w, int h, u32_t color) {
  (void)x; (void)y; (void)w; (void)h; (void)color;
}

void DrawCircleStub(int cx, int cy, int radius, u32_t color) {
  (void)cx; (void)cy; (void)radius; (void)color;
}

void DrawLineStub(int x1, int y1, int x2, int y2, u32_t color) {
  (void)x1; (void)y1; (void)x2; (void)y2; (void)color;
}

draw_rect_fn *DrawRect = DrawRectStub;
draw_circle_fn *DrawCircle = DrawCircleStub;
draw_line_fn *DrawLine = DrawLineStub;
```

**After (Casey's pattern):**

```c
// graphics_api.h
#define GFX_DRAW_RECT(name) \
  void name(int x, int y, int w, int h, u32_t color)
typedef GFX_DRAW_RECT(gfx_draw_rect);

#define GFX_DRAW_CIRCLE(name) \
  void name(int cx, int cy, int radius, u32_t color)
typedef GFX_DRAW_CIRCLE(gfx_draw_circle);

#define GFX_DRAW_LINE(name) \
  void name(int x1, int y1, int x2, int y2, u32_t color)
typedef GFX_DRAW_LINE(gfx_draw_line);

// Stubs
GFX_DRAW_RECT(DrawRectStub) {
  (void)x; (void)y; (void)w; (void)h; (void)color;
}

GFX_DRAW_CIRCLE(DrawCircleStub) {
  (void)cx; (void)cy; (void)radius; (void)color;
}

GFX_DRAW_LINE(DrawLineStub) {
  (void)x1; (void)y1; (void)x2; (void)y2; (void)color;
}

// Function pointers
gfx_draw_rect *DrawRect_ = DrawRectStub;
gfx_draw_circle *DrawCircle_ = DrawCircleStub;
gfx_draw_line *DrawLine_ = DrawLineStub;

#define DrawRect DrawRect_
#define DrawCircle DrawCircle_
#define DrawLine DrawLine_
```

**Benefits:**

1. Change `color` type (u32_t ‚Üí struct) in ONE place
2. Add new parameter (int layer) in ONE place
3. Compiler catches signature mismatches

---

### Exercise 5: Debug Macro Expansion Issues

**Broken macro:**

```c
#define BAD_MACRO(name) int name(int x) return x * 2;
//                                       ^--- Missing semicolon!

BAD_MACRO(MyFunc) {
  // What happens here?
}
```

**Compile and observe error:**

```bash
gcc -c broken_macro.c
```

**Error:**

```
error: expected ';' before '{' token
```

**Why?**

- Macro expands to: `int MyFunc(int x) return x * 2; { ... }`
- Missing function body braces!

**Fix:**

```c
#define GOOD_MACRO(name) int name(int x)
//                                       ^--- No body!

GOOD_MACRO(MyFunc) {
  return x * 2;  // Body provided by user
}
```

---

## üéì Comprehension Check

**Before finishing Unit 1, answer these:**

1. **Awareness:** Count how many times `ALSA_SND_PCM_*` macros appear in `audio.h`.

2. **Comprehension:** Why is the typedef needed? What if you removed it?

3. **Application:** Add a new ALSA function (`snd_pcm_drain`) using the macro pattern.

4. **Analysis:** What happens if stub signature doesn't match macro? Demonstrate!

5. **Synthesis:** Design a macro pattern for OpenGL functions (return types vary).

6. **Evaluation:** When would macros NOT be appropriate? (Hint: C++ templates?)

---

## üéì Unit 1 Completion Checklist

Before moving to Unit 2, verify you can:

- [ ] Explain how `dlopen()` loads a library into memory
- [ ] Describe how `dlsym()` searches the symbol table (O(n) linear search)
- [ ] Explain why stub functions prevent NULL pointer crashes
- [ ] Use Casey's macro pattern to define function pointer APIs
- [ ] Debug symbol loading failures (library not found, symbol not exported)
- [ ] Measure performance difference between dlsym() and cached pointers
- [ ] Write stubs that return appropriate error codes
- [ ] Expand macros manually to understand what compiler sees

**Self-Assessment:**

- **Confidence (0-10):** \_\_\_
- **Can modify code without breaking:** Yes / No
- **Can debug symbol loading failures:** Yes / No
- **Understand ALL lines in `audio.c:133-200`:** Yes / No

---

## üîó Connection to Unit 2

**Unit 2: ALSA Architecture**

- You now understand HOW we load ALSA (dlopen/dlsym)
- Next: WHAT we're loading (ALSA kernel architecture)
- What IS `snd_pcm_t`? What does "PCM" mean?
- Where does audio data go after `snd_pcm_writei()`?

---

## üìù Final Reflection (Write in UNITS-TRACKER.md)

### Update Unit 1 Status:

```markdown
## Unit 1: Dynamic Library Loading [COMPLETED] ‚úÖ

**Status:** üü¢ Completed
**Target Competence:** Level 3 (Can modify)
**Achieved:** Level \_\_\_ (fill in)

### Lessons

- [x] L1.1: Dynamic Linker Basics
- [x] L1.2: Symbol Tables & Resolution
- [x] L1.3: Stub Functions Pattern
- [x] L1.4: Macro Pattern

### Metrics

- **Confidence:** \_\_\_/10
- **Time Spent:** \_\_\_ hours
- **Aha Moments:**
  - (Write your biggest insight)
- **Code Modified:**
  - (List what you changed in audio.c)

### Reflections

1. **Key Takeaway:** What's the ONE thing you'll remember from Unit 1?
2. **Struggled With:** What was hardest to understand?
3. **Surprised By:** What was unexpectedly simple/complex?
4. **Next Time:** What would you do differently?
```

---

**Congratulations! Unit 1 complete. Move to Unit 2 when ready!** üéâ
