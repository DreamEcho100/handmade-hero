# L6.2: PulseAudio Simple API Port

**Unit 6: Porting & Alternative Backends**  
**Estimated Time:** 60-75 minutes  
**Competence Target:** Level 5 (Synthesis - implement alternative backend)

---

## Learning Objectives

By the end of this lesson, you will:

1. **Port** your ALSA audio code to PulseAudio Simple API
2. **Measure** the complexity reduction (300 lines → 60 lines)
3. **Compare** latency between ALSA and PulseAudio
4. **Test** multi-application mixing
5. **Understand** when to choose PulseAudio over ALSA
6. **Debug** PulseAudio-specific issues

---

## Why PulseAudio Simple API?

### The Elevator Pitch

**ALSA:**
- 300+ lines of code
- Manual hardware configuration
- No mixing (exclusive access)
- Low latency (20ms)

**PulseAudio Simple:**
- ~60 lines of code
- Automatic configuration
- Built-in mixing
- Medium latency (50-80ms)

**Trade:** Complexity for convenience + latency for features.

---

## Complete Implementation

### Step 1: Create `audio_pulse.c`

```c
#include <pulse/simple.h>
#include <pulse/error.h>
#include <stdio.h>
#include <stdint.h>

typedef struct PulseAudioOutput {
  pa_simple *stream;
  int32_t samples_per_second;
  int32_t bytes_per_sample;
} PulseAudioOutput;

int PulseAudioInit(PulseAudioOutput *output, int32_t samples_per_second) {
  pa_sample_spec spec = {
    .format = PA_SAMPLE_S16LE,      // 16-bit signed little-endian
    .channels = 2,                   // Stereo
    .rate = samples_per_second       // 48000 Hz
  };
  
  pa_buffer_attr buffer_attr = {
    .maxlength = (uint32_t)-1,       // Default
    .tlength = samples_per_second * 2 * 2,  // 1 second buffer
    .prebuf = (uint32_t)-1,          // Default pre-buffering
    .minreq = (uint32_t)-1,          // Default minimum request
    .fragsize = (uint32_t)-1         // Not used for playback
  };
  
  int error;
  output->stream = pa_simple_new(
    NULL,                             // Default server
    "HandmadeGame",                   // Application name
    PA_STREAM_PLAYBACK,               // Playback stream
    NULL,                             // Default device
    "Game Audio",                     // Stream description
    &spec,                            // Sample format
    NULL,                             // Default channel map
    &buffer_attr,                     // Buffer attributes
    &error                            // Error code
  );
  
  if (!output->stream) {
    fprintf(stderr, "PulseAudio init failed: %s\n", pa_strerror(error));
    return -1;
  }
  
  output->samples_per_second = samples_per_second;
  output->bytes_per_sample = 4;  // 2 channels * 2 bytes
  
  printf("PulseAudio initialized: %d Hz, stereo, S16LE\n", samples_per_second);
  return 0;
}

void PulseAudioWrite(PulseAudioOutput *output, void *samples, int32_t sample_count) {
  int error;
  size_t bytes = sample_count * output->bytes_per_sample;
  
  if (pa_simple_write(output->stream, samples, bytes, &error) < 0) {
    fprintf(stderr, "PulseAudio write failed: %s\n", pa_strerror(error));
  }
}

void PulseAudioShutdown(PulseAudioOutput *output) {
  if (output->stream) {
    pa_simple_drain(output->stream, NULL);  // Wait for playback to finish
    pa_simple_free(output->stream);
    output->stream = NULL;
  }
}
```

**That's it! 60 lines vs 300+ for ALSA.**

---

### Step 2: Integrate into `backend.c`

**Replace your ALSA init:**
```c
// In LinuxMainLoop() or similar:
PulseAudioOutput sound_output = {};

if (PulseAudioInit(&sound_output, 48000) != 0) {
  fprintf(stderr, "Audio init failed, continuing without sound\n");
  // Continue anyway (graceful degradation)
}

while (running) {
  // Game code fills sample_buffer...
  GameOutputSound(&game_sound_output);
  
  // Write to PulseAudio
  if (sound_output.stream) {
    PulseAudioWrite(&sound_output, game_sound_output.samples, sample_count);
  }
  
  // ... rest of game loop ...
}

PulseAudioShutdown(&sound_output);
```

---

## Exercise 1: Side-by-Side Comparison

**Build both versions:**

```bash
# ALSA version
gcc backend.c audio.c -ldl -lX11 -lGL -lm -o game_alsa

# PulseAudio version
gcc backend.c audio_pulse.c -lpulse-simple -lX11 -lGL -lm -o game_pulse
```

**Run and compare:**

| Metric | ALSA | PulseAudio | Notes |
|--------|------|------------|-------|
| **Code size** | 300 lines | 60 lines | 5x reduction |
| **Init time** | ~50ms | ~200ms | PulseAudio connects to daemon |
| **Latency** | 33ms | 70ms | Measured with audio markers |
| **Mixing** | No | Yes | Try playing music while game runs |
| **Error recovery** | Manual | Automatic | PulseAudio handles underruns |

---

## Exercise 2: Test Multi-App Mixing

**ALSA (fails):**
```bash
./game_alsa &
aplay test.wav  # Error: "Device or resource busy"
```

**PulseAudio (works):**
```bash
./game_pulse &
aplay test.wav  # ✅ Plays alongside game audio
```

**Why:** PulseAudio daemon mixes all audio sources.

---

## Exercise 3: Measure Latency

**Add to audio callback:**
```c
void GameOutputSound(...) {
  static int64_t sample_index = 0;
  static struct timespec last_time;
  
  struct timespec now;
  clock_gettime(CLOCK_MONOTONIC, &now);
  
  if (sample_index > 0) {
    int64_t elapsed_ns = (now.tv_sec - last_time.tv_sec) * 1000000000LL +
                         (now.tv_nsec - last_time.tv_nsec);
    int64_t expected_ns = (sample_count * 1000000000LL) / samples_per_second;
    int64_t latency_ns = elapsed_ns - expected_ns;
    
    if (sample_index % (60 * samples_per_second / sample_count) == 0) {  // Every second
      printf("Latency: %.1f ms\n", latency_ns / 1000000.0);
    }
  }
  
  last_time = now;
  sample_index += sample_count;
}
```

**Expected results:**
- ALSA: 20-35ms
- PulseAudio: 50-80ms

---

## Common PulseAudio Issues

### Issue 1: High Latency (> 200ms)

**Cause:** Default buffer too large.

**Fix:** Reduce `tlength`:
```c
pa_buffer_attr buffer_attr = {
  .tlength = samples_per_second * 2 * 2 / 10,  // 100ms buffer (was 1 second)
  // ...
};
```

---

### Issue 2: Audio Stuttering

**Cause:** `tlength` too small (underruns).

**Check:** PulseAudio logs:
```bash
pactl list sinks | grep -A 10 "State: RUNNING"
```

**Fix:** Increase buffer:
```c
.tlength = samples_per_second * 2 * 2 / 4,  // 250ms buffer
```

---

### Issue 3: "Connection refused"

**Cause:** PulseAudio daemon not running.

**Fix:**
```bash
systemctl --user start pulseaudio
```

Or check if it's running:
```bash
pactl info
```

---

## Key Differences from ALSA

| Feature | ALSA | PulseAudio |
|---------|------|------------|
| **Hardware params** | Manual (`snd_pcm_hw_params`) | Automatic |
| **Buffer size** | Must calculate | Hints only |
| **Underrun recovery** | Manual (`snd_pcm_recover`) | Automatic |
| **Error handling** | Return codes | Callback + error code |
| **Latency control** | High precision | Coarse hints |
| **Mixing** | No (dmix plugin needed) | Yes (built-in) |

---

## When to Use PulseAudio

**✅ Use PulseAudio for:**
- Desktop applications (not embedded)
- Latency < 100ms acceptable
- Need multi-app mixing
- Want simple code

**❌ Don't use PulseAudio for:**
- Embedded Linux (no daemon)
- Real-time audio (< 20ms latency)
- Minimal dependencies
- Maximum control

---

## Self-Check Quiz

### Question 1
**How much code is PulseAudio Simple API vs ALSA?**

A) Same complexity  
B) 2x simpler  
C) 5x simpler  
D) 10x simpler  

<details>
<summary>Answer</summary>

**C) 5x simpler**

- ALSA: ~300 lines (init, config, error handling)
- PulseAudio: ~60 lines (mostly boilerplate)
</details>

---

### Question 2
**What is PulseAudio's typical latency?**

A) 5ms  
B) 20ms  
C) 50-80ms  
D) 500ms  

<details>
<summary>Answer</summary>

**C) 50-80ms**

Higher than ALSA (20-40ms) due to daemon overhead.
</details>

---

### Question 3
**Can PulseAudio and ALSA run simultaneously?**

A) No, they conflict  
B) Yes, PulseAudio uses ALSA underneath  
C) Only with special configuration  
D) Only on modern kernels  

<details>
<summary>Answer</summary>

**B) Yes, PulseAudio uses ALSA underneath**

PulseAudio is a layer **on top of** ALSA, not a replacement.
</details>

---

## Key Takeaways

### PulseAudio Simple API Pattern

```c
// 1. Define spec
pa_sample_spec spec = { .format = PA_SAMPLE_S16LE, .channels = 2, .rate = 48000 };

// 2. Create stream
pa_simple *s = pa_simple_new(NULL, "App", PA_STREAM_PLAYBACK, NULL, "audio", &spec, NULL, NULL, NULL);

// 3. Write samples
pa_simple_write(s, samples, bytes, NULL);

// 4. Cleanup
pa_simple_free(s);
```

**4 function calls vs 20+ for ALSA!**

---

## Next Lesson Preview

**L6.3: Web Audio API Port**
- Port to browser using Emscripten
- JavaScript interop
- AudioWorklet for low latency
- Cross-platform web game!

---

**Estimated Completion Time:** 60-75 minutes  
**Difficulty:** ⭐⭐⭐☆☆ (Medium)  
**Competence Level Achieved:** 5/6 (Synthesis)

**Progress:** Unit 6 is 40% complete! (2/5 lessons done)

