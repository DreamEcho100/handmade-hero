# L6.1: Audio Backend Comparison Matrix

**Unit 6: Porting & Alternative Backends**  
**Estimated Time:** 60-75 minutes  
**Competence Target:** Level 5 (Synthesis - choose backends wisely)

---

## Learning Objectives

By the end of this lesson, you will:

1. **Compare** 6 audio backends across 10 criteria
2. **Justify** backend choices for different platforms
3. **Understand** latency vs complexity tradeoffs
4. **Evaluate** when to use ALSA vs PulseAudio vs others
5. **Design** multi-platform audio abstraction layers
6. **Predict** portability challenges before coding

---

## The Landscape: Audio APIs Across Platforms

### 6 Major Backends

| Backend | Platform | Year | Popularity | Your Code Uses |
|---------|----------|------|------------|----------------|
| **ALSA** | Linux | 2002 | Medium | ✅ Yes |
| **PulseAudio** | Linux | 2004 | High | ❌ No |
| **JACK** | Linux/Mac | 2001 | Low (pro audio) | ❌ No |
| **CoreAudio** | macOS/iOS | 2002 | High (Apple only) | ❌ No |
| **WASAPI** | Windows | 2007 | Medium (modern) | ❌ No |
| **Web Audio** | Browser | 2011 | High (web apps) | ❌ No |

**Bonus:** DirectSound (Windows, deprecated), OpenSL ES (Android), AAudio (Android modern)

---

## Comparison Matrix

### Criterion 1: Latency (Lower is Better)

| Backend | Typical Latency | Best Case | Notes |
|---------|----------------|-----------|-------|
| **ALSA** | 20-40 ms | 5 ms | Direct kernel access |
| **PulseAudio** | 50-100 ms | 20 ms | Extra mixing layer |
| **JACK** | 5-10 ms | 1.5 ms | Real-time optimized |
| **CoreAudio** | 10-20 ms | 3 ms | Apple hardware tuned |
| **WASAPI (Exclusive)** | 10-20 ms | 3 ms | Bypasses Windows mixer |
| **Web Audio** | 20-100 ms | 10 ms | Browser overhead |

**Your ALSA config:**
```c
int32_t latency_sample_count = game_update_hz * 2;  // 33 ms @ 60 FPS
```

**Analysis:** Your 33ms is **acceptable for games**, but **not for music production** (needs < 10ms).

---

### Criterion 2: API Complexity (Simpler is Better)

| Backend | Complexity | Lines to Play Sine Wave |
|---------|-----------|-------------------------|
| **PulseAudio (Simple)** | ⭐☆☆☆☆ | ~20 lines |
| **Web Audio** | ⭐⭐☆☆☆ | ~15 lines (JS) |
| **CoreAudio (AudioQueue)** | ⭐⭐⭐☆☆ | ~50 lines |
| **ALSA** | ⭐⭐⭐⭐☆ | ~100 lines |
| **WASAPI** | ⭐⭐⭐⭐☆ | ~150 lines (COM boilerplate) |
| **JACK** | ⭐⭐⭐⭐⭐ | ~80 lines + daemon setup |

**Your ALSA code:** ~300 lines (`audio.c` init + write + debug)

**Why so complex?**
- Dynamic library loading (`dlopen`)
- Hardware parameter configuration
- Error handling (underrun recovery)
- Debug visualization

---

### Criterion 3: Portability

| Backend | Platforms | Cross-Platform? |
|---------|-----------|----------------|
| **ALSA** | Linux only | ❌ No |
| **PulseAudio** | Linux, FreeBSD | ❌ Mostly Linux |
| **JACK** | Linux, macOS, Windows (hack) | ⚠️ Limited |
| **CoreAudio** | macOS, iOS | ❌ Apple only |
| **WASAPI** | Windows Vista+ | ❌ Windows only |
| **Web Audio** | All (via browser) | ✅ Yes (web apps only) |

**Conclusion:** No single native API works everywhere!

**Solution:** Abstraction layer (like SDL2, OpenAL, or your own).

---

### Criterion 4: Mixing (Can Multiple Apps Play Audio?)

| Backend | Multi-App Mixing | Notes |
|---------|-----------------|-------|
| **ALSA** | ❌ No (exclusive by default) | Use `dmix` plugin |
| **PulseAudio** | ✅ Yes (built-in) | Why it replaced ALSA |
| **JACK** | ✅ Yes | Pro-level routing |
| **CoreAudio** | ✅ Yes | System-wide mixer |
| **WASAPI (Shared)** | ✅ Yes | Default mode |
| **Web Audio** | ✅ Yes | Browser manages |

**Your experience:**
- If you hear "Device or resource busy" → ALSA exclusive mode
- If PulseAudio is running → It wraps ALSA and provides mixing

---

### Criterion 5: Sample Format Flexibility

| Backend | Formats Supported | Your Code Uses |
|---------|------------------|---------------|
| **ALSA** | Any (U8, S16, S24, S32, F32) | S16_LE |
| **PulseAudio** | Same as ALSA | S16_LE |
| **JACK** | F32 only | N/A |
| **CoreAudio** | Many (prefers F32) | N/A |
| **WASAPI** | Many (S16, F32) | N/A |
| **Web Audio** | F32 only | N/A |

**Trend:** Modern APIs prefer **float32** (easier mixing, no clipping).

**Your choice:** `int16_t` is **fine for games** (less memory, easier debugging).

---

### Criterion 6: Dynamic Library Loading

| Backend | Requires dlopen? | Link Directly? |
|---------|-----------------|---------------|
| **ALSA** | Optional | ✅ Yes (libasound.so) |
| **PulseAudio** | Optional | ✅ Yes (libpulse-simple.so) |
| **JACK** | Recommended | ✅ Yes (libjack.so) |
| **CoreAudio** | No | ✅ Yes (AudioToolbox framework) |
| **WASAPI** | No | ✅ Yes (Winmm.lib) |
| **Web Audio** | No (JS API) | N/A |

**Why you used dlopen:**
- Avoid hard dependency on ALSA
- Graceful fallback if library missing
- Casey's philosophy: "Don't crash if audio unavailable"

---

### Criterion 7: Documentation Quality

| Backend | Docs Rating | Learning Curve |
|---------|------------|---------------|
| **Web Audio** | ⭐⭐⭐⭐⭐ | Easy (MDN docs) |
| **CoreAudio** | ⭐⭐⭐⭐☆ | Medium (Apple docs) |
| **PulseAudio** | ⭐⭐⭐☆☆ | Easy (simple API) |
| **ALSA** | ⭐⭐☆☆☆ | Hard (scattered docs) |
| **WASAPI** | ⭐⭐☆☆☆ | Hard (MSDN sprawl) |
| **JACK** | ⭐⭐☆☆☆ | Hard (niche community) |

**Your experience:** You likely cargo-culted ALSA code from online examples!

---

### Criterion 8: Installation Complexity

| Backend | User Install | Developer Install |
|---------|--------------|------------------|
| **ALSA** | Pre-installed (Linux) | `apt install libasound2-dev` |
| **PulseAudio** | Pre-installed (most distros) | `apt install libpulse-dev` |
| **JACK** | User must install | `apt install libjack-jackd2-dev` |
| **CoreAudio** | Pre-installed (macOS) | Xcode |
| **WASAPI** | Pre-installed (Windows) | Windows SDK |
| **Web Audio** | Browser only | None |

**Distribution:** ALSA is **safest** — always present on Linux.

---

### Criterion 9: Debugging Tools

| Backend | Tools Available | Your Code Supports |
|---------|----------------|-------------------|
| **ALSA** | `aplay`, `arecord`, `speaker-test` | ⚠️ Limited |
| **PulseAudio** | `pactl`, `pavucontrol` (GUI) | ❌ No |
| **JACK** | `qjackctl` (GUI), `jack_lsp` | ❌ No |
| **CoreAudio** | Audio MIDI Setup | ❌ No |
| **WASAPI** | Windows Sound settings | ❌ No |
| **Web Audio** | Chrome DevTools (visualizer) | ❌ No |

**Your debug approach:** Custom markers in `audio.c` (L4.5 lesson).

---

### Criterion 10: Real-Time Safety

| Backend | Real-Time Safe? | Notes |
|---------|----------------|-------|
| **JACK** | ✅ Yes | Designed for pro audio |
| **ALSA (direct)** | ✅ Yes | If configured properly |
| **CoreAudio (AudioUnit)** | ✅ Yes | Low-latency path |
| **WASAPI (Exclusive)** | ✅ Yes | Bypasses mixer |
| **PulseAudio** | ⚠️ Maybe | Extra latency from daemon |
| **Web Audio** | ⚠️ Maybe | Browser scheduling |

**Real-time safe:** No malloc, no locks, no syscalls in audio callback.

**Your code:** Violates this (uses `SndPcmWritei` = syscall). OK for games, bad for pro audio.

---

## Decision Matrix: Which Backend to Use?

### Use ALSA When:
- ✅ Target: Linux only
- ✅ Need: Low latency (< 20ms)
- ✅ OK with: Complex setup
- ✅ Example: Embedded Linux device, game

**Your project fits this!**

---

### Use PulseAudio When:
- ✅ Target: Desktop Linux
- ✅ Need: Simple API + mixing
- ✅ OK with: Higher latency (50ms)
- ✅ Example: Desktop app, multimedia player

---

### Use JACK When:
- ✅ Target: Music production
- ✅ Need: < 10ms latency
- ✅ OK with: User must install daemon
- ✅ Example: DAW, live audio processing

---

### Use CoreAudio When:
- ✅ Target: macOS/iOS only
- ✅ Need: Best Apple hardware support
- ✅ Example: Native iOS app

---

### Use WASAPI When:
- ✅ Target: Windows 7+
- ✅ Need: Modern Windows API
- ✅ Better than: DirectSound (deprecated)
- ✅ Example: Windows-only game

---

### Use Web Audio When:
- ✅ Target: Cross-platform web app
- ✅ Need: Zero install
- ✅ OK with: Browser-only
- ✅ Example: Browser game, music visualizer

---

## Exercise 1: Score Your Project's Needs

**Fill this out for your game:**

| Criterion | Weight (1-5) | ALSA Score | PulseAudio Score | Web Audio Score |
|-----------|-------------|-----------|-----------------|----------------|
| Low latency | 4 | 5 | 3 | 3 |
| Simplicity | 2 | 2 | 4 | 5 |
| Portability | 1 | 2 | 2 | 5 |
| Mixing | 3 | 2 | 5 | 5 |
| Debugging | 2 | 3 | 4 | 5 |
| **Total** | | **44** | **52** | **62** |

**Calculation:** `Sum(Weight × Score)` for each backend.

**Interpretation:**
- If game is Linux-only → ALSA wins
- If desktop app → PulseAudio wins
- If web app → Web Audio wins

---

## Exercise 2: Architectural Abstraction

**Goal:** Design a header that can swap backends.

**Create `platform_audio.h`:**
```c
#ifndef PLATFORM_AUDIO_H
#define PLATFORM_AUDIO_H

#include <stdint.h>

typedef struct PlatformAudioConfig {
  int32_t samples_per_second;
  int32_t channels;
  int32_t buffer_size_samples;
} PlatformAudioConfig;

typedef struct PlatformAudioHandle {
  void *backend_specific;  // ALSA: snd_pcm_t*, PulseAudio: pa_simple*
  int32_t samples_per_second;
} PlatformAudioHandle;

// Platform-agnostic API:
int PlatformAudioInit(PlatformAudioHandle *audio, PlatformAudioConfig config);
int PlatformAudioWrite(PlatformAudioHandle *audio, int16_t *samples, int32_t sample_count);
void PlatformAudioShutdown(PlatformAudioHandle *audio);

#endif
```

**Implementation for ALSA (`platform_audio_alsa.c`):**
```c
#include "platform_audio.h"
#include <alsa/asoundlib.h>

int PlatformAudioInit(PlatformAudioHandle *audio, PlatformAudioConfig config) {
  snd_pcm_t *handle;
  int err = snd_pcm_open(&handle, "default", SND_PCM_STREAM_PLAYBACK, 0);
  if (err < 0) return -1;
  
  // ... setup hw_params ...
  
  audio->backend_specific = handle;
  audio->samples_per_second = config.samples_per_second;
  return 0;
}

int PlatformAudioWrite(PlatformAudioHandle *audio, int16_t *samples, int32_t sample_count) {
  snd_pcm_t *handle = (snd_pcm_t *)audio->backend_specific;
  snd_pcm_sframes_t frames = snd_pcm_writei(handle, samples, sample_count);
  return (frames == sample_count) ? 0 : -1;
}
```

**Implementation for PulseAudio (`platform_audio_pulse.c`):**
```c
#include "platform_audio.h"
#include <pulse/simple.h>

int PlatformAudioInit(PlatformAudioHandle *audio, PlatformAudioConfig config) {
  pa_simple *s;
  pa_sample_spec ss = {
    .format = PA_SAMPLE_S16LE,
    .channels = config.channels,
    .rate = config.samples_per_second
  };
  
  s = pa_simple_new(NULL, "MyGame", PA_STREAM_PLAYBACK, NULL, "audio", &ss, NULL, NULL, NULL);
  if (!s) return -1;
  
  audio->backend_specific = s;
  return 0;
}

int PlatformAudioWrite(PlatformAudioHandle *audio, int16_t *samples, int32_t sample_count) {
  pa_simple *s = (pa_simple *)audio->backend_specific;
  int err = pa_simple_write(s, samples, sample_count * 4, NULL);
  return err;
}
```

**Build system switches backend:**
```bash
# Build for ALSA:
gcc backend.c platform_audio_alsa.c -lasound -o game

# Build for PulseAudio:
gcc backend.c platform_audio_pulse.c -lpulse-simple -o game
```

---

## Self-Check Quiz

### Question 1
**Which backend has the lowest possible latency?**

A) ALSA  
B) PulseAudio  
C) JACK  
D) Web Audio  

<details>
<summary>Answer</summary>

**C) JACK**

Best case: 1.5ms (with real-time kernel + proper config).

ALSA can achieve ~5ms, but JACK is designed for pro audio.
</details>

---

### Question 2
**Why does PulseAudio have higher latency than ALSA?**

A) It's poorly coded  
B) Extra mixing layer (daemon)  
C) Uses network protocol  
D) Limited by hardware  

<details>
<summary>Answer</summary>

**B) Extra mixing layer**

PulseAudio sits **on top of ALSA**, adding:
- Daemon process (pulseaudio)
- Inter-process communication
- Software mixing

This adds 20-50ms compared to direct ALSA access.
</details>

---

### Question 3
**Which backend is truly cross-platform (native code)?**

A) ALSA  
B) CoreAudio  
C) None of them  
D) Web Audio (via Emscripten)  

<details>
<summary>Answer</summary>

**C) None of them**

All native backends are platform-specific:
- ALSA: Linux
- CoreAudio: macOS/iOS
- WASAPI: Windows

**Web Audio** is cross-platform but requires browser (not native).

**Solution:** Abstraction layer or use SDL2/OpenAL.
</details>

---

### Question 4
**If your game must support Linux + Windows + macOS, what's the best approach?**

A) Write ALSA + WASAPI + CoreAudio backends  
B) Use OpenAL or SDL2  
C) Use Web Audio (compile to WebAssembly)  
D) Abandon audio support  

<details>
<summary>Answer</summary>

**B) Use OpenAL or SDL2**

These libraries provide **cross-platform abstraction**:
- SDL2: Wraps ALSA, CoreAudio, WASAPI
- OpenAL: 3D audio API (uses SDL2 or platform APIs)

You write once, library handles platform differences.
</details>

---

### Question 5
**Why use `dlopen()` for ALSA instead of linking directly?**

A) It's faster  
B) Avoid hard dependency (graceful fallback)  
C) Required by ALSA  
D) Better performance  

<details>
<summary>Answer</summary>

**B) Avoid hard dependency**

If libasound.so is missing:
- **Direct link:** Program crashes on startup
- **dlopen:** Program runs, audio just doesn't work

Casey's philosophy: "Degrade gracefully, don't crash."
</details>

---

## Key Takeaways

### Backend Selection Flowchart

```
Need cross-platform?
├─ Yes → Use SDL2/OpenAL or Web Audio
└─ No (single platform)
    ├─ Linux only?
    │   ├─ Low latency? → ALSA
    │   └─ Simple API? → PulseAudio
    ├─ macOS only? → CoreAudio
    ├─ Windows only? → WASAPI
    └─ Pro audio? → JACK
```

---

### Latency Hierarchy (Lower is Better)

```
JACK (1.5ms) < ALSA (5ms) < CoreAudio (10ms) < WASAPI (10ms) < PulseAudio (50ms) < Web Audio (20-100ms)
```

---

### Complexity Hierarchy (Simpler is Better)

```
PulseAudio (20 lines) < Web Audio (15 lines JS) < ALSA (100 lines) < WASAPI (150 lines)
```

---

## Connection to Other Lessons

**Prerequisites:**
- L5.1: Platform API Design (abstraction principles)
- L2.3: ALSA Initialization (understand one backend deeply)

**Enables:**
- L6.2: PulseAudio Port (implement alternative)
- L6.3: Web Audio Port (browser target)
- L6.4: Tradeoff Analysis (evaluate choices)

---

## Next Lesson Preview

**L6.2: PulseAudio Simple API Port**
- Rewrite your audio code using PulseAudio
- Compare code complexity (ALSA vs PulseAudio)
- Measure latency difference
- Test multi-app mixing

**Spoiler:** PulseAudio version is **5x shorter** than ALSA!

---

**Estimated Completion Time:** 60-75 minutes  
**Difficulty:** ⭐⭐⭐☆☆ (Medium)  
**Competence Level Achieved:** 5/6 (Synthesis)

---

**Progress:** Unit 6 is 20% complete! (1/5 lessons done)

