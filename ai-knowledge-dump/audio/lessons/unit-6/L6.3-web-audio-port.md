# L6.3: Web Audio API Port - Browser Game Audio

**Unit 6: Porting & Alternative Backends**  
**Estimated Time:** 75-90 minutes  
**Competence Target:** Level 5 (Synthesis - cross-platform implementation)

---

## Learning Objectives

By the end of this lesson, you will:

1. **Port** your audio system to Web Audio API (JavaScript)
2. **Understand** the callback vs push model difference
3. **Implement** C to JavaScript interop (Emscripten)
4. **Compare** Web Audio latency to native audio
5. **Use** AudioWorklet for low-latency synthesis
6. **Deploy** your game to run in a browser

---

## Paradigm Shift: Callback vs Push

### Your Current Model (ALSA/PulseAudio): PUSH

```c
while (running) {
  // Game generates audio
  FillAudioBuffer(samples, sample_count);
  
  // Push to audio device
  snd_pcm_writei(handle, samples, sample_count);  // ← PUSH
}
```

**Game controls when audio is generated.**

---

### Web Audio Model: CALLBACK (Pull)

```javascript
// Audio context calls YOU when it needs data
const audioContext = new AudioContext();
const scriptNode = audioContext.createScriptProcessor(4096, 0, 2);

scriptNode.onaudioprocess = (event) => {
  // ← Audio system PULLS data from you
  const outputL = event.outputBuffer.getChannelData(0);
  const outputR = event.outputBuffer.getChannelData(1);
  
  for (let i = 0; i < outputL.length; i++) {
    outputL[i] = generateSample();  // Fill on demand
    outputR[i] = generateSample();
  }
};

scriptNode.connect(audioContext.destination);
```

**Audio context controls when you generate samples.**

---

## Approach 1: Pure JavaScript (No C)

### Minimal Web Audio Sine Wave

```html
<!DOCTYPE html>
<html>
<head><title>Web Audio Game</title></head>
<body>
  <h1>Press START to play audio</h1>
  <button id="start">START</button>
  
  <script>
    let audioContext = null;
    let scriptNode = null;
    let runningIndex = 0;
    
    document.getElementById('start').addEventListener('click', () => {
      if (!audioContext) {
        audioContext = new AudioContext();
        scriptNode = audioContext.createScriptProcessor(4096, 0, 2);
        
        scriptNode.onaudioprocess = (event) => {
          const outputL = event.outputBuffer.getChannelData(0);
          const outputR = event.outputBuffer.getChannelData(1);
          const sampleRate = audioContext.sampleRate;
          
          for (let i = 0; i < outputL.length; i++) {
            const t = runningIndex / sampleRate;
            const frequency = 440.0;  // A4
            const value = Math.sin(2.0 * Math.PI * frequency * t);
            
            outputL[i] = value * 0.3;
            outputR[i] = value * 0.3;
            
            runningIndex++;
          }
        };
        
        scriptNode.connect(audioContext.destination);
        console.log('Audio started at', sampleRate, 'Hz');
      }
    });
  </script>
</body>
</html>
```

**Save as `game.html`, open in browser, click START.**

**Result:** 440 Hz sine wave, just like your C code!

---

## Approach 2: C to JavaScript (Emscripten)

### Step 1: Install Emscripten

```bash
# Install emsdk
git clone https://github.com/emscripten-core/emsdk.git
cd emsdk
./emsdk install latest
./emsdk activate latest
source ./emsdk_env.sh
```

---

### Step 2: Create `game.c` (Simplified)

```c
#include <emscripten.h>
#include <math.h>
#include <stdio.h>

#define SAMPLE_RATE 48000
#define BUFFER_SIZE 4096

static int running_index = 0;

// Called by JavaScript when audio buffer needs filling
void EMSCRIPTEN_KEEPALIVE FillAudioBuffer(float *output, int sample_count) {
  for (int i = 0; i < sample_count; i++) {
    float t = (float)running_index / SAMPLE_RATE;
    float frequency = 440.0f;
    float value = sinf(2.0f * M_PI * frequency * t);
    
    output[i * 2 + 0] = value * 0.3f;  // Left
    output[i * 2 + 1] = value * 0.3f;  // Right
    
    running_index++;
  }
}

int main() {
  printf("Game audio module loaded\n");
  return 0;
}
```

---

### Step 3: JavaScript Glue Code

**Create `game.html`:**
```html
<!DOCTYPE html>
<html>
<head><title>Emscripten Game Audio</title></head>
<body>
  <h1>Press START</h1>
  <button id="start">START</button>
  
  <script src="game.js"></script>
  <script>
    let audioContext = null;
    let scriptNode = null;
    let audioBuffer = null;
    
    Module.onRuntimeInitialized = () => {
      console.log('C module loaded');
      
      document.getElementById('start').addEventListener('click', () => {
        if (!audioContext) {
          audioContext = new AudioContext();
          scriptNode = audioContext.createScriptProcessor(4096, 0, 2);
          
          // Allocate shared buffer (C heap)
          const bufferSize = 4096 * 2;  // Stereo
          audioBuffer = Module._malloc(bufferSize * 4);  // 4 bytes per float
          
          scriptNode.onaudioprocess = (event) => {
            const outputL = event.outputBuffer.getChannelData(0);
            const outputR = event.outputBuffer.getChannelData(1);
            
            // Call C function to fill buffer
            Module._FillAudioBuffer(audioBuffer, outputL.length);
            
            // Copy from C heap to audio buffers
            const cBuffer = new Float32Array(Module.HEAPF32.buffer, audioBuffer, outputL.length * 2);
            for (let i = 0; i < outputL.length; i++) {
              outputL[i] = cBuffer[i * 2 + 0];
              outputR[i] = cBuffer[i * 2 + 1];
            }
          };
          
          scriptNode.connect(audioContext.destination);
          console.log('Audio started');
        }
      });
    };
  </script>
</body>
</html>
```

---

### Step 4: Compile

```bash
emcc game.c \
  -s WASM=1 \
  -s EXPORTED_FUNCTIONS="['_main', '_FillAudioBuffer']" \
  -s EXPORTED_RUNTIME_METHODS="['ccall', 'cwrap']" \
  -o game.js
```

---

### Step 5: Run

```bash
# Start web server
python3 -m http.server 8000

# Open browser: http://localhost:8000/game.html
```

**Result:** Your C audio code running in browser!

---

## Approach 3: AudioWorklet (Low Latency)

### Why AudioWorklet?

**ScriptProcessor (old):**
- Runs on main thread
- High latency (100-200ms)
- Deprecated

**AudioWorklet (new):**
- Runs on audio thread
- Low latency (20-50ms)
- Recommended

---

### Implementation

**Create `audio-processor.js`:**
```javascript
class GameAudioProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    this.runningIndex = 0;
  }
  
  process(inputs, outputs, parameters) {
    const output = outputs[0];
    const outputL = output[0];
    const outputR = output[1];
    
    const sampleRate = 48000;  // Assume
    
    for (let i = 0; i < outputL.length; i++) {
      const t = this.runningIndex / sampleRate;
      const frequency = 440.0;
      const value = Math.sin(2.0 * Math.PI * frequency * t);
      
      outputL[i] = value * 0.3;
      outputR[i] = value * 0.3;
      
      this.runningIndex++;
    }
    
    return true;  // Keep processor alive
  }
}

registerProcessor('game-audio-processor', GameAudioProcessor);
```

**Main HTML:**
```html
<script>
  let audioContext = null;
  
  document.getElementById('start').addEventListener('click', async () => {
    audioContext = new AudioContext();
    
    await audioContext.audioWorklet.addModule('audio-processor.js');
    
    const processorNode = new AudioWorkletNode(audioContext, 'game-audio-processor');
    processorNode.connect(audioContext.destination);
    
    console.log('AudioWorklet started');
  });
</script>
```

**Latency:** 20-50ms (comparable to native ALSA)!

---

## Comparison Table

| Approach | Latency | Complexity | C Code Reuse |
|----------|---------|-----------|--------------|
| **Pure JavaScript** | 100-200ms | Simple | 0% |
| **Emscripten + ScriptProcessor** | 100-200ms | Medium | 80% |
| **AudioWorklet** | 20-50ms | Medium | 0% (JS only) |
| **Emscripten + AudioWorklet** | 20-50ms | Complex | 80% |

**Best for learning:** Pure JavaScript  
**Best for porting:** Emscripten + AudioWorklet

---

## Exercise: Port Your Game

**Step 1:** Extract audio generation to standalone function:
```c
void GameGenerateAudio(float *samples, int sample_count, int sample_rate) {
  // Your sine wave code here
}
```

**Step 2:** Compile with Emscripten.

**Step 3:** Call from AudioWorklet.

**Step 4:** Deploy to GitHub Pages!

---

## Common Issues

### Issue 1: "AudioContext not allowed to start"

**Cause:** Browsers require user interaction.

**Fix:** Start audio in click handler:
```javascript
button.addEventListener('click', () => {
  audioContext.resume();
});
```

---

### Issue 2: Clicks/pops in audio

**Cause:** Buffer underruns (JavaScript too slow).

**Fix:** Increase buffer size:
```javascript
createScriptProcessor(8192, 0, 2);  // Was 4096
```

---

### Issue 3: Wrong sample rate

**Cause:** AudioContext uses hardware sample rate.

**Check:**
```javascript
console.log('Sample rate:', audioContext.sampleRate);
// Might be 44100, 48000, or 96000
```

**Fix:** Use dynamic sample rate:
```javascript
const t = runningIndex / audioContext.sampleRate;
```

---

## Self-Check Quiz

### Question 1
**What's the key difference between ALSA and Web Audio?**

A) ALSA is faster  
B) ALSA is push, Web Audio is pull (callback)  
C) Web Audio doesn't support stereo  
D) No difference  

<details>
<summary>Answer</summary>

**B) ALSA is push, Web Audio is pull**

- ALSA: You call `snd_pcm_writei()` when ready
- Web Audio: It calls your `onaudioprocess` when it needs data
</details>

---

### Question 2
**What's the latency of AudioWorklet?**

A) 1-5ms  
B) 20-50ms  
C) 100-200ms  
D) 500ms+  

<details>
<summary>Answer</summary>

**B) 20-50ms**

Similar to native ALSA, much better than ScriptProcessor (100-200ms).
</details>

---

### Question 3
**Why does Web Audio require a user gesture to start?**

A) Browser limitation  
B) Security (prevent auto-playing ads)  
C) Performance  
D) It doesn't  

<details>
<summary>Answer</summary>

**B) Security**

Browsers block auto-play to prevent annoying ads. User must interact first.
</details>

---

## Key Takeaways

### Web Audio Pattern

```javascript
// 1. Create context
const ctx = new AudioContext();

// 2. Create processor
const node = ctx.createScriptProcessor(4096, 0, 2);

// 3. Fill callback
node.onaudioprocess = (e) => {
  const out = e.outputBuffer.getChannelData(0);
  // Fill out[i]...
};

// 4. Connect
node.connect(ctx.destination);
```

---

### Cross-Platform Audio Abstraction

```c
// Common interface:
void GameGenerateAudio(float *samples, int sample_count, int sample_rate);

// Platform-specific wrappers:
// - ALSA: Call from main loop, convert to int16_t
// - PulseAudio: Same
// - Web Audio: Call from AudioWorklet, use floats directly
```

---

## Next Lesson Preview

**L6.4: Architecture Tradeoff Analysis**
- When to choose each backend
- Latency vs complexity matrix
- Real-world decision framework

---

**Estimated Completion Time:** 75-90 minutes  
**Difficulty:** ⭐⭐⭐⭐☆ (Advanced)  
**Competence Level Achieved:** 5/6 (Synthesis)

**Progress:** Unit 6 is 60% complete! (3/5 lessons done)

