# L10.6: TypeScript Types for C Structs (Not Interfaces)

## Prerequisites
- Completed Lesson 5 (SharedArrayBuffer as C Struct)
- Understanding of JSDoc/TypeScript types
- Knowledge of C struct definitions

## Core Concept

Write JSDoc types that **describe memory layout**, not behavior. Types should mirror C structs exactly.

---

## Part 1: Types as Documentation, Not Abstraction

### ❌ OOP Interface Way

```typescript
interface AudioBackend {
  init(device: string): void;
  write(samples: Float32Array): number;
  shutdown(): void;
}
```

**Problem:** This describes behavior (methods), not data.

### ✅ Data-Oriented Way

```typescript
/**
 * @typedef {Object} AudioBackend
 * @property {function(string): number} init
 * @property {function(number, Float32Array, number): number} write
 * @property {function(number): void} shutdown
 */
```

**Better:** This describes a struct with function pointers.

---

## Part 2: Complete Audio System Types

### Core Structs

```typescript
// audio-structs.d.ts

/**
 * Mirrors GameSoundOutput from handmade hero
 * @typedef {Object} GameSoundOutput
 * @property {number} samples_per_second
 * @property {number} sample_count
 * @property {Float32Array} samples - Flat interleaved array
 * @property {bigint} write_cursor_sample
 */

/**
 * Platform memory block - mirrors platform.h
 * @typedef {Object} PlatformMemoryBlock
 * @property {ArrayBuffer} memory
 * @property {number} size Total allocated size
 * @property {number} used Currently used bytes
 * @property {PlatformMemoryBlock|null} next_free Linked list pointer
 */

/**
 * Ring buffer state
 * @typedef {Object} RingBufferState
 * @property {SharedArrayBuffer} buffer
 * @property {Uint32Array} read_cursor  @offset 0
 * @property {Uint32Array} write_cursor @offset 4
 * @property {Float32Array} data        @offset 8
 * @property {number} size_mask Power-of-2 mask for wrapping
 */

/**
 * Game state per frame
 * @typedef {Object} GameFrameState
 * @property {number} frame_number
 * @property {number} delta_time_ms
 * @property {number} samples_to_generate
 * @property {bigint} absolute_sample_index
 * @property {Object} metrics
 * @property {number} metrics.cpu_time_ms
 * @property {number} metrics.buffer_fill_percentage
 */
```

### Function Pointer Types

```typescript
/**
 * Callback signature - like X11 event handlers
 * @callback AudioCallback
 * @param {Float32Array} output_buffer
 * @param {number} frame_count
 * @param {GameFrameState} frame_state
 * @returns {void}
 */

/**
 * Error handler - like ALSA error callbacks
 * @callback ErrorHandler
 * @param {number} error_code
 * @param {string} error_message
 * @returns {boolean} true = retry, false = abort
 */

/**
 * Audio system configuration
 * @typedef {Object} AudioConfig
 * @property {number} sample_rate
 * @property {number} channels
 * @property {number} buffer_size_frames
 * @property {AudioCallback} fill_callback
 * @property {ErrorHandler} on_error
 */
```

---

## Part 3: Memory Layout Annotations

### Documenting Offsets

```typescript
/**
 * ALSA state struct - 32 bytes total
 * @typedef {Object} AlsaState
 * @property {Int32Array} handle       @offset 0  (4 bytes)
 * @property {Int32Array} channels     @offset 4  (4 bytes)
 * @property {Int32Array} rate         @offset 8  (4 bytes)
 * @property {Int32Array} latency_ms   @offset 12 (4 bytes)
 * @property {BigInt64Array} writeCursor @offset 16 (8 bytes, 8-byte aligned)
 * @property {BigInt64Array} runningIndex @offset 24 (8 bytes)
 */
```

### Size Constants

```typescript
/** Memory layout constants */
const ALSA_STATE_SIZE = 32;
const GAME_SOUND_OUTPUT_HEADER_SIZE = 16;

/**
 * Create buffer for AlsaState
 * @returns {SharedArrayBuffer}
 */
function allocateAlsaState() {
  return new SharedArrayBuffer(ALSA_STATE_SIZE);
}
```

---

## Part 4: Auto-Generate from C Headers

### C Header Parser

```typescript
// parse-c-header.mjs
import { readFileSync } from 'fs';

/**
 * Parse C struct to JSDoc typedef
 * @param {string} cHeaderPath
 * @returns {string} JSDoc typedef
 */
export function parseStructToJSDoc(cHeaderPath) {
  const content = readFileSync(cHeaderPath, 'utf8');
  const structMatch = content.match(/typedef struct\s+{([^}]+)}\s+(\w+);/);
  
  if (!structMatch) return '';
  
  const [, body, name] = structMatch;
  const fields = body.split(';').map(field => {
    const match = field.trim().match(/(\w+)\s+(\w+)/);
    if (!match) return null;
    const [, type, fieldName] = match;
    return { type: mapCTypeToJS(type), fieldName };
  }).filter(Boolean);
  
  let jsdoc = `/**\n * @typedef {Object} ${name}\n`;
  fields.forEach(({ type, fieldName }) => {
    jsdoc += ` * @property {${type}} ${fieldName}\n`;
  });
  jsdoc += ` */\n`;
  
  return jsdoc;
}

function mapCTypeToJS(cType) {
  const typeMap = {
    'int': 'number',
    'float': 'number',
    'double': 'number',
    'uint32_t': 'number',
    'int64_t': 'bigint',
    'void*': 'number', // Pointer as offset
    'char*': 'string'
  };
  return typeMap[cType] || 'any';
}

// Usage
const jsDoc = parseStructToJSDoc('./alsa_state.h');
console.log(jsDoc);
```

---

## Part 5: Web API Mirror - WebGL Types

### Vertex Buffer Layout

```typescript
/**
 * Vertex buffer layout - mirrors OpenGL vertex attributes
 * @typedef {Object} Vertex
 * @property {Float32Array} position @offset 0, length 3 (12 bytes)
 * @property {Float32Array} normal   @offset 12, length 3 (12 bytes)
 * @property {Float32Array} uv       @offset 24, length 2 (8 bytes)
 * @property {Uint8Array} color      @offset 32, length 4 (4 bytes)
 */

/** Total vertex size: 36 bytes */
const VERTEX_SIZE = 36;

/**
 * Create vertex buffer
 * @param {number} vertexCount
 * @returns {ArrayBuffer}
 */
function createVertexBuffer(vertexCount) {
  return new ArrayBuffer(vertexCount * VERTEX_SIZE);
}
```

---

## Self-Assessment

- [ ] Can write JSDoc types for C structs
- [ ] Understand difference between type and interface
- [ ] Can annotate memory offsets in comments
- [ ] Can auto-generate types from C headers

**Next: L10.7 - Latency Data as Array of Structs**
