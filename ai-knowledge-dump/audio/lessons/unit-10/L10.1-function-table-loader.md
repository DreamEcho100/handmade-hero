# L10.1: Dynamic Function Table Loader (The `dlsym` Rosetta Stone)

## Prerequisites
- Completed Unit 1-L1.2 (`dlsym` pattern)
- Understanding of C function pointers
- Basic JavaScript module system knowledge

## Core Concept

Build a **plain function table** that you **hot-load** at runtime—exactly like `audio.c:133-200`, but in JavaScript. This is your first step into data-oriented thinking.

---

## Part 1: Understanding the C Pattern

### In C (audio.c:133-200)

```c
// Define function pointer types
typedef int (*snd_pcm_open_t)(snd_pcm_t **, const char *, snd_pcm_stream_t, int);
typedef int (*snd_pcm_writei_t)(snd_pcm_t *, const void *, snd_pcm_uframes_t);

// Global function pointers (the "VTable")
static snd_pcm_open_t SndPcmOpen = NULL;
static snd_pcm_writei_t SndPcmWritei = NULL;

// Load the library and populate function pointers
void *handle = dlopen("libasound.so.2", RTLD_NOW);
*(void **)(&SndPcmOpen) = dlsym(handle, "snd_pcm_open");
*(void **)(&SndPcmWritei) = dlsym(handle, "snd_pcm_writei");

// Now call them like regular functions
SndPcmOpen(&pcm, "default", SND_PCM_STREAM_PLAYBACK, 0);
SndPcmWritei(pcm, buffer, frames);
```

**Key Insight:** You're not creating objects or classes. You're just loading **function addresses** into **global variables**. Then you call them.

---

## Part 2: The JavaScript Translation

### Step 1: Define the VTable Structure

```javascript
// function-table.mjs
/**
 * @typedef {Object} AudioBackendVTable
 * @property {function(string): number} init
 * @property {function(number, Float32Array, number): number} write
 * @property {function(number): {playCursor: number, writeCursor: number, delay: number}} getCursorInfo
 * @property {function(number): void} shutdown
 */

/** @type {AudioBackendVTable|null} */
let g_audioBackend = null;
```

**Why `null` and not a class?** Because in C, uninitialized function pointers are `NULL`. We mirror this exactly.

### Step 2: The `dlsym` Equivalent

```javascript
import { pathToFileURL } from 'url';

export async function loadBackend(modulePath) {
  // This is the JS version of dlopen + dlsym
  const module = await import(pathToFileURL(modulePath).href);
  
  // Populate the function table - just like dlsym
  g_audioBackend = {
    init: module.init,
    write: module.write,
    getCursorInfo: module.getCursorInfo,
    shutdown: module.shutdown
  };
}
```

**Line-by-line comparison:**

| C | JavaScript |
|---|------------|
| `dlopen("libasound.so.2", ...)` | `import(modulePath)` |
| `dlsym(handle, "snd_pcm_open")` | `module.init` |
| `*(void **)(&SndPcmOpen) = ...` | `g_audioBackend = { init: module.init, ... }` |

### Step 3: Access the Backend

```javascript
export function getBackend() {
  return g_audioBackend;
}
```

---

## Part 3: Creating a Backend (Pure Functions)

### ALSA-Style Backend

Create `backends/alsa-backend.mjs`:

```javascript
// backends/alsa-backend.mjs
// Data-oriented - NO classes, NO this

export function init(deviceName) {
  console.log(`[ALSA] Initializing: ${deviceName}`);
  return 0; // Success (would return handle in real impl)
}

export function write(handle, samples, frameCount) {
  console.log(`[ALSA] Writing ${frameCount} frames`);
  // In real impl: snd_pcm_writei(handle, samples, frameCount)
  return frameCount;
}

export function getCursorInfo(handle) {
  // In real impl: snd_pcm_avail() and snd_pcm_delay()
  return {
    playCursor: 1024,
    writeCursor: 2048,
    delay: 512
  };
}

export function shutdown(handle) {
  console.log(`[ALSA] Shutting down handle ${handle}`);
  // In real impl: snd_pcm_close(handle)
}
```

**Critical Rules:**
1. ❌ No `class AlsaBackend { ... }`
2. ❌ No `this.device` or any instance state
3. ✅ Just exported functions
4. ✅ All state passed as parameters (like C)

---

## Part 4: Using the Function Table

### Basic Usage

```javascript
import { loadBackend, getBackend } from './function-table.mjs';

// Load backend
await loadBackend('./backends/alsa-backend.mjs');

// Get function table
const backend = getBackend();

// Call functions directly - just like C!
const handle = backend.init('default');
const samples = new Float32Array(1024);
const written = backend.write(handle, samples, 1024);
const info = backend.getCursorInfo(handle);
backend.shutdown(handle);
```

**This is IDENTICAL to:**
```c
SndPcmOpen(&pcm, "default", ...);
SndPcmWritei(pcm, buffer, 1024);
```

---

## Part 5: The "Aha Moment" Test

### Proof That Functions Are Independent

```javascript
// Extract a function from the table
const initFunc = backend.init;

// Call it standalone - NO 'this' binding needed!
const result = initFunc('standalone-call');
```

**If this was a class method:**
```javascript
class AudioBackend {
  init(device) {
    this.device = device; // ERROR: 'this' is undefined!
  }
}
```

This would crash! But our function table works because **functions don't depend on `this`**.

---

## Part 6: Hot-Swapping (The Power Move)

```javascript
// Start with ALSA
await loadBackend('./backends/alsa-backend.mjs');
let backend = getBackend();
backend.init('alsa-device');

// Hot-swap to Web Audio - NO restart needed!
await loadBackend('./backends/webaudio-backend.mjs');
backend = getBackend();
backend.init('webaudio-device');
```

**Why this is powerful:**
- No `instanceof` checks
- No inheritance hierarchies
- Just swap the function pointers
- Exactly like Casey's platform layer

---

## Part 7: Creative Challenge - Cartridge System

### Retro Game Console Emulator

```javascript
// cartridge-system.mjs
/**
 * @typedef {Object} CartridgeVTable
 * @property {function(): void} onLoad
 * @property {function(Float32Array): void} fillAudioBuffer
 * @property {function(): void} onEject
 */

const cartridgeSlot = {
  current: null,
  swap(newCartridge) {
    if (this.current) this.current.onEject();
    this.current = newCartridge;
    this.current.onLoad();
  }
};

export function createCartridge(gameName, audioFillFunc) {
  return {
    onLoad() {
      console.log(`[Cartridge] Loading: ${gameName}`);
    },
    fillAudioBuffer(buffer) {
      audioFillFunc(buffer);
    },
    onEject() {
      console.log(`[Cartridge] Ejecting: ${gameName}`);
    }
  };
}
```

### Using Cartridges

```javascript
const sineWave = createCartridge('Sine Wave Game', (buffer) => {
  for (let i = 0; i < buffer.length; i++) {
    buffer[i] = Math.sin(i * 0.01);
  }
});

const squareWave = createCartridge('Square Wave Game', (buffer) => {
  for (let i = 0; i < buffer.length; i++) {
    buffer[i] = (i % 100 < 50) ? 1.0 : -1.0;
  }
});

// Swap cartridges like an NES!
swapCartridge(sineWave);
swapCartridge(squareWave);
```

---

## Exercises

### Exercise 1: Add a Mock Backend

Create `backends/mock-backend.mjs` that simulates errors:

```javascript
export function init(deviceName) {
  return -1; // Simulate failure
}

export function write(handle, samples, frameCount) {
  throw new Error('Simulated write error');
}
```

### Exercise 2: Multi-Backend Fallback

```javascript
const backends = [
  './backends/alsa-backend.mjs',
  './backends/pulseaudio-backend.mjs',
  './backends/webaudio-backend.mjs'
];

for (const path of backends) {
  await loadBackend(path);
  const backend = getBackend();
  const handle = backend.init('default');
  if (handle >= 0) {
    console.log(`Success with ${path}`);
    break;
  }
}
```

### Exercise 3: Timing Wrapper

Add performance measurements without changing backends:

```javascript
function wrapWithTiming(backend) {
  return {
    init: (device) => {
      const start = performance.now();
      const result = backend.init(device);
      console.log(`init took ${performance.now() - start}ms`);
      return result;
    },
    // ... wrap other functions
  };
}
```

---

## Key Takeaways

### What You Learned

1. **Function tables are just data** - you can swap, wrap, or transform them
2. **No `this` means no hidden dependencies** - all state is explicit
3. **Hot-swapping is trivial** - just reassign the global
4. **This is how Casey designs platform layers** - pure functions, no OOP

### Connects To

- **Unit 1-L1.2**: The original `dlsym` pattern in `audio.c`
- **Unit 1-L1.4**: Macro redirection (another way to swap implementations)
- **Unit 5-L5.1**: Platform API design philosophy

### Enables

- **Lesson 2**: Ring buffers (also no classes, just functions on data)
- **Lesson 4**: Hot-reloadable backends for debugging
- **Lesson 8**: Error simulation by swapping mock VTables

---

## Self-Assessment

You understand this lesson when you can:

- [ ] Explain why `g_audioBackend.write()` is the same as `(*SndPcmWritei)(...)`
- [ ] Hot-swap backends without restarting your program
- [ ] Extract a function from the table and call it standalone
- [ ] Articulate why this is different from `class AudioBackend extends ...`
- [ ] Debug function table issues by inspecting the object structure

---

## Next Lesson

**L10.2: Ring Buffer as Raw TypedArray** - Apply the same "no classes, just data" philosophy to ring buffers using `SharedArrayBuffer`.
