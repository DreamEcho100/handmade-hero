# L10.3: Frame Timing as Pure Data Transform

## Prerequisites
- Completed Unit 3-L3.1 (Game Loop Anatomy)
- Understanding of generator functions in JavaScript
- Knowledge of `backend.c:423-899` frame timing logic

## Core Concept

Simulate your **game loop** as a **generator function that yields plain structs**—no game state object, just immutable data per frame.

---

## Part 1: The C Pattern

### Handmade Hero Game Loop (backend.c)

```c
while (running) {
    int64_t target_samples = (int64_t)(sound_output.samples_per_second / game_update_hz);
    
    game_sound_output sound_buffer = {};
    sound_buffer.samples_per_second = sound_output.samples_per_second;
    sound_buffer.sample_count = target_samples;
    sound_buffer.samples = samples;
    
    // Game logic fills buffer
    GameUpdateAndRender(&game_memory, input, &sound_buffer, &back_buffer);
    
    // Write to audio
    PlatformFillSoundBuffer(&sound_output, &sound_buffer);
    
    running_sample_index += target_samples;
}
```

**Key Insight:** Each frame is a **struct of data**—you don't mutate global state, you pass fresh structs.

---

## Part 2: Generator-Based Game Loop

### Step 1: Define Frame Data Structure

```javascript
// game-loop-data.mjs
/**
 * @typedef {Object} GameFrame
 * @property {number} frameNumber
 * @property {number} deltaTimeMs Exact frame time
 * @property {number} targetFps
 * @property {number} samplesToWrite Derived from targetFps
 * @property {number} writeCursor Current sample write position
 * @property {Object} performanceMetrics
 * @property {number} performanceMetrics.cpuTime
 * @property {number} performanceMetrics.bufferAvailable
 */
```

### Step 2: Generator Function (Not a Class)

```javascript
/**
 * Generator-based game loop - mirrors backend.c:423-899
 * @param {number} targetFps
 * @generator
 * @yields {GameFrame}
 * @returns {Generator<GameFrame, void, number>}
 */
export function* gameLoopSimulator(targetFps) {
  let runningSampleIndex = 0;
  let frameNumber = 0;
  const sampleRate = 48000;
  
  while (true) {
    const samplesThisFrame = Math.floor(sampleRate / targetFps);
    
    const frame = {
      frameNumber,
      deltaTimeMs: 1000 / targetFps,
      targetFps,
      samplesToWrite: samplesThisFrame,
      writeCursor: runningSampleIndex,
      performanceMetrics: {
        cpuTime: 0,
        bufferAvailable: 0
      }
    };
    
    // Yield frame, receive actual delta from caller
    const actualDeltaTime = yield frame;
    
    runningSampleIndex += samplesThisFrame;
    frameNumber++;
  }
}
```

### Step 3: Using the Generator

```javascript
const loop = gameLoopSimulator(60);
let frame = loop.next().value;

while (playing) {
  const startTime = performance.now();
  
  // Simulate game logic
  updatePlayer(frame);
  updateEnemies(frame);
  
  // Fill audio buffer based on frame
  const audioData = new Float32Array(frame.samplesToWrite);
  generateAudio(audioData, frame.writeCursor);
  
  // Measure performance
  frame.performanceMetrics.cpuTime = performance.now() - startTime;
  
  // Get next frame with actual measured delta
  const actualDelta = performance.now() - startTime;
  frame = loop.next(actualDelta).value;
}
```

---

## Part 3: Data-Oriented Principle

### ❌ OOP Way (Stateful)

```javascript
class GameLoop {
  constructor() {
    this.frameNumber = 0;
    this.runningSampleIndex = 0;
  }
  
  nextFrame() {
    this.frameNumber++;
    this.runningSampleIndex += this.samplesThisFrame;
    return this.createFrame(); // Returns mutated state
  }
}
```

### ✅ Data-Oriented Way (Pure)

```javascript
function* gameLoopSimulator(targetFps) {
  let runningSampleIndex = 0; // Hidden in closure
  
  while (true) {
    const frame = { /* fresh immutable struct */ };
    yield frame; // Pure data out
    runningSampleIndex += samplesThisFrame; // Update internal state
  }
}
```

**The generator encapsulates mutation, but yields immutable data.**

---

## Part 4: Frame Time Distribution Analyzer

### Collecting Frame Stats

```javascript
/**
 * @typedef {Object} FrameStats
 * @property {number[]} deltaTimes
 * @property {number} avgDelta
 * @property {number} minDelta
 * @property {number} maxDelta
 * @property {number} stdDev
 */

/**
 * Analyze frame timing - mirrors perf tool (Unit 8-L8.1)
 * @param {GameFrame[]} frames
 * @returns {FrameStats}
 */
export function analyzeFrameTiming(frames) {
  const deltaTimes = frames.map(f => f.deltaTimeMs);
  const sum = deltaTimes.reduce((a, b) => a + b, 0);
  const avg = sum / deltaTimes.length;
  
  const variance = deltaTimes
    .map(dt => Math.pow(dt - avg, 2))
    .reduce((a, b) => a + b, 0) / deltaTimes.length;
  
  return {
    deltaTimes,
    avgDelta: avg,
    minDelta: Math.min(...deltaTimes),
    maxDelta: Math.max(...deltaTimes),
    stdDev: Math.sqrt(variance)
  };
}
```

### Histogram Visualization

```javascript
/**
 * Render histogram to canvas
 * @param {FrameStats} stats
 * @param {CanvasRenderingContext2D} ctx
 */
export function renderHistogram(stats, ctx) {
  const buckets = new Array(60).fill(0);
  const bucketSize = (stats.maxDelta - stats.minDelta) / buckets.length;
  
  stats.deltaTimes.forEach(dt => {
    const bucket = Math.floor((dt - stats.minDelta) / bucketSize);
    buckets[Math.min(bucket, buckets.length - 1)]++;
  });
  
  const maxCount = Math.max(...buckets);
  const width = ctx.canvas.width;
  const height = ctx.canvas.height;
  
  ctx.clearRect(0, 0, width, height);
  
  buckets.forEach((count, i) => {
    const barHeight = (count / maxCount) * height;
    const x = (i / buckets.length) * width;
    const barWidth = width / buckets.length;
    
    ctx.fillStyle = '#0f0';
    ctx.fillRect(x, height - barHeight, barWidth, barHeight);
  });
}
```

---

## Part 5: Web API Mirror - requestAnimationFrame Logger

### Simple Frame Logger

```javascript
const frames = [];
let lastTimestamp = 0;

function logFrame(timestamp) {
  const deltaTime = timestamp - lastTimestamp;
  
  frames.push({
    timestamp,
    deltaTime,
    fps: deltaTime > 0 ? 1000 / deltaTime : 0,
    frameNumber: frames.length
  });
  
  lastTimestamp = timestamp;
  requestAnimationFrame(logFrame);
}

requestAnimationFrame(logFrame);

// After 1000 frames, analyze
setTimeout(() => {
  const stats = analyzeFrameTiming(frames);
  console.log('Average FPS:', 1000 / stats.avgDelta);
  console.log('Frame time jitter:', stats.stdDev.toFixed(2) + 'ms');
}, 16667); // ~1000 frames at 60 FPS
```

### Visualize as Racing Line

```javascript
/**
 * Render frame times as a "racing line"
 * Smooth 60 FPS = straight line
 * Jitter = wobbly line
 */
export function renderRacingLine(frames, ctx) {
  const width = ctx.canvas.width;
  const height = ctx.canvas.height;
  const targetDelta = 1000 / 60;
  
  ctx.clearRect(0, 0, width, height);
  
  // Target line (straight)
  ctx.strokeStyle = '#333';
  ctx.beginPath();
  ctx.moveTo(0, height / 2);
  ctx.lineTo(width, height / 2);
  ctx.stroke();
  
  // Actual frame times
  ctx.strokeStyle = '#0f0';
  ctx.beginPath();
  
  frames.forEach((frame, i) => {
    const x = (i / frames.length) * width;
    const deviation = frame.deltaTimeMs - targetDelta;
    const y = height / 2 + deviation * 10; // Scale for visibility
    
    i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
  });
  
  ctx.stroke();
}
```

---

## Part 6: Adaptive FPS System

### Dynamic Frame Rate Adjustment

```javascript
/**
 * Generator with adaptive FPS
 * @param {number} initialFps
 */
export function* adaptiveGameLoop(initialFps) {
  let targetFps = initialFps;
  let runningSampleIndex = 0;
  let frameNumber = 0;
  const sampleRate = 48000;
  
  while (true) {
    const samplesThisFrame = Math.floor(sampleRate / targetFps);
    
    const frame = {
      frameNumber,
      deltaTimeMs: 1000 / targetFps,
      targetFps,
      samplesToWrite: samplesThisFrame,
      writeCursor: runningSampleIndex,
      performanceMetrics: { cpuTime: 0, bufferAvailable: 0 }
    };
    
    const actualDeltaTime = yield frame;
    
    // Adapt FPS if frame took too long
    if (actualDeltaTime > 1000 / targetFps * 1.5) {
      targetFps = Math.max(30, targetFps - 5);
      console.log(`Reducing target FPS to ${targetFps}`);
    } else if (actualDeltaTime < 1000 / targetFps * 0.8 && targetFps < initialFps) {
      targetFps = Math.min(initialFps, targetFps + 5);
      console.log(`Increasing target FPS to ${targetFps}`);
    }
    
    runningSampleIndex += samplesThisFrame;
    frameNumber++;
  }
}
```

---

## Exercises

### Exercise 1: Frame Budget Monitor

Add warning when frame exceeds budget:

```javascript
export function monitorFrameBudget(frame, actualTime) {
  const budget = frame.deltaTimeMs;
  const used = actualTime;
  const percentage = (used / budget) * 100;
  
  if (percentage > 90) {
    console.warn(`Frame ${frame.frameNumber} used ${percentage.toFixed(1)}% of budget!`);
  }
  
  return {
    budget,
    used,
    percentage,
    overbudget: used > budget
  };
}
```

### Exercise 2: Slow-Motion Mode

Implement slow-motion by scaling delta time:

```javascript
export function* slowMotionLoop(targetFps, slowMotionFactor = 0.5) {
  let runningSampleIndex = 0;
  let frameNumber = 0;
  const sampleRate = 48000;
  
  while (true) {
    const samplesThisFrame = Math.floor(sampleRate / targetFps);
    
    const frame = {
      frameNumber,
      deltaTimeMs: (1000 / targetFps) * slowMotionFactor, // Scaled!
      targetFps,
      samplesToWrite: samplesThisFrame,
      writeCursor: runningSampleIndex,
      performanceMetrics: { cpuTime: 0, bufferAvailable: 0 }
    };
    
    yield frame;
    
    runningSampleIndex += samplesThisFrame;
    frameNumber++;
  }
}
```

### Exercise 3: Frame Interpolation

Store previous frame for interpolation:

```javascript
export function* interpolatedLoop(targetFps) {
  let previousFrame = null;
  let runningSampleIndex = 0;
  let frameNumber = 0;
  const sampleRate = 48000;
  
  while (true) {
    const samplesThisFrame = Math.floor(sampleRate / targetFps);
    
    const frame = {
      frameNumber,
      deltaTimeMs: 1000 / targetFps,
      targetFps,
      samplesToWrite: samplesThisFrame,
      writeCursor: runningSampleIndex,
      previous: previousFrame, // For interpolation
      performanceMetrics: { cpuTime: 0, bufferAvailable: 0 }
    };
    
    yield frame;
    
    previousFrame = { ...frame };
    runningSampleIndex += samplesThisFrame;
    frameNumber++;
  }
}
```

---

## Key Takeaways

### What You Learned

1. **Generators encapsulate state, yield data** - pure on the outside
2. **Frame structs are immutable** - you don't mutate them
3. **Performance metrics flow through data** - no global perf counters
4. **Frame timing jitter is visualizable** - use histograms and racing lines

### Connects To

- **Unit 3-L3.1**: Game loop anatomy in backend.c
- **Unit 3-L3.5**: Adaptive FPS system
- **Unit 8-L8.1**: Performance profiling with perf

### Enables

- **Lesson 7**: Latency measurement (timing data flows through frames)
- **Lesson 10**: Game audio manager (frames drive audio generation)

---

## Self-Assessment

You understand this lesson when you can:

- [ ] Explain why `yield frame` is like returning from a game loop iteration
- [ ] Calculate `samplesToWrite` from target FPS and sample rate
- [ ] Visualize frame time variance as a histogram
- [ ] Implement adaptive FPS by adjusting `targetFps` per frame
- [ ] Articulate why generators are better than `class GameLoop { update() { } }`

---

## Next Lesson

**L10.4: Error State as Tagged Union (No Exceptions)** - Model ALSA's error cascade as a state machine array, no try/catch.
