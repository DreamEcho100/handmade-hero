# L10.4: Error State as Tagged Union (No Exceptions)

## Prerequisites
- Completed Unit 4-L4.3 (Initialization Failure Modes)
- Understanding of state machines
- Knowledge of error handling patterns in C

## Core Concept

Model your **ALSA error cascade** as a **plain array of state transitions**—no try/catch, just data.

---

## Part 1: The C Pattern (Error Codes, Not Exceptions)

### Handmade Hero Init Cascade

```c
// backend.c - ALSA initialization
int result = 0;
void *alsa_handle = dlopen("libasound.so.2", RTLD_NOW);
if (!alsa_handle) {
    fprintf(stderr, "Failed to load ALSA\n");
    // Try PulseAudio fallback
    goto try_pulse;
}

result = snd_pcm_open(&pcm, "default", SND_PCM_STREAM_PLAYBACK, 0);
if (result < 0) {
    fprintf(stderr, "ALSA open failed: %d\n", result);
    goto try_pulse;
}

// Success path
return 0;

try_pulse:
    // PulseAudio fallback logic
    // ...
```

**Key Insight:** No exceptions—just **error codes** and **explicit control flow**.

---

## Part 2: State Machine as Array

### Step 1: Define State Transition Table

```javascript
// error-states.mjs
/**
 * @typedef {Object} InitStep
 * @property {string} name
 * @property {function(): number} action Returns 0 or negative error code
 * @property {number} onSuccess Next step index
 * @property {number} onFailure Fallback step index (-1 = abort)
 */

/** @type {InitStep[]} */
const initSteps = [
  {
    name: 'dlopen_alsa',
    action: () => (Math.random() > 0.05 ? 0 : -1),
    onSuccess: 1,
    onFailure: 4 // Jump to PulseAudio fallback
  },
  {
    name: 'dlsym_snd_pcm_open',
    action: () => 0,
    onSuccess: 2,
    onFailure: -1
  },
  {
    name: 'snd_pcm_open',
    action: () => (Math.random() > 0.1 ? 0 : -2),
    onSuccess: 3,
    onFailure: 4
  },
  {
    name: 'snd_pcm_set_params',
    action: () => 0,
    onSuccess: -2, // Success terminal
    onFailure: 4
  },
  {
    name: 'try_pulse',
    action: () => 0,
    onSuccess: -2,
    onFailure: 5
  },
  {
    name: 'fallback_null',
    action: () => 0,
    onSuccess: -2,
    onFailure: -1
  }
];
```

### Step 2: Interpreter (Not a Class)

```javascript
/**
 * Run initialization state machine
 * @returns {('alsa'|'pulse'|'null'|'failed')}
 */
export function runInitMachine() {
  let stepIndex = 0;
  const executedSteps = [];
  
  while (stepIndex >= 0 && stepIndex < initSteps.length) {
    const step = initSteps[stepIndex];
    executedSteps.push(step.name);
    
    const result = step.action();
    
    if (result === 0) {
      stepIndex = step.onSuccess;
    } else {
      console.log(`[INIT] ${step.name} failed with ${result}`);
      stepIndex = step.onFailure;
    }
    
    // Terminal success
    if (stepIndex === -2) {
      if (executedSteps.includes('snd_pcm_set_params')) return 'alsa';
      if (executedSteps.includes('try_pulse')) return 'pulse';
      return 'null';
    }
  }
  
  return 'failed';
}
```

---

## Part 3: Data-Oriented Principle

### ❌ Exception-Based Way

```javascript
try {
  const handle = dlopen('libasound.so.2');
  try {
    const pcm = snd_pcm_open(handle, 'default');
    return { backend: 'alsa', handle: pcm };
  } catch (e) {
    throw new Error('ALSA init failed');
  }
} catch (e) {
  try {
    return initPulseAudio();
  } catch (e2) {
    return initNullBackend();
  }
}
```

**Problems:**
- Hidden control flow
- Can't visualize execution path
- Hard to test specific failure modes

### ✅ State Machine Way

```javascript
const initSteps = [ /* data */ ];
const backend = runInitMachine();
```

**Benefits:**
- Control flow is **visible data**
- Easy to visualize (draw state diagram)
- Testable (inject failures by index)

---

## Part 4: Visualizing State Transitions

### State Diagram Generator

```javascript
/**
 * Generate Graphviz DOT format
 * @param {InitStep[]} steps
 * @returns {string}
 */
export function generateStateDiagram(steps) {
  let dot = 'digraph Init {\n';
  
  steps.forEach((step, i) => {
    dot += `  ${i} [label="${step.name}"];\n`;
    
    if (step.onSuccess >= 0) {
      dot += `  ${i} -> ${step.onSuccess} [label="success", color="green"];\n`;
    } else if (step.onSuccess === -2) {
      dot += `  ${i} -> SUCCESS [color="green"];\n`;
    }
    
    if (step.onFailure >= 0) {
      dot += `  ${i} -> ${step.onFailure} [label="failure", color="red"];\n`;
    } else if (step.onFailure === -1) {
      dot += `  ${i} -> FAILED [color="red"];\n`;
    }
  });
  
  dot += '}\n';
  return dot;
}
```

### Canvas-Based Visualizer

```javascript
/**
 * Render state machine execution
 * @param {string[]} executedSteps
 * @param {CanvasRenderingContext2D} ctx
 */
export function visualizeExecution(executedSteps, ctx) {
  const width = ctx.canvas.width;
  const height = ctx.canvas.height;
  const stepHeight = height / executedSteps.length;
  
  ctx.clearRect(0, 0, width, height);
  
  executedSteps.forEach((stepName, i) => {
    const y = i * stepHeight;
    
    // Step box
    ctx.fillStyle = stepName.includes('failed') ? '#f00' : '#0f0';
    ctx.fillRect(10, y + 5, width - 20, stepHeight - 10);
    
    // Label
    ctx.fillStyle = '#000';
    ctx.font = '14px monospace';
    ctx.fillText(stepName, 20, y + stepHeight / 2);
    
    // Arrow to next
    if (i < executedSteps.length - 1) {
      ctx.strokeStyle = '#fff';
      ctx.beginPath();
      ctx.moveTo(width / 2, y + stepHeight);
      ctx.lineTo(width / 2, y + stepHeight + 5);
      ctx.stroke();
    }
  });
}
```

---

## Part 5: Testable Failure Injection

### Force Specific Failures

```javascript
/**
 * Inject failure at specific step for testing
 * @param {number} failAtStep Index to fail at
 * @returns {string}
 */
export function runWithInjectedFailure(failAtStep) {
  let stepIndex = 0;
  const executedSteps = [];
  
  while (stepIndex >= 0 && stepIndex < initSteps.length) {
    const step = initSteps[stepIndex];
    executedSteps.push(step.name);
    
    // Inject failure
    const result = (stepIndex === failAtStep) ? -1 : step.action();
    
    if (result === 0) {
      stepIndex = step.onSuccess;
    } else {
      console.log(`[INJECTED] Failed at ${step.name}`);
      stepIndex = step.onFailure;
    }
    
    if (stepIndex === -2) {
      if (executedSteps.includes('snd_pcm_set_params')) return 'alsa';
      if (executedSteps.includes('try_pulse')) return 'pulse';
      return 'null';
    }
  }
  
  return 'failed';
}

// Test all failure paths
console.log('Fail at step 0:', runWithInjectedFailure(0)); // Should use pulse
console.log('Fail at step 2:', runWithInjectedFailure(2)); // Should use pulse
console.log('Fail at step 4:', runWithInjectedFailure(4)); // Should use null
```

---

## Part 6: Creative Challenge - Visual Novel

### Dialogue State Machine

```javascript
/**
 * @typedef {Object} DialogueNode
 * @property {string} text
 * @property {string[]} choices
 * @property {number[]} nextNodes Parallel to choices
 * @property {function(): number} condition Optional: auto-branching
 */

/** @type {DialogueNode[]} */
const story = [
  {
    text: "ALSA library loading...",
    choices: ["Continue"],
    nextNodes: [1],
    condition: () => (Math.random() > 0.9 ? 3 : 1) // Random failure
  },
  {
    text: "Successfully loaded ALSA!",
    choices: ["Open device", "Try PulseAudio instead"],
    nextNodes: [2, 4]
  },
  {
    text: "Device opened. Audio quality: Perfect",
    choices: ["Play sound"],
    nextNodes: [-2] // Success ending
  },
  {
    text: "ALSA failed! System message: Permission denied",
    choices: ["Retry", "Fallback to PulseAudio"],
    nextNodes: [1, 4]
  },
  {
    text: "PulseAudio active. Audio quality: Degraded",
    choices: ["Accept degraded audio"],
    nextNodes: [-2]
  }
];

/**
 * Run visual novel - player experiences audio init
 * @param {number} startNode
 */
export function runVisualNovel(startNode = 0) {
  let currentNode = startNode;
  
  while (currentNode >= 0 && currentNode < story.length) {
    const node = story[currentNode];
    console.log(`\n${node.text}`);
    
    // Auto-branch if condition exists
    if (node.condition) {
      currentNode = node.condition();
      continue;
    }
    
    // Player choice
    node.choices.forEach((choice, i) => {
      console.log(`  ${i + 1}. ${choice}`);
    });
    
    // (In real impl, wait for user input)
    const choice = 0; // Simulate choice
    currentNode = node.nextNodes[choice];
    
    if (currentNode === -2) {
      console.log('\n[SUCCESS] Audio initialized!');
      break;
    }
  }
}
```

---

## Exercises

### Exercise 1: Retry Logic

Add retry attempts with exponential backoff:

```javascript
export function runWithRetries(maxRetries = 3) {
  let stepIndex = 0;
  let retries = 0;
  
  while (stepIndex >= 0) {
    const step = initSteps[stepIndex];
    const result = step.action();
    
    if (result !== 0 && retries < maxRetries) {
      console.log(`[RETRY] Attempt ${retries + 1}/${maxRetries}`);
      retries++;
      continue; // Retry same step
    }
    
    stepIndex = result === 0 ? step.onSuccess : step.onFailure;
    retries = 0; // Reset on transition
  }
}
```

### Exercise 2: State Machine Debugger

Log all possible paths:

```javascript
export function enumerateAllPaths() {
  const paths = [];
  
  function explore(stepIndex, path, backend) {
    if (stepIndex === -2) {
      paths.push({ path, backend, success: true });
      return;
    }
    if (stepIndex === -1) {
      paths.push({ path, backend: 'none', success: false });
      return;
    }
    
    const step = initSteps[stepIndex];
    
    // Explore success path
    explore(step.onSuccess, [...path, `${step.name}→success`], backend);
    
    // Explore failure path
    explore(step.onFailure, [...path, `${step.name}→failure`], backend);
  }
  
  explore(0, [], null);
  return paths;
}
```

### Exercise 3: Async State Machine

Support async actions:

```javascript
export async function runAsyncInitMachine() {
  let stepIndex = 0;
  
  while (stepIndex >= 0 && stepIndex < initSteps.length) {
    const step = initSteps[stepIndex];
    
    // Await async action
    const result = await step.action();
    
    stepIndex = result === 0 ? step.onSuccess : step.onFailure;
    
    if (stepIndex === -2) return 'success';
  }
  
  return 'failed';
}
```

---

## Key Takeaways

### What You Learned

1. **Error codes > exceptions** for explicit control flow
2. **State machines as data** - arrays of transitions
3. **Visualizable execution paths** - no hidden behavior
4. **Testable failure modes** - inject errors by index

### Connects To

- **Unit 4-L4.3**: ALSA initialization cascade
- **Unit 1-L1.6**: Error handling patterns
- **Lesson 1**: Function tables (compose with state machines)

### Enables

- **Lesson 8**: Advanced state machine patterns
- **Lesson 10**: Robust game audio init

---

## Self-Assessment

You understand this lesson when you can:

- [ ] Replace a try/catch cascade with a state machine array
- [ ] Visualize execution paths as a state diagram
- [ ] Inject failures at specific steps for testing
- [ ] Explain why error codes are more debuggable than exceptions
- [ ] Build a visual novel with branching dialogue

---

## Next Lesson

**L10.5: SharedArrayBuffer as C Struct (Manual Layout)** - Manually layout memory with explicit offsets and alignment.
