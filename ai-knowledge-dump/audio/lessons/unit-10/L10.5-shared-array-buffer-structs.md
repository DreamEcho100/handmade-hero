# L10.5: SharedArrayBuffer as C Struct (Manual Layout)

## Prerequisites
- Completed Unit 2-L2.4 (Ring Buffer Mental Model)
- Understanding of C struct memory layout
- Knowledge of alignment and padding

## Core Concept

Manually **layout memory** like a C struct—**offsets matter, alignment matters, no abstraction**.

---

## Part 1: C Struct Memory Layout

### Handmade Hero Audio State

```c
typedef struct {
    int handle;            // @offset 0,  4 bytes
    int channels;          // @offset 4,  4 bytes
    int rate;              // @offset 8,  4 bytes
    int latency_ms;        // @offset 12, 4 bytes
    int64_t write_cursor;  // @offset 16, 8 bytes (aligned!)
    int64_t running_index; // @offset 24, 8 bytes
} alsa_state;              // Total: 32 bytes
```

**Key Insight:** The compiler pads fields for alignment. `int64_t` must be at 8-byte boundaries.

---

## Part 2: Manual JavaScript Layout

### Step 1: Define Memory Structure

```javascript
// c-struct-layout.mjs
/**
 * Memory layout (32 bytes total):
 * @typedef {Object} AlsaState
 * @property {Int32Array} handle       @offset 0  (4 bytes)
 * @property {Int32Array} channels     @offset 4  (4 bytes)
 * @property {Int32Array} rate         @offset 8  (4 bytes)
 * @property {Int32Array} latency_ms   @offset 12 (4 bytes)
 * @property {BigInt64Array} writeCursor @offset 16 (8 bytes, aligned)
 * @property {BigInt64Array} runningIndex @offset 24 (8 bytes)
 */

const STATE_SIZE = 32;
```

### Step 2: Creation Function (Manual Offsets)

```javascript
/**
 * Create ALSA state struct from raw memory
 * @param {SharedArrayBuffer} sab
 * @returns {AlsaState}
 */
export function createAlsaState(sab) {
  // Manual offset calculation—like C struct padding
  return {
    handle: new Int32Array(sab, 0, 1),
    channels: new Int32Array(sab, 4, 1),
    rate: new Int32Array(sab, 8, 1),
    latency_ms: new Int32Array(sab, 12, 1),
    writeCursor: new BigInt64Array(sab, 16, 1),  // 8-byte aligned
    runningIndex: new BigInt64Array(sab, 24, 1)
  };
}

// Usage
const buffer = new SharedArrayBuffer(STATE_SIZE);
const state = createAlsaState(buffer);
```

### Step 3: Initialization Function

```javascript
/**
 * Initialize state - like alsa_init()
 * @param {AlsaState} state
 * @param {number} handle
 * @param {number} channels
 * @param {number} rate
 */
export function initState(state, handle, channels, rate) {
  state.handle[0] = handle;
  state.channels[0] = channels;
  state.rate[0] = rate;
  state.latency_ms[0] = Math.floor((4096 * 1000) / rate);
  state.writeCursor[0] = 0n;
  state.runningIndex[0] = 0n;
}
```

### Step 4: Update Functions (Pure)

```javascript
/**
 * Update write cursor - like audio write loop
 * @param {AlsaState} state
 * @param {number} framesWritten
 */
export function updateCursors(state, framesWritten) {
  const newIndex = state.runningIndex[0] + BigInt(framesWritten);
  state.runningIndex[0] = newIndex;
  state.writeCursor[0] = newIndex % BigInt(state.rate[0]);
}

/**
 * Get latency in samples
 * @param {AlsaState} state
 * @returns {number}
 */
export function getLatencySamples(state) {
  return Math.floor(state.rate[0] * state.latency_ms[0] / 1000);
}
```

---

## Part 3: Alignment Matters

### Debug Challenge - Misalignment Test

```javascript
/**
 * BROKEN VERSION - misaligned BigInt64Array
 */
function createBrokenState(sab) {
  return {
    handle: new Int32Array(sab, 0, 1),
    channels: new Int32Array(sab, 4, 1),
    rate: new Int32Array(sab, 8, 1),
    // BUG: BigInt64Array at offset 10 (not 8-byte aligned!)
    writeCursor: new BigInt64Array(sab, 10, 1), // CRASHES
    runningIndex: new BigInt64Array(sab, 18, 1)
  };
}

// Test it
try {
  const buffer = new SharedArrayBuffer(32);
  const broken = createBrokenState(buffer);
  console.log('This will crash!');
} catch (e) {
  console.error('RangeError: offset must be multiple of 8');
}
```

**Why it crashes:** `BigInt64Array` requires 8-byte alignment. Offset 10 is not divisible by 8.

### Alignment Calculator

```javascript
/**
 * Calculate next aligned offset
 * @param {number} currentOffset
 * @param {number} alignment 1, 2, 4, or 8
 * @returns {number}
 */
export function alignOffset(currentOffset, alignment) {
  const remainder = currentOffset % alignment;
  return remainder === 0 ? currentOffset : currentOffset + (alignment - remainder);
}

// Example
console.log(alignOffset(10, 8)); // 16 (next 8-byte boundary)
console.log(alignOffset(12, 8)); // 16
console.log(alignOffset(16, 8)); // 16 (already aligned)
```

---

## Part 4: Web API Mirror - Manual Audio Buffer

### Don't Use AudioBuffer - Allocate Raw Memory

```javascript
/**
 * Manual stereo audio buffer (no AudioBuffer abstraction)
 * 1 second of stereo at 48kHz
 */
const sampleRate = 48000;
const duration = 1; // seconds
const channels = 2;

// Allocate: 48000 samples * 2 channels * 4 bytes (Float32)
const sab = new SharedArrayBuffer(sampleRate * channels * 4);

// Layout channels manually
const leftChannel = new Float32Array(sab, 0, sampleRate);
const rightChannel = new Float32Array(sab, sampleRate * 4, sampleRate);

// Manual interleaving (like snd_pcm_writei)
for (let i = 0; i < sampleRate; i++) {
  leftChannel[i] = Math.sin(2 * Math.PI * 440 * i / sampleRate);
  rightChannel[i] = Math.sin(2 * Math.PI * 880 * i / sampleRate);
}
```

**This is exactly what `snd_pcm_set_params` does**—manual memory layout for interleaved audio.

---

## Part 5: Complex Struct with Nested Arrays

### Game Sound Output (Handmade Hero)

```javascript
/**
 * @typedef {Object} GameSoundOutput
 * @property {Int32Array} samplesPerSecond  @offset 0
 * @property {Int32Array} sampleCount       @offset 4
 * @property {BigInt64Array} writeCursor    @offset 8 (aligned)
 * @property {Float32Array} samples         @offset 16+ (variable)
 */

/**
 * Create game sound output buffer
 * @param {number} sampleRate
 * @param {number} maxSamples
 * @returns {GameSoundOutput}
 */
export function createGameSoundOutput(sampleRate, maxSamples) {
  const headerSize = 16; // 4 + 4 + 8 (aligned)
  const dataSize = maxSamples * 4; // Float32 = 4 bytes each
  const totalSize = headerSize + dataSize;
  
  const buffer = new SharedArrayBuffer(totalSize);
  
  return {
    samplesPerSecond: new Int32Array(buffer, 0, 1),
    sampleCount: new Int32Array(buffer, 4, 1),
    writeCursor: new BigInt64Array(buffer, 8, 1),
    samples: new Float32Array(buffer, 16, maxSamples)
  };
}

// Initialize
const soundOutput = createGameSoundOutput(48000, 4096);
soundOutput.samplesPerSecond[0] = 48000;
soundOutput.sampleCount[0] = 0;
soundOutput.writeCursor[0] = 0n;
```

---

## Part 6: Creative Challenge - Struct Puzzle Game

### Hex Dump Decoder

```javascript
/**
 * @typedef {Object} PuzzleLevel
 * @property {Uint8Array} hexDump Raw memory
 * @property {string} secretMessage Hidden in struct
 * @property {Object} structHints Wrong offsets - you must fix them
 */

const level1 = {
  hexDump: new Uint8Array([
    0x48, 0x65, 0x6C, 0x6C, // "Hell"
    0x6F, 0x20, 0x00, 0x00, // "o "
    0x57, 0x6F, 0x72, 0x6C, // "Worl"
    0x64, 0x21, 0x00, 0x00  // "d!"
  ]),
  secretMessage: "Hello World!",
  structHints: {
    part1Offset: 0,  // Correct
    part2Offset: 6,  // WRONG! Should be 4
    part3Offset: 10, // WRONG! Should be 8
    part4Offset: 14  // WRONG! Should be 12
  }
};

/**
 * Decode message with correct offsets
 * @param {PuzzleLevel} level
 * @param {Object} offsets Player's guesses
 * @returns {string}
 */
export function decodeMessage(level, offsets) {
  const decoder = new TextDecoder();
  let message = '';
  
  message += decoder.decode(level.hexDump.slice(offsets.part1Offset, offsets.part1Offset + 4));
  message += decoder.decode(level.hexDump.slice(offsets.part2Offset, offsets.part2Offset + 2));
  message += decoder.decode(level.hexDump.slice(offsets.part3Offset, offsets.part3Offset + 4));
  message += decoder.decode(level.hexDump.slice(offsets.part4Offset, offsets.part4Offset + 2));
  
  return message;
}

// Player must find correct offsets
const correctOffsets = {
  part1Offset: 0,
  part2Offset: 4,
  part3Offset: 8,
  part4Offset: 12
};

console.log(decodeMessage(level1, correctOffsets)); // "Hello World!"
```

---

## Exercises

### Exercise 1: Struct Size Calculator

Calculate total size with padding:

```javascript
/**
 * @typedef {Object} FieldDef
 * @property {string} name
 * @property {number} size Bytes
 * @property {number} alignment
 */

/**
 * Calculate struct size with padding
 * @param {FieldDef[]} fields
 * @returns {number}
 */
export function calculateStructSize(fields) {
  let offset = 0;
  
  fields.forEach(field => {
    // Align offset
    offset = alignOffset(offset, field.alignment);
    offset += field.size;
  });
  
  // Final alignment to largest field
  const maxAlign = Math.max(...fields.map(f => f.alignment));
  return alignOffset(offset, maxAlign);
}

// Example
const alsaFields = [
  { name: 'handle', size: 4, alignment: 4 },
  { name: 'channels', size: 4, alignment: 4 },
  { name: 'rate', size: 4, alignment: 4 },
  { name: 'latency_ms', size: 4, alignment: 4 },
  { name: 'writeCursor', size: 8, alignment: 8 },
  { name: 'runningIndex', size: 8, alignment: 8 }
];

console.log(calculateStructSize(alsaFields)); // 32 bytes
```

### Exercise 2: Memory Hex Dump

Visualize raw memory:

```javascript
/**
 * Print hex dump of SharedArrayBuffer
 * @param {SharedArrayBuffer} sab
 * @param {number} bytesPerLine
 */
export function hexDump(sab, bytesPerLine = 16) {
  const bytes = new Uint8Array(sab);
  
  for (let i = 0; i < bytes.length; i += bytesPerLine) {
    const offset = i.toString(16).padStart(8, '0');
    const chunk = bytes.slice(i, i + bytesPerLine);
    const hex = Array.from(chunk)
      .map(b => b.toString(16).padStart(2, '0'))
      .join(' ');
    const ascii = Array.from(chunk)
      .map(b => (b >= 32 && b < 127) ? String.fromCharCode(b) : '.')
      .join('');
    
    console.log(`${offset}  ${hex.padEnd(bytesPerLine * 3)}  ${ascii}`);
  }
}

// Test
const buffer = new SharedArrayBuffer(32);
const state = createAlsaState(buffer);
initState(state, 42, 2, 48000);
hexDump(buffer);
```

### Exercise 3: Cross-Worker Struct

Share struct between workers:

```javascript
// main.mjs
const buffer = new SharedArrayBuffer(STATE_SIZE);
const state = createAlsaState(buffer);
initState(state, 1, 2, 48000);

const worker = new Worker('./audio-worker.mjs', { type: 'module' });
worker.postMessage({ stateBuffer: buffer });

// audio-worker.mjs
self.onmessage = (e) => {
  const state = createAlsaState(e.data.stateBuffer);
  
  setInterval(() => {
    updateCursors(state, 1024);
    console.log('Running index:', state.runningIndex[0]);
  }, 100);
};
```

---

## Key Takeaways

### What You Learned

1. **Manual memory layout** - explicit offsets like C structs
2. **Alignment is critical** - BigInt64Array needs 8-byte boundaries
3. **SharedArrayBuffer = raw memory** - no abstraction
4. **TypedArray views** - multiple views on same buffer

### Connects To

- **Unit 2-L2.4**: Ring buffer memory layout
- **Unit 7-L7.2**: Cache alignment effects
- **Lesson 2**: Ring buffer as raw memory

### Enables

- **Lesson 6**: TypeScript types for structs
- **Lesson 9**: WASM memory interop

---

## Self-Assessment

You understand this lesson when you can:

- [ ] Calculate struct size with padding
- [ ] Explain why BigInt64Array needs 8-byte alignment
- [ ] Create SharedArrayBuffer with multiple TypedArray views
- [ ] Debug misalignment errors
- [ ] Share structs between Workers

---

## Next Lesson

**L10.6: TypeScript Types for C Structs** - Write JSDoc types that describe memory layout, not behavior.
