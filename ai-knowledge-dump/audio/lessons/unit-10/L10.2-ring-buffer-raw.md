# L10.2: Ring Buffer as Raw TypedArray (No Objects)

## Prerequisites

- Completed Unit 2-L2.4 (Ring Buffer Mental Model)
- Understanding of C pointer arithmetic
- Knowledge of SharedArrayBuffer and TypedArrays

## Core Concept

Visualize your ring buffer as **raw memory**—just a `SharedArrayBuffer` with manual cursor arithmetic. **No classes, just data transforms**.

---

## Part 1: Understanding Raw Memory Layout

### In C (Handmade Hero style)

```c
typedef struct {
    int read_cursor;     // @offset 0
    int write_cursor;    // @offset 4
    float samples[];     // @offset 8, variable length
} RingBuffer;

// Manual pointer arithmetic
void write_sample(RingBuffer *rb, float sample) {
    int mask = rb->size - 1;  // Power of 2 optimization
    rb->samples[rb->write_cursor & mask] = sample;
    rb->write_cursor++;
}
```

**Key Insight:** The buffer is just **contiguous memory** with manual index management. No abstractions.

---

## Part 2: JavaScript Translation with SharedArrayBuffer

### Step 1: Memory Layout Definition

```javascript
// ring-buffer-raw.mjs
/**
 * @typedef {Object} RingBuffer
 * @property {SharedArrayBuffer} buffer
 * @property {Int32Array} readIndex  // First 4 bytes
 * @property {Int32Array} writeIndex // Next 4 bytes
 * @property {Float32Array} data     // Rest of buffer
 */
```

### Step 2: Creation Function (Not a Constructor)

```javascript
/**
 * Create ring buffer - mirrors L2.4: Ring Buffer Mental Model
 * @param {number} sizePowerOfTwo Must be power of 2 for mask optimization
 * @returns {RingBuffer}
 */
export function createRingBuffer(sizePowerOfTwo) {
  const buffer = new SharedArrayBuffer(8 + sizePowerOfTwo * 4);
  return {
    buffer,
    readIndex: new Int32Array(buffer, 0, 1),
    writeIndex: new Int32Array(buffer, 4, 1),
    data: new Float32Array(buffer, 8, sizePowerOfTwo),
  };
}
```

**Memory layout:**

```
Offset 0-3:   readIndex  (i32)
Offset 4-7:   writeIndex (i32)
Offset 8+:    data       (Float32 array)
```

### Step 3: Write Function (Pure, No Methods)

```javascript
/**
 * Write samples - mirrors audio.c:470-603 sample writing loop
 * @param {RingBuffer} rb
 * @param {Float32Array} input
 * @returns {number} Frames written
 */
export function ringBufferWrite(rb, input) {
  const mask = rb.data.length - 1;
  let written = 0;

  for (let i = 0; i < input.length; i++) {
    const writePos = Atomics.load(rb.writeIndex, 0) & mask;
    const readPos = Atomics.load(rb.readIndex, 0);

    // Buffer full check - like snd_pcm_avail() == 0
    if (writePos === readPos) break;

    rb.data[writePos] = input[i];
    Atomics.add(rb.writeIndex, 0, 1);
    written++;
  }
  return written;
}
```

### Step 4: Read Function

```javascript
/**
 * Read samples - consumer side
 * @param {RingBuffer} rb
 * @param {Float32Array} output
 * @returns {number} Frames read
 */
export function ringBufferRead(rb, output) {
  const mask = rb.data.length - 1;
  let read = 0;

  for (let i = 0; i < output.length; i++) {
    const readPos = Atomics.load(rb.readIndex, 0) & mask;
    const writePos = Atomics.load(rb.writeIndex, 0);

    // Buffer empty check
    if (readPos === writePos) break;

    output[i] = rb.data[readPos];
    Atomics.add(rb.readIndex, 0, 1);
    read++;
  }
  return read;
}
```

---

## Part 3: The Power of 2 Mask Optimization

### Why Power of 2?

```javascript
// ❌ Slow modulo operation
index = index % bufferSize;

// ✅ Fast bitwise AND (when bufferSize is power of 2)
index = index & (bufferSize - 1);
```

**Proof:**

```javascript
const bufferSize = 1024; // 2^10
const mask = 1023; // 1024 - 1 = 0b1111111111

console.log(1025 % 1024); // 1 (slow)
console.log(1025 & mask); // 1 (fast, same result)

console.log(2048 % 1024); // 0
console.log(2048 & mask); // 0
```

### Benchmark

```javascript
// Test the difference
function benchmarkMask() {
  const size = 1024;
  const mask = size - 1;
  const iterations = 10_000_000;

  // Modulo version
  let start = performance.now();
  let index = 0;
  for (let i = 0; i < iterations; i++) {
    index = (index + 1) % size;
  }
  console.log(`Modulo: ${performance.now() - start}ms`);

  // Mask version
  start = performance.now();
  index = 0;
  for (let i = 0; i < iterations; i++) {
    index = (index + 1) & mask;
  }
  console.log(`Mask: ${performance.now() - start}ms`);
}
```

---

## Part 4: Lock-Free with Atomics

### Why Atomics?

```javascript
// ❌ NOT thread-safe
rb.writeIndex[0]++;

// ✅ Thread-safe (works across Workers)
Atomics.add(rb.writeIndex, 0, 1);
```

### Producer-Consumer Pattern

```javascript
// main.mjs (producer)
import { createRingBuffer, ringBufferWrite } from "./ring-buffer-raw.mjs";

const rb = createRingBuffer(4096);

// Spawn consumer worker
const worker = new Worker("./consumer.mjs", { type: "module" });
worker.postMessage({ buffer: rb.buffer });

// Producer loop
setInterval(() => {
  const samples = new Float32Array(128);
  for (let i = 0; i < 128; i++) {
    samples[i] = Math.sin(Date.now() * 0.001 + i * 0.1);
  }
  const written = ringBufferWrite(rb, samples);
  console.log(`Wrote ${written} samples`);
}, 16);
```

```javascript
// consumer.mjs (worker)
import { ringBufferRead } from "./ring-buffer-raw.mjs";

self.onmessage = (e) => {
  const rb = {
    buffer: e.data.buffer,
    readIndex: new Int32Array(e.data.buffer, 0, 1),
    writeIndex: new Int32Array(e.data.buffer, 4, 1),
    data: new Float32Array(e.data.buffer, 8),
  };

  // Consumer loop
  setInterval(() => {
    const output = new Float32Array(128);
    const read = ringBufferRead(rb, output);
    console.log(`Read ${read} samples`);
  }, 16);
};
```

---

## Part 5: Debug Challenge - Force Buffer Wrap

### Visualization Tool

```javascript
/**
 * Visualize ring buffer state
 * @param {RingBuffer} rb
 */
export function debugRingBuffer(rb) {
  const readPos = Atomics.load(rb.readIndex, 0);
  const writePos = Atomics.load(rb.writeIndex, 0);
  const mask = rb.data.length - 1;

  console.log("Ring Buffer State:");
  console.log(`  Read cursor:  ${readPos} (wrapped: ${readPos & mask})`);
  console.log(`  Write cursor: ${writePos} (wrapped: ${writePos & mask})`);
  console.log(`  Available:    ${writePos - readPos} samples`);
  console.log(
    `  Used space:   ${(((writePos - readPos) / rb.data.length) * 100).toFixed(1)}%`,
  );
}
```

### Test Wrapping

```javascript
function testWrap() {
  const rb = createRingBuffer(16); // Small buffer

  // Write more than capacity
  const input = new Float32Array(100);
  for (let i = 0; i < 100; i++) {
    input[i] = i;
  }

  ringBufferWrite(rb, input);
  debugRingBuffer(rb);

  // Watch cursors wrap around
  console.log("First few samples:", rb.data.slice(0, 5));
}
```

---

## Part 6: Creative Challenge - Memory Inspector Visualizer

### Canvas-Based Hex Dump + Waveform

```javascript
/**
 * @param {RingBuffer} rb
 * @param {CanvasRenderingContext2D} ctx
 */
export function visualizeRingBuffer(rb, ctx) {
  const width = ctx.canvas.width;
  const height = ctx.canvas.height;

  ctx.clearRect(0, 0, width, height);

  // Top half: hex dump
  const bytes = new Uint8Array(rb.buffer);
  ctx.font = "10px monospace";
  ctx.fillStyle = "#0f0";

  for (let i = 0; i < Math.min(256, bytes.length); i++) {
    const x = (i % 32) * 20;
    const y = Math.floor(i / 32) * 16;
    ctx.fillText(bytes[i].toString(16).padStart(2, "0"), x, y);
  }

  // Bottom half: waveform
  const readPos = Atomics.load(rb.readIndex, 0);
  const writePos = Atomics.load(rb.writeIndex, 0);
  const mask = rb.data.length - 1;

  ctx.strokeStyle = "#0f0";
  ctx.beginPath();
  for (let i = 0; i < rb.data.length; i++) {
    const x = (i / rb.data.length) * width;
    const y = height / 2 + (rb.data[i] * height) / 4;
    i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
  }
  ctx.stroke();

  // Cursor indicators
  ctx.fillStyle = "#f00";
  ctx.fillRect(((readPos & mask) / rb.data.length) * width, 0, 2, height);
  ctx.fillStyle = "#00f";
  ctx.fillRect(((writePos & mask) / rb.data.length) * width, 0, 2, height);
}
```

---

## Exercises

### Exercise 1: Detect Overflow

Add overflow detection:

```javascript
export function ringBufferWriteSafe(rb, input) {
  const available = rb.data.length - (rb.writeIndex[0] - rb.readIndex[0]);
  if (input.length > available) {
    console.warn(
      `Buffer overflow! Requested: ${input.length}, Available: ${available}`,
    );
    return 0;
  }
  return ringBufferWrite(rb, input);
}
```

### Exercise 2: Benchmark Atomics vs Regular

Compare atomic vs non-atomic operations:

```javascript
function benchmarkAtomics() {
  const buffer = new SharedArrayBuffer(4);
  const arr = new Int32Array(buffer);

  // Regular increment
  let start = performance.now();
  for (let i = 0; i < 10_000_000; i++) {
    arr[0]++;
  }
  console.log(`Regular: ${performance.now() - start}ms`);

  // Atomic increment
  arr[0] = 0;
  start = performance.now();
  for (let i = 0; i < 10_000_000; i++) {
    Atomics.add(arr, 0, 1);
  }
  console.log(`Atomic: ${performance.now() - start}ms`);
}
```

### Exercise 3: Multi-Producer Ring Buffer

Extend to support multiple writers:

```javascript
export function ringBufferWriteMulti(rb, input, producerId) {
  // Add producer ID to metadata
  // Implement producer slots
  // Handle collisions
}
```

---

## Key Takeaways

### What You Learned

1. **SharedArrayBuffer is raw memory** - you manually layout data
2. **Power-of-2 sizes enable fast wrapping** - bitwise AND vs modulo
3. **Atomics enable lock-free concurrency** - safe across Workers
4. **Ring buffers are just index math** - no magic, just wrapping

### Connects To

- **Unit 2-L2.4**: The original ring buffer mental model
- **Unit 7-L7.2**: Cache-friendly sequential memory access
- **Unit 8-L8.3**: Lock-free programming patterns

### Enables

- **Lesson 3**: Frame timing with buffer state
- **Lesson 5**: Shared memory between threads
- **Lesson 7**: Latency measurement arrays

---

## Self-Assessment

You understand this lesson when you can:

- [ ] Explain why `writeIndex & mask` works for wrapping
- [ ] Visualize the memory layout of the SharedArrayBuffer
- [ ] Implement producer-consumer pattern with Workers
- [ ] Debug buffer overflow by inspecting cursors
- [ ] Articulate why this is faster than a class-based queue

---

## Next Lesson

**L10.3: Frame Timing as Pure Data Transform** - Model the game loop as a generator that yields frame structs, no state mutation.
