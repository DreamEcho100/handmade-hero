# L10.7: Latency Data as Array of Structs

## Prerequisites
- Completed Unit 8-L8.1 (Performance Profiling)
- Understanding of Structure of Arrays (SoA) pattern
- Knowledge of cache-friendly data access

## Core Concept

Collect **1000 latency measurements** as a **flat Float64Array**—not an array of objects. This is cache-friendly data-oriented design.

---

## Part 1: AoS vs SoA

### ❌ Array of Structures (OOP Way)

```javascript
const samples = [
  { timestamp: 100, keypressTime: 95, audioTime: 110 },
  { timestamp: 117, keypressTime: 112, audioTime: 127 },
  // ... 998 more objects
];

// Access pattern: random jumps through memory
const latency = samples[i].audioTime - samples[i].keypressTime;
```

**Problem:** Each object is scattered in memory. Cache misses galore.

### ✅ Structure of Arrays (Data-Oriented Way)

```javascript
// Flat array: [ts0, kp0, at0, ts1, kp1, at1, ...]
const samples = new Float64Array(1000 * 3);

// Access pattern: sequential memory
const offset = i * 3;
const latency = samples[offset + 2] - samples[offset + 1];
```

**Benefit:** Sequential memory access = cache-friendly.

---

## Part 2: Flat Array Implementation

### Memory Layout

```javascript
// latency-struct-array.mjs

/**
 * Each measurement is 24 bytes (3 x Float64):
 * @typedef {Object} LatencySample
 * @property {number} timestamp      @offset 0
 * @property {number} keypressTime   @offset 8
 * @property {number} audioTime      @offset 16
 */

const SAMPLE_SIZE = 3; // 3 Float64 values
const MAX_SAMPLES = 1000;

/** Flat array: all samples in contiguous memory */
const samples = new Float64Array(MAX_SAMPLES * SAMPLE_SIZE);
let sampleCount = 0;
```

### Recording Function

```javascript
/**
 * Record latency sample - data-oriented write
 * @param {number} timestamp
 * @param {number} keypressTime
 * @param {number} audioTime
 */
export function recordSample(timestamp, keypressTime, audioTime) {
  if (sampleCount >= MAX_SAMPLES) return;
  
  const offset = sampleCount * SAMPLE_SIZE;
  samples[offset] = timestamp;
  samples[offset + 1] = keypressTime;
  samples[offset + 2] = audioTime;
  
  sampleCount++;
}
```

### Analysis Function

```javascript
/**
 * Process all samples in one loop - cache-friendly
 * @returns {Object} Statistics
 */
export function analyzeSamples() {
  let totalLatency = 0;
  let minLatency = Infinity;
  let maxLatency = -Infinity;
  
  for (let i = 0; i < sampleCount * SAMPLE_SIZE; i += SAMPLE_SIZE) {
    const latency = samples[i + 2] - samples[i + 1];
    totalLatency += latency;
    minLatency = Math.min(minLatency, latency);
    maxLatency = Math.max(maxLatency, latency);
  }
  
  return {
    avgLatency: totalLatency / sampleCount,
    minLatency,
    maxLatency,
    sampleCount
  };
}

/**
 * Get percentile - requires sort
 * @param {number} percentile 0-100
 * @returns {number}
 */
export function getPercentile(percentile) {
  const latencies = new Float64Array(sampleCount);
  
  for (let i = 0; i < sampleCount; i++) {
    const offset = i * SAMPLE_SIZE;
    latencies[i] = samples[offset + 2] - samples[offset + 1];
  }
  
  latencies.sort();
  const index = Math.floor((percentile / 100) * sampleCount);
  return latencies[index];
}
```

---

## Part 3: Real-World Latency Test

### Keypress to Audio Callback

```javascript
// latency-test.mjs
import { recordSample, analyzeSamples, getPercentile } from './latency-struct-array.mjs';

/**
 * Measure keypress → audio latency
 */
export async function runLatencyTest(audioBackend) {
  return new Promise((resolve) => {
    let testCount = 0;
    
    document.addEventListener('keydown', async (e) => {
      if (testCount >= 1000) return;
      
      const keypressTime = performance.now();
      
      // Simulate audio callback delay
      const timestamp = performance.now();
      const audioTime = await triggerSound(audioBackend);
      
      recordSample(timestamp, keypressTime, audioTime);
      testCount++;
      
      if (testCount >= 1000) {
        const stats = analyzeSamples();
        stats.p50 = getPercentile(50);
        stats.p95 = getPercentile(95);
        stats.p99 = getPercentile(99);
        resolve(stats);
      }
    });
  });
}
```

---

## Part 4: Profiler Visualizer

### Latency Heatmap

```javascript
/**
 * Render latency heatmap - each sample is a pixel
 * @param {CanvasRenderingContext2D} ctx
 */
export function renderLatencyHeatmap(ctx) {
  const width = ctx.canvas.width;
  const height = ctx.canvas.height;
  const pixelsPerSample = Math.floor(width / sampleCount);
  
  for (let i = 0; i < sampleCount; i++) {
    const offset = i * SAMPLE_SIZE;
    const latency = samples[offset + 2] - samples[offset + 1];
    
    // Color: green (fast) → red (slow)
    const normalizedLatency = (latency - 0) / (50 - 0); // 0-50ms range
    const hue = (1 - normalizedLatency) * 120; // 120=green, 0=red
    
    ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
    ctx.fillRect(
      i * pixelsPerSample,
      0,
      pixelsPerSample,
      height
    );
  }
}

/**
 * Render distribution curve
 * @param {CanvasRenderingContext2D} ctx
 */
export function renderDistributionCurve(ctx) {
  const buckets = new Array(100).fill(0);
  
  for (let i = 0; i < sampleCount; i++) {
    const offset = i * SAMPLE_SIZE;
    const latency = samples[offset + 2] - samples[offset + 1];
    const bucket = Math.floor(latency); // 1ms buckets
    if (bucket < buckets.length) buckets[bucket]++;
  }
  
  const maxCount = Math.max(...buckets);
  const width = ctx.canvas.width;
  const height = ctx.canvas.height;
  
  ctx.beginPath();
  buckets.forEach((count, ms) => {
    const x = (ms / buckets.length) * width;
    const y = height - (count / maxCount) * height;
    ms === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
  });
  ctx.strokeStyle = '#0f0';
  ctx.stroke();
}
```

---

## Part 5: Backend Comparison

### Compare Multiple Backends

```javascript
/**
 * Compare X11, Web Audio, WebSocket latencies
 */
export async function compareLatencies() {
  const tests = [
    { name: 'X11', backend: x11Backend },
    { name: 'Web Audio', backend: webAudioBackend },
    { name: 'WebSocket', backend: websocketBackend }
  ];
  
  for (const test of tests) {
    console.log(`Testing ${test.name}...`);
    const stats = await runLatencyTest(test.backend);
    console.log(`  Avg: ${stats.avgLatency.toFixed(2)}ms`);
    console.log(`  P50: ${stats.p50.toFixed(2)}ms`);
    console.log(`  P95: ${stats.p95.toFixed(2)}ms`);
    console.log(`  P99: ${stats.p99.toFixed(2)}ms`);
  }
}
```

---

## Self-Assessment

- [ ] Understand SoA vs AoS tradeoffs
- [ ] Can implement flat array pattern
- [ ] Can measure and visualize latency
- [ ] Can calculate percentiles from data

**Next: L10.8 - State Machine as Transition Table**
