# L10.8: State Machine as Transition Table

## Core Concept
Your init cascade as **array of structs** with function pointers. Logic becomes data.

## State Machine Pattern

```javascript
/** State IDs */
const STATE = {
  INIT: 0,
  TRY_ALSA_DLOPEN: 1,
  TRY_ALSA_INIT: 2,
  ALSA_SUCCESS: 3,
  TRY_PULSE: 4,
  PULSE_SUCCESS: 5,
  TRY_NULL: 6,
  NULL_SUCCESS: 7,
  FAILED: -1
};

/** @type {Transition[]} */
const transitions = [
  { fromState: STATE.INIT, condition: 0, toState: STATE.TRY_ALSA_DLOPEN, label: 'start' },
  { fromState: STATE.TRY_ALSA_DLOPEN, condition: 0, toState: STATE.TRY_ALSA_INIT, label: 'dlopen success' },
  { fromState: STATE.TRY_ALSA_DLOPEN, condition: -1, toState: STATE.TRY_PULSE, label: 'dlopen failed' },
  // ...
];

function getNextState(currentState, result) {
  const condition = result === 0 ? 0 : -1;
  return transitions.find(t => t.fromState === currentState && t.condition === condition)?.toState;
}
```

**Key Principle:** The state machine is **data you interpret**, not code you execute.

**Next: L10.9 - Spatial Audio (ECS)**
