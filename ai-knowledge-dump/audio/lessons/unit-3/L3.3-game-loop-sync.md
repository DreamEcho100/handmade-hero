# Unit 3, Lesson 3: Synchronizing Audio with Game Loop

> **Learning Goal:** Integrate ALSA pull system into game loop correctly  
> **Time Estimate:** 45-60 minutes  
> **Prerequisite:** L3.2 (avail and delay)

---

## üéØ The Mystery You're Solving

Where EXACTLY in the game loop should audio go?

```c
// Option 1: Audio at START of frame
void game_loop() {
  while (running) {
    handle_audio();    // ‚Üê Here?
    process_input();
    update_game();
    render_frame();
  }
}

// Option 2: Audio at END of frame
void game_loop() {
  while (running) {
    process_input();
    update_game();
    render_frame();
    handle_audio();    // ‚Üê Or here?
  }
}

// Option 3: Audio PARALLEL with game
void game_loop() {
  spawn_audio_thread();  // ‚Üê Or separate thread?
  while (running) {
    process_input();
    update_game();
    render_frame();
  }
}
```

**Questions:**
- Why does Casey put audio FIRST in the loop?
- Should audio run on a separate thread?
- How to handle variable frame times?
- What if audio generation takes too long?

---

## üìö Core Concepts

### 1. Casey's Game Loop Structure (Day 19)

**The complete pattern:**

```c
void linux_game_loop() {
  uint64_t last_counter = get_wall_clock();
  
  while (running) {
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PHASE 1: AUDIO (highest priority)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    snd_pcm_sframes_t frames_to_write = SndPcmAvail(sound.handle);
    
    if (frames_to_write > 0) {
      // Generate audio for THIS frame
      fill_sound_buffer(&sound, frames_to_write);
      
      // Write immediately (blocking if needed)
      SndPcmWritei(sound.handle, sound.buffer, frames_to_write);
    } else if (frames_to_write < 0) {
      // Recover from underrun
      SndPcmRecover(sound.handle, frames_to_write, 1);
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PHASE 2: INPUT (low latency)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    XEvent event;
    while (XPending(display)) {
      XNextEvent(display, &event);
      handle_event(&event);
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PHASE 3: GAME LOGIC (can take time)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    uint64_t current_counter = get_wall_clock();
    float dt = (current_counter - last_counter) / 1e9;
    last_counter = current_counter;
    
    update_game(dt);
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PHASE 4: RENDERING (can take time)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    render_frame(&backbuffer);
    present_frame(&backbuffer);
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PHASE 5: FRAME LIMITING (optional)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // VSync or sleep here
  }
}
```

**Why this order?**

```
Priority ranking:
1. Audio    (33ms buffer = can't miss writes)
2. Input    (player expects <10ms response)
3. Game     (can vary 10-50ms, player won't notice)
4. Render   (can drop frames, player tolerates)

Critical path:
Audio MUST finish ‚Üí Input can wait ‚Üí Game can wait ‚Üí Render can wait
```

---

### 2. Why Audio First?

**Problem with audio LAST:**

```c
void game_loop() {
  while (running) {
    process_input();      // 1ms
    update_game();        // Could spike to 50ms! (loading)
    render_frame();       // Could spike to 30ms! (complex scene)
    handle_audio();       // ‚ùå Now we're late! Underrun!
  }
}

Timeline:
Frame 0:  [Input][Game][Render][Audio ‚ùå UNDERRUN!]
          0ms    1ms   51ms     81ms
          
By the time we get to audio, ALSA buffer is empty!
```

**Solution: Audio FIRST:**

```c
void game_loop() {
  while (running) {
    handle_audio();       // ‚úÖ Takes <1ms, done immediately
    process_input();      // Now we have time...
    update_game();        // ...for game logic to vary...
    render_frame();       // ...and rendering to spike
  }
}

Timeline:
Frame 0:  [Audio ‚úÖ][Input][Game][Render]
          0-1ms     1-2ms  2-52ms 52-82ms
          
Audio is safe in buffer before game logic even starts!
```

---

### 3. Handling Variable Frame Times

**The PULL system adapts automatically:**

```c
// Frame 0 (16.67ms at 60 FPS):
snd_pcm_sframes_t frames = SndPcmAvail(handle);
// Returns: ~800 frames (16.67ms worth)
generate_audio(buffer, frames);
SndPcmWritei(handle, buffer, frames);

// Frame 1 (50ms - SLOW frame, loading asset):
frames = SndPcmAvail(handle);
// Returns: ~2400 frames (50ms worth) ‚Üê Automatically more!
generate_audio(buffer, frames);
SndPcmWritei(handle, buffer, frames);

// Frame 2 (8ms - FAST frame, nothing happening):
frames = SndPcmAvail(handle);
// Returns: ~400 frames (8ms worth) ‚Üê Automatically less!
generate_audio(buffer, frames);
SndPcmWritei(handle, buffer, frames);
```

**No matter the frame time, audio stays continuous!**

---

### 4. Thread vs No Thread

**Option A: Audio on same thread (Casey's choice)**

```c
// Pros:
// ‚úÖ Simple (no threading complexity)
// ‚úÖ No race conditions
// ‚úÖ Deterministic timing
// ‚úÖ Easy to debug

// Cons:
// ‚ùå Audio generation blocks game loop
// ‚ùå If game hangs, audio stops

void game_loop() {
  while (running) {
    handle_audio();  // Same thread
    update_game();
  }
}
```

**Option B: Audio on separate thread**

```c
// Pros:
// ‚úÖ Audio never blocks game
// ‚úÖ Can survive game stutters

// Cons:
// ‚ùå Complex (mutexes, atomics)
// ‚ùå Race conditions possible
// ‚ùå Harder to debug
// ‚ùå Need lock-free ring buffer

void audio_thread() {
  while (running) {
    frames = SndPcmAvail(handle);
    generate_audio(buffer, frames);
    SndPcmWritei(handle, buffer, frames);
    sleep_ms(10);
  }
}

void game_loop() {
  spawn_thread(audio_thread);
  while (running) {
    update_game();
  }
}
```

**Casey's philosophy:**
> "Don't use threads unless you NEED to. Audio generation is fast (<1ms), so blocking game loop is fine."

**When to use separate thread:**
- Audio DSP is expensive (>5ms)
- Need real-time guarantee (pro audio apps)
- Game frequently hangs for >100ms

**For Handmade Hero:**
- Audio generation < 1ms ‚úÖ
- Game loop stable ~16ms ‚úÖ
- No thread needed ‚úÖ

---

### 5. Dealing with dt (Delta Time)

**Audio needs SAMPLES, not TIME:**

```c
// WRONG: Using dt for audio
void handle_audio(float dt) {
  int frames = (int)(48000 * dt);  // If dt=0.016, frames=768
  generate_audio(buffer, frames);
  SndPcmWritei(handle, buffer, frames);
  
  // Problem: What if dt is inaccurate?
  // Problem: What if ALSA needs different amount?
}

// RIGHT: Using snd_pcm_avail()
void handle_audio() {
  int frames = SndPcmAvail(handle);  // Ask ALSA directly!
  if (frames > 0) {
    generate_audio(buffer, frames);
    SndPcmWritei(handle, buffer, frames);
  }
}
```

**Why avail is better than dt:**
- **Accurate:** ALSA knows exactly what it needs
- **Adaptive:** Handles clock drift, timing jitter
- **Robust:** No assumptions about frame rate

---

### 6. Pseudo-Code Pattern

**Complete integration:**

```c
typedef struct {
  snd_pcm_t *handle;
  int16_t *buffer;
  int buffer_size;
  int channels;
  int samples_per_second;
} AudioOutput;

void fill_sound_buffer(AudioOutput *audio, int frames_to_write) {
  int sample_count = frames_to_write * audio->channels;
  int16_t *samples = audio->buffer;
  
  // Generate audio content (from game state)
  for (int i = 0; i < sample_count; i += audio->channels) {
    // Left channel
    samples[i] = generate_sample();
    // Right channel
    samples[i + 1] = generate_sample();
  }
}

void linux_game_loop() {
  AudioOutput audio = {0};
  // ... initialize audio ...
  
  bool running = true;
  while (running) {
    // ‚ïê‚ïê‚ïê AUDIO FIRST ‚ïê‚ïê‚ïê
    snd_pcm_sframes_t frames_to_write = SndPcmAvail(audio.handle);
    
    if (frames_to_write > 0) {
      // Generate exactly what ALSA needs
      fill_sound_buffer(&audio, frames_to_write);
      
      // Write to ALSA
      long written = SndPcmWritei(audio.handle, audio.buffer, frames_to_write);
      
      if (written < 0) {
        printf("Write error: %s\n", SndStrerror(written));
        SndPcmRecover(audio.handle, written, 1);
      }
    } else if (frames_to_write == 0) {
      // Buffer full (rare, game is super fast)
      // Skip audio this frame
    } else {
      // Error (underrun)
      SndPcmRecover(audio.handle, frames_to_write, 1);
    }
    
    // ‚ïê‚ïê‚ïê REST OF GAME ‚ïê‚ïê‚ïê
    handle_input();
    update_game();
    render_frame();
  }
}
```

---

## üß™ Hands-On Exercises

### Exercise 1: Measure Audio Time

Create `measure_audio_cost.c`:
```c
#include <alsa/asoundlib.h>
#include <stdio.h>
#include <time.h>
#include <math.h>

double get_time_ns() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return ts.tv_sec * 1e9 + ts.tv_nsec;
}

void generate_audio(int16_t *buffer, int frames) {
  // Simulate game audio generation
  for (int i = 0; i < frames * 2; i++) {
    float t = i / 48000.0;
    buffer[i] = (int16_t)(sin(2 * M_PI * 440 * t) * 10000);
  }
}

int main() {
  snd_pcm_t *handle;
  snd_pcm_open(&handle, "default", SND_PCM_STREAM_PLAYBACK, 0);
  snd_pcm_set_params(handle, SND_PCM_FORMAT_S16_LE,
                     SND_PCM_ACCESS_RW_INTERLEAVED,
                     2, 48000, 1, 50000);
  
  int16_t buffer[4800 * 2];  // Max 100ms
  
  printf("Measuring audio processing cost:\n\n");
  
  double total_audio_time = 0;
  int frame_count = 0;
  
  for (int frame = 0; frame < 60; frame++) {
    // Measure audio phase
    double start = get_time_ns();
    
    snd_pcm_sframes_t frames = snd_pcm_avail(handle);
    if (frames > 0) {
      generate_audio(buffer, frames);
      snd_pcm_writei(handle, buffer, frames);
    }
    
    double end = get_time_ns();
    double audio_time_ms = (end - start) / 1e6;
    total_audio_time += audio_time_ms;
    frame_count++;
    
    if (frame % 10 == 0) {
      printf("Frame %2d: Audio took %.3f ms\n", frame, audio_time_ms);
    }
    
    usleep(16000);  // 16ms game frame
  }
  
  printf("\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
  printf("Average audio cost: %.3f ms/frame\n", total_audio_time / frame_count);
  printf("Percentage of 16ms frame: %.1f%%\n",
         (total_audio_time / frame_count / 16.0) * 100);
  
  snd_pcm_close(handle);
  return 0;
}
```

**Expected output:**
```
Average audio cost: 0.123 ms/frame
Percentage of 16ms frame: 0.8%
```

**Takeaway:** Audio is CHEAP! Less than 1% of frame budget.

---

### Exercise 2: Simulate Variable Frame Times

Create `variable_frames.c`:
```c
#include <alsa/asoundlib.h>
#include <stdio.h>
#include <unistd.h>

int main() {
  snd_pcm_t *handle;
  snd_pcm_open(&handle, "default", SND_PCM_STREAM_PLAYBACK, 0);
  snd_pcm_set_params(handle, SND_PCM_FORMAT_S16_LE,
                     SND_PCM_ACCESS_RW_INTERLEAVED,
                     2, 48000, 1, 50000);
  
  int16_t buffer[4800 * 2];
  
  printf("Testing pull system with variable frame times:\n\n");
  
  int frame_times_ms[] = {16, 16, 50, 16, 100, 16, 8, 16, 32, 16};
  
  for (int i = 0; i < 10; i++) {
    int ft = frame_times_ms[i];
    
    // Audio first (pull system)
    snd_pcm_sframes_t frames = snd_pcm_avail(handle);
    
    printf("Frame %d (%3dms): ALSA needs %5ld frames ‚Üí ",
           i, ft, frames);
    
    if (frames > 0) {
      snd_pcm_writei(handle, buffer, frames);
      printf("‚úÖ Wrote %ld frames\n", frames);
    }
    
    // Simulate variable game frame time
    usleep(ft * 1000);
  }
  
  printf("\n‚úÖ All frames handled correctly!\n");
  
  snd_pcm_close(handle);
  return 0;
}
```

---

### Exercise 3: Compare Audio-First vs Audio-Last

Create `ordering_test.c`:
```c
#include <alsa/asoundlib.h>
#include <stdio.h>
#include <unistd.h>

snd_pcm_t *handle;
int16_t buffer[4800 * 2];

void simulate_game_logic() {
  usleep(10000);  // 10ms game logic
}

void simulate_slow_frame() {
  usleep(50000);  // 50ms spike (loading asset)
}

void test_audio_first() {
  printf("\n=== Audio FIRST (Casey's way) ===\n");
  
  for (int i = 0; i < 5; i++) {
    // Audio first
    snd_pcm_sframes_t frames = snd_pcm_avail(handle);
    if (frames > 0) {
      snd_pcm_writei(handle, buffer, frames);
      printf("Frame %d: Wrote %ld frames\n", i, frames);
    }
    
    // Then game logic
    if (i == 2) simulate_slow_frame();
    else simulate_game_logic();
  }
  
  snd_pcm_sframes_t delay;
  snd_pcm_delay(handle, &delay);
  printf("Final buffer state: %ld frames queued\n", delay);
}

void test_audio_last() {
  printf("\n=== Audio LAST (wrong way) ===\n");
  
  // Reset ALSA
  snd_pcm_drop(handle);
  snd_pcm_prepare(handle);
  
  for (int i = 0; i < 5; i++) {
    // Game logic first
    if (i == 2) simulate_slow_frame();
    else simulate_game_logic();
    
    // Then audio
    snd_pcm_sframes_t frames = snd_pcm_avail(handle);
    if (frames < 0) {
      printf("Frame %d: ‚ùå UNDERRUN! (%s)\n", i, snd_strerror(frames));
      snd_pcm_recover(handle, frames, 1);
    } else {
      snd_pcm_writei(handle, buffer, frames);
      printf("Frame %d: Wrote %ld frames\n", i, frames);
    }
  }
  
  snd_pcm_sframes_t delay;
  snd_pcm_delay(handle, &delay);
  printf("Final buffer state: %ld frames queued\n", delay);
}

int main() {
  snd_pcm_open(&handle, "default", SND_PCM_STREAM_PLAYBACK, 0);
  snd_pcm_set_params(handle, SND_PCM_FORMAT_S16_LE,
                     SND_PCM_ACCESS_RW_INTERLEAVED,
                     2, 48000, 1, 30000);  // Small buffer
  
  test_audio_first();
  test_audio_last();
  
  snd_pcm_close(handle);
  return 0;
}
```

---

### Exercise 4: Implement in Your Game

**Modify `backend.c` to use audio-first pattern:**

```c
void linux_game_loop(LinuxGameState *state) {
  bool running = true;
  uint64_t last_counter = linux_get_wall_clock();
  
  while (running) {
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PHASE 1: AUDIO (do this FIRST!)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    snd_pcm_sframes_t frames_to_write = 
        SndPcmAvail(state->sound_output.handle);
    
    if (frames_to_write > 0) {
      linux_fill_sound_buffer(&state->sound_output, frames_to_write);
      
      long written = SndPcmWritei(state->sound_output.handle,
                                  state->sound_output.sample_buffer.base,
                                  frames_to_write);
      
      if (written < 0) {
        SndPcmRecover(state->sound_output.handle, written, 1);
      }
    } else if (frames_to_write < 0) {
      SndPcmRecover(state->sound_output.handle, frames_to_write, 1);
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PHASE 2-4: Game logic, rendering, etc.
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    linux_process_events(state);
    
    uint64_t current_counter = linux_get_wall_clock();
    float dt = (current_counter - last_counter) / 1e9f;
    last_counter = current_counter;
    
    game_update_and_render(&state->game_memory, dt);
    linux_display_buffer_in_window(&state->backbuffer);
  }
}
```

---

## üéì Comprehension Check

1. **Awareness:** Why does Casey put audio FIRST in game loop?

2. **Comprehension:** What happens if audio is LAST and game stutters?

3. **Application:** Add audio-first pattern to your own game loop.

4. **Analysis:** Your audio takes 5ms to generate. Still safe to do on main thread?

5. **Synthesis:** Design game loop for VR game (needs <11ms total frame time).

6. **Evaluation:** When SHOULD you use a separate audio thread?

---

## üîó Connection to Next Lesson

**L3.4: Handling Underruns**
- You know how to write audio correctly
- Next: What if something goes WRONG?
- How to detect underruns?
- How to recover gracefully?

---

**When ready, move to L3.4!** ‚úÖ
