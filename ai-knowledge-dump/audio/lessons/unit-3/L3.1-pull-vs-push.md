# Unit 3, Lesson 1: Pull vs Push Audio Architecture

> **Learning Goal:** Understand Casey's "pull system" and why it's better than "push"  
> **Time Estimate:** 45-60 minutes  
> **Prerequisite:** Unit 2 Complete (ALSA Architecture)

---

## ğŸ¯ The Mystery You're Solving

Two fundamentally different ways to handle audio in a game:

```c
// PUSH system (naive):
void game_loop() {
  while (running) {
    update_game();
    render_frame();
    
    // Generate audio and push it out
    generate_audio(buffer, FIXED_SIZE);
    snd_pcm_writei(handle, buffer, FIXED_SIZE);  // Hope it fits!
  }
}

// PULL system (Casey's Day 19):
void game_loop() {
  while (running) {
    // ASK how much audio ALSA needs
    snd_pcm_sframes_t frames_to_write = snd_pcm_avail();
    
    // Generate EXACTLY that much
    generate_audio(buffer, frames_to_write);
    snd_pcm_writei(handle, buffer, frames_to_write);
    
    update_game();
    render_frame();
  }
}
```

**Questions:**
- What's the difference between "push" and "pull"?
- Why does Casey check `snd_pcm_avail()` before writing?
- What happens if you push too much audio?
- What happens if you push too little?

---

## ğŸ“š Core Concepts

### 1. Push System (Traditional Game Audio)

**How it works:**
```c
void game_loop() {
  while (running) {
    // 1. Update game logic
    update_game(dt);
    
    // 2. Render frame
    render_frame();
    
    // 3. Generate fixed amount of audio
    int samples = 1024;  // Always generate 1024 samples
    generate_audio(audio_buffer, samples);
    
    // 4. PUSH it to audio system
    snd_pcm_writei(handle, audio_buffer, samples);
    //              ^--- Might block if buffer full!
    //                   Might underrun if too small!
  }
}
```

**Problems with push:**

```
Frame 0 (16.67ms at 60 FPS):
  Game runs normally
  Generate 1024 samples â†’ ALSA accepts
  
Frame 1 (16.67ms):
  Game runs normally
  Generate 1024 samples â†’ ALSA accepts
  
Frame 2 (50ms - SLOW FRAME! Loading asset):
  Game stutters
  Still generate 1024 samples â†’ ALSA accepts
  But 50ms passed, ALSA consumed 2400 samples!
  Buffer underrun! (1024 < 2400)
  
Frame 3 (16.67ms - back to normal):
  Game runs fast
  Generate 1024 samples â†’ But buffer already empty
  Underrun continues...
```

**The fundamental issue:**
- Push assumes CONSTANT frame rate
- Real games have VARIABLE frame times
- Fixed audio chunks don't adapt to timing variance

---

### 2. Pull System (Casey's Innovation)

**How it works:**
```c
void game_loop() {
  while (running) {
    // 1. ASK ALSA: "How much audio do you need?"
    snd_pcm_sframes_t frames_to_write = snd_pcm_avail(handle);
    
    // 2. Generate EXACTLY that amount
    if (frames_to_write > 0) {
      generate_audio(audio_buffer, frames_to_write);
      snd_pcm_writei(handle, audio_buffer, frames_to_write);
    }
    
    // 3. Update game logic
    update_game(dt);
    
    // 4. Render frame
    render_frame();
  }
}
```

**Why pull is better:**

```
Frame 0 (16.67ms at 60 FPS):
  ALSA needs: 800 samples (16.67ms worth)
  Generate: 800 samples âœ… Perfect fit
  
Frame 1 (16.67ms):
  ALSA needs: 800 samples
  Generate: 800 samples âœ… Perfect fit
  
Frame 2 (50ms - SLOW FRAME!):
  ALSA needs: 2400 samples (50ms worth)
  Generate: 2400 samples âœ… Automatically adapts!
  
Frame 3 (16.67ms - back to normal):
  ALSA needs: 800 samples
  Generate: 800 samples âœ… No underrun!
```

**Key advantage:**
- Audio generation ADAPTS to actual frame time
- No underruns even with frame rate variance
- No need to predict timing

---

### 3. How `snd_pcm_avail()` Works

**What it returns:**
```c
snd_pcm_sframes_t snd_pcm_avail(snd_pcm_t *handle);
// Returns: Number of frames available to write (free space in buffer)
```

**Internal logic:**

```
ALSA Ring Buffer (2400 frames total):

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ [][][][][]            [][][]    â”‚  â† Buffer state
â”‚  ^                    ^          â”‚
â”‚  Play cursor          Write cursor
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

avail = buffer_size - (write_pos - play_pos) % buffer_size
      = 2400 - delay
      
If delay = 1200 (1200 frames queued):
  avail = 2400 - 1200 = 1200 frames free âœ…
  
If delay = 100 (buffer almost empty):
  avail = 2400 - 100 = 2300 frames free âš ï¸ Write soon!
  
If delay = 2400 (buffer full):
  avail = 0 frames free âŒ Can't write yet
```

**Example usage:**

```c
snd_pcm_sframes_t avail = snd_pcm_avail(handle);

if (avail < 0) {
  // Error (buffer xrun)
  printf("ALSA error: %s\n", snd_strerror(avail));
  snd_pcm_recover(handle, avail, 1);
} else if (avail > 0) {
  // Normal case: Generate and write
  int16_t buffer[avail * 2];  // *2 for stereo
  generate_audio(buffer, avail);
  snd_pcm_writei(handle, buffer, avail);
} else {
  // avail == 0: Buffer full, skip audio this frame
  // (Happens rarely, only if game is VERY fast)
}
```

---

### 4. The "Audio First" Pattern

**Casey's ordering (from Day 19):**

```c
void game_loop() {
  while (running) {
    // 1. AUDIO FIRST (before game logic)
    snd_pcm_sframes_t frames_to_write = snd_pcm_avail(handle);
    if (frames_to_write > 0) {
      generate_audio(buffer, frames_to_write);
      snd_pcm_writei(handle, buffer, frames_to_write);
    }
    
    // 2. THEN game logic
    update_game(dt);
    
    // 3. THEN rendering
    render_frame();
    
    // Why this order?
    // - Audio needs CONSISTENT timing (more critical than visuals)
    // - Do audio before game logic can slow frame
    // - Ensures audio buffer always has data
  }
}
```

**Why audio first?**

```
Bad order (game logic first):
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Update game â”‚ â† Could take 50ms if loading
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Generate    â”‚ â† Now you're late!
  â”‚ audio       â”‚   ALSA buffer empty = underrun
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Good order (audio first):
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Generate    â”‚ â† Takes <1ms, ALSA filled immediately
  â”‚ audio       â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Update game â”‚ â† Can take as long as needed
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   Audio already safe in buffer
```

---

### 5. Comparison Table

| Aspect | Push System | Pull System (Casey) |
|--------|-------------|---------------------|
| **Audio amount** | Fixed (e.g., 1024 samples) | Variable (matches need) |
| **Frame variance** | Causes underruns | Handles gracefully |
| **Complexity** | Simple | Slightly more complex |
| **Buffer management** | Manual (guess size) | Automatic (query size) |
| **Timing dependency** | Assumes constant FPS | Adapts to any FPS |
| **Example** | Most old games | Handmade Hero, modern engines |

**Web Dev Analogy:**

```javascript
// PUSH (traditional):
setInterval(() => {
  const data = generateData(FIXED_SIZE);
  socket.send(data);  // Hope socket has room!
}, 16);  // Assume 60 FPS

// PULL (Casey's way):
socket.on('drain', () => {
  const neededBytes = socket.writableLength;
  const data = generateData(neededBytes);
  socket.write(data);  // Exactly what's needed
});
```

---

## ğŸ§ª Hands-On Exercises

### Exercise 1: Compare Push vs Pull

Create `push_vs_pull.c`:
```c
#include <alsa/asoundlib.h>
#include <stdio.h>
#include <math.h>
#include <unistd.h>

snd_pcm_t *handle;

// PUSH approach (fixed size)
void test_push() {
  printf("\n=== Testing PUSH system ===\n");
  
  int16_t buffer[1024 * 2];  // Fixed 1024 frames
  
  for (int frame = 0; frame < 10; frame++) {
    // Simulate variable frame time
    if (frame == 5) {
      printf("Frame %d: Simulating slow frame (50ms)...\n", frame);
      usleep(50000);  // 50ms delay
    }
    
    // Always write same amount (PUSH)
    printf("Frame %d: Pushing 1024 frames...\n", frame);
    long written = snd_pcm_writei(handle, buffer, 1024);
    
    if (written < 0) {
      printf("  âŒ Error: %s\n", snd_strerror(written));
      snd_pcm_recover(handle, written, 1);
    }
    
    usleep(16000);  // Normal 16ms frame
  }
}

// PULL approach (query first)
void test_pull() {
  printf("\n=== Testing PULL system ===\n");
  
  int16_t buffer[4800 * 2];  // Large enough for any frame
  
  for (int frame = 0; frame < 10; frame++) {
    // Simulate variable frame time
    if (frame == 5) {
      printf("Frame %d: Simulating slow frame (50ms)...\n", frame);
      usleep(50000);
    }
    
    // Query how much to write (PULL)
    snd_pcm_sframes_t avail = snd_pcm_avail(handle);
    printf("Frame %d: ALSA needs %ld frames...\n", frame, avail);
    
    if (avail > 0) {
      long written = snd_pcm_writei(handle, buffer, avail);
      printf("  âœ… Wrote %ld frames\n", written);
    }
    
    usleep(16000);
  }
}

int main() {
  // Setup ALSA
  snd_pcm_open(&handle, "default", SND_PCM_STREAM_PLAYBACK, 0);
  snd_pcm_set_params(handle, SND_PCM_FORMAT_S16_LE,
                     SND_PCM_ACCESS_RW_INTERLEAVED,
                     2, 48000, 1, 50000);
  
  test_push();
  
  // Reset
  snd_pcm_drop(handle);
  snd_pcm_prepare(handle);
  
  test_pull();
  
  snd_pcm_close(handle);
  return 0;
}
```

**Compile and run:**
```bash
gcc -o push_vs_pull push_vs_pull.c -lasound -lm
./push_vs_pull
```

**Observe:**
- Push system: Likely underruns at frame 5
- Pull system: Adapts smoothly

---

### Exercise 2: Visualize Buffer Fill

Create `buffer_fill_viz.c`:
```c
#include <alsa/asoundlib.h>
#include <stdio.h>

void print_buffer_state(snd_pcm_t *handle, int frame) {
  snd_pcm_sframes_t avail = snd_pcm_avail(handle);
  snd_pcm_sframes_t delay;
  snd_pcm_delay(handle, &delay);
  
  snd_pcm_uframes_t buffer_size;
  snd_pcm_get_params(handle, &buffer_size, NULL);
  
  // Visual bar
  printf("Frame %2d: [", frame);
  int filled = (delay * 50) / buffer_size;
  for (int i = 0; i < 50; i++) {
    printf(i < filled ? "â–ˆ" : "â–‘");
  }
  printf("] %ld/%ld frames\n", delay, buffer_size);
}

int main() {
  snd_pcm_t *handle;
  snd_pcm_open(&handle, "default", SND_PCM_STREAM_PLAYBACK, 0);
  snd_pcm_set_params(handle, SND_PCM_FORMAT_S16_LE,
                     SND_PCM_ACCESS_RW_INTERLEAVED,
                     2, 48000, 1, 50000);
  
  int16_t buffer[800 * 2];  // 16.67ms at 48kHz
  
  printf("Monitoring buffer fill with PULL system:\n\n");
  
  for (int frame = 0; frame < 20; frame++) {
    // PULL: Query and write
    snd_pcm_sframes_t avail = snd_pcm_avail(handle);
    if (avail > 800) avail = 800;  // Write one frame's worth
    
    if (avail > 0) {
      snd_pcm_writei(handle, buffer, avail);
    }
    
    print_buffer_state(handle, frame);
    usleep(16000);  // 16ms
  }
  
  snd_pcm_close(handle);
  return 0;
}
```

---

### Exercise 3: Implement Pull System

**Modify your game loop to use pull:**

```c
// In your main game loop (backend.c)
void linux_game_loop() {
  bool running = true;
  
  while (running) {
    // PULL SYSTEM: Audio first
    snd_pcm_sframes_t frames_to_write = SndPcmAvail(sound_output.handle);
    
    if (frames_to_write > 0) {
      // Generate exactly what ALSA needs
      int samples_to_write = frames_to_write * sound_output.channels;
      
      // Fill audio buffer with game audio
      linux_fill_sound_buffer(&sound_output, samples_to_write);
      
      // Write to ALSA
      SndPcmWritei(sound_output.handle,
                   sound_output.sample_buffer.base,
                   frames_to_write);
    } else if (frames_to_write < 0) {
      // Handle error (underrun/overrun)
      printf("ALSA error: %s\n", SndStrerror(frames_to_write));
      SndPcmRecover(sound_output.handle, frames_to_write, 1);
    }
    
    // Then game logic and rendering
    handle_events();
    update_game(dt);
    render_frame();
  }
}
```

---

### Exercise 4: Measure Adaptation

Create `frame_variance_test.c`:
```c
#include <alsa/asoundlib.h>
#include <stdio.h>
#include <unistd.h>

int main() {
  snd_pcm_t *handle;
  snd_pcm_open(&handle, "default", SND_PCM_STREAM_PLAYBACK, 0);
  snd_pcm_set_params(handle, SND_PCM_FORMAT_S16_LE,
                     SND_PCM_ACCESS_RW_INTERLEAVED,
                     2, 48000, 1, 50000);
  
  int16_t buffer[4800 * 2];  // Max 100ms
  
  printf("Simulating variable frame times:\n\n");
  
  int frame_times_ms[] = {16, 16, 50, 16, 100, 16, 16, 8, 16};
  
  for (int i = 0; i < 9; i++) {
    int ft = frame_times_ms[i];
    
    // PULL: Query available
    snd_pcm_sframes_t avail = snd_pcm_avail(handle);
    
    printf("Frame time: %3dms â†’ ALSA needs: %5ld frames (%.1f ms)\n",
           ft, avail, avail / 48.0);
    
    if (avail > 0) {
      snd_pcm_writei(handle, buffer, avail);
    }
    
    usleep(ft * 1000);
  }
  
  printf("\nâœ… Pull system handled all frame time variance!\n");
  
  snd_pcm_close(handle);
  return 0;
}
```

---

## ğŸ“ Comprehension Check

**Before moving to L3.2, answer these:**

1. **Awareness:** What's the key difference between push and pull?

2. **Comprehension:** Why does pull handle frame variance better than push?

3. **Application:** Modify your game loop to use pull system.

4. **Analysis:** Your game runs at 60 FPS but stutters to 10 FPS for 1 second. How does pull system handle this?

5. **Synthesis:** Design a hybrid push/pull system. When would you use each?

6. **Evaluation:** Are there cases where push is better than pull?

---

## ğŸ”— Connection to Next Lesson

**L3.2: snd_pcm_avail() Deep Dive**
- You know pull queries available frames
- Next: HOW does snd_pcm_avail() calculate that number?
- What's the difference between avail and delay?
- When does avail return negative values?

---

## ğŸ“ Reflection Questions (Write in UNITS-TRACKER.md)

1. **Aha Moment:** When did the pull vs push distinction click?

2. **Code Insight:** How would you convert your current push to pull?

3. **Web Dev Connection:** Is this like event-driven vs polling?

4. **Design Choice:** Why does Casey prioritize audio over game logic?

---

**When ready, update UNITS-TRACKER.md and move to L3.2!** âœ…
