# Unit 3, Lesson 2: snd_pcm_avail() and snd_pcm_delay()

> **Learning Goal:** Master ALSA's buffer query functions and their differences  
> **Time Estimate:** 45-60 minutes  
> **Prerequisite:** L3.1 (Pull vs Push)

---

## üéØ The Mystery You're Solving

Two similar-sounding functions, VERY different purposes:

```c
// How much CAN I write?
snd_pcm_sframes_t avail = snd_pcm_avail(handle);

// How much is QUEUED (not yet played)?
snd_pcm_sframes_t delay = snd_pcm_delay(handle, &delay);
```

**Questions:**
- What's the difference between `avail` and `delay`?
- How are they related? (Hint: `avail + delay ‚âà buffer_size`)
- When do these functions return negative values?
- Why does Casey use `avail` instead of `delay`?

---

## üìö Core Concepts

### 1. The Three Key Numbers

**Every ALSA buffer has THREE important values:**

```c
// 1. BUFFER SIZE (constant, set during init)
snd_pcm_uframes_t buffer_size;
snd_pcm_get_params(handle, &buffer_size, NULL);
// Example: 2400 frames (50ms at 48kHz)

// 2. DELAY (frames queued, waiting to play)
snd_pcm_sframes_t delay;
snd_pcm_delay(handle, &delay);
// Example: 1200 frames (25ms of audio buffered)

// 3. AVAIL (free space, can write this much)
snd_pcm_sframes_t avail = snd_pcm_avail(handle);
// Example: 1200 frames (can write 25ms more)

// RELATIONSHIP:
// buffer_size = delay + avail (approximately)
// 2400 = 1200 + 1200 ‚úÖ
```

**Visual representation:**

```
ALSA Ring Buffer (2400 frames total):

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ [P][P][P][P][P][P]        [ ][ ][ ][ ]  ‚îÇ
‚îÇ  ^                 ^       ^             ‚îÇ
‚îÇ  Play              Write   End           ‚îÇ
‚îÇ  cursor            cursor  of buffer     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      DELAY (queued)         AVAIL (free)
      1200 frames            1200 frames
```

---

### 2. snd_pcm_avail() Deep Dive

**Function signature:**
```c
snd_pcm_sframes_t snd_pcm_avail(snd_pcm_t *pcm);
```

**What it returns:**
- **Positive value:** Frames available to write (free space)
- **Zero:** Buffer full (rare, means game is super fast)
- **Negative:** Error code (underrun/overrun)

**Internal calculation:**

```c
// Simplified ALSA internal logic:
snd_pcm_sframes_t snd_pcm_avail(snd_pcm_t *pcm) {
  // Get current hardware position
  snd_pcm_uframes_t hw_ptr = get_hardware_pointer();
  snd_pcm_uframes_t app_ptr = pcm->appl_ptr;
  
  snd_pcm_uframes_t buffer_size = pcm->buffer_size;
  
  // Calculate available space
  snd_pcm_sframes_t avail = buffer_size - (app_ptr - hw_ptr);
  
  // Handle wrap-around
  if (avail < 0) avail += buffer_size;
  
  return avail;
}
```

**When to use:**
```c
// PULL SYSTEM: Query before writing
snd_pcm_sframes_t frames_to_write = snd_pcm_avail(handle);

if (frames_to_write > 0) {
  generate_audio(buffer, frames_to_write);
  snd_pcm_writei(handle, buffer, frames_to_write);
} else if (frames_to_write == 0) {
  // Buffer full, skip this frame (rare)
} else {
  // Error! Handle underrun
  snd_pcm_recover(handle, frames_to_write, 1);
}
```

---

### 3. snd_pcm_delay() Deep Dive

**Function signature:**
```c
int snd_pcm_delay(snd_pcm_t *pcm, snd_pcm_sframes_t *delayp);
```

**What it returns:**
- **In `delayp`:** Frames queued (not yet played)
- **Return value:** 0 on success, negative on error

**What "delay" means:**

```c
snd_pcm_sframes_t delay;
snd_pcm_delay(handle, &delay);

// delay = Number of frames between "now" and what you'll hear
// Example: delay = 1200 frames = 25ms at 48kHz
//   ‚Üí Audio you write NOW will play 25ms from now
```

**Internal calculation:**

```c
// Simplified ALSA internal logic:
int snd_pcm_delay(snd_pcm_t *pcm, snd_pcm_sframes_t *delayp) {
  // Application pointer (where you've written to)
  snd_pcm_uframes_t app_ptr = pcm->appl_ptr;
  
  // Hardware pointer (where hardware is playing from)
  snd_pcm_uframes_t hw_ptr = get_hardware_pointer();
  
  // Delay = difference (with wrap-around handling)
  *delayp = (app_ptr - hw_ptr) % pcm->buffer_size;
  
  return 0;
}
```

**When to use:**
```c
// Measuring actual latency
snd_pcm_sframes_t delay;
snd_pcm_delay(handle, &delay);

float latency_ms = (delay / 48.0);  // At 48kHz
printf("Current latency: %.1f ms\n", latency_ms);

// Lip-sync (align video with audio)
if (delay < 800) {  // Less than 16ms buffered
  printf("Warning: Buffer running low!\n");
}

// NOT for deciding how much to write (use avail for that)
```

---

### 4. The Relationship: avail + delay ‚âà buffer_size

**Why "approximately" and not exactly?**

```c
// In theory:
avail + delay == buffer_size

// In practice:
avail + delay ‚âà buffer_size  // Might differ by 1-2 frames

// Why the difference?
// 1. Hardware pointer updates asynchronously
// 2. Period boundaries (ALSA updates in chunks)
// 3. DMA transfer timing
```

**Example measurements:**

```c
snd_pcm_uframes_t buffer_size = 2400;

// Frame 0:
snd_pcm_avail(handle);   // Returns: 2400 (empty buffer)
snd_pcm_delay(handle, &delay);  // delay: 0 (nothing queued)
// 2400 + 0 = 2400 ‚úÖ

// After writing 800 frames:
snd_pcm_avail(handle);   // Returns: 1600 (free space)
snd_pcm_delay(handle, &delay);  // delay: 800 (queued)
// 1600 + 800 = 2400 ‚úÖ

// After 10ms passes (hardware consumed 480 frames):
snd_pcm_avail(handle);   // Returns: 2080 (free space)
snd_pcm_delay(handle, &delay);  // delay: 320 (queued)
// 2080 + 320 = 2400 ‚úÖ
```

---

### 5. Error Handling: Negative Return Values

**Both functions can return errors:**

```c
// snd_pcm_avail() returns negative on error
snd_pcm_sframes_t avail = snd_pcm_avail(handle);
if (avail < 0) {
  switch (avail) {
    case -EPIPE:  // -32
      printf("UNDERRUN! (buffer empty)\n");
      break;
    case -ESTRPIPE:  // -86
      printf("SUSPEND! (system suspended)\n");
      break;
    default:
      printf("Error: %s\n", snd_strerror(avail));
  }
  
  snd_pcm_recover(handle, avail, 1);
}

// snd_pcm_delay() returns negative on error
snd_pcm_sframes_t delay;
int err = snd_pcm_delay(handle, &delay);
if (err < 0) {
  printf("Error getting delay: %s\n", snd_strerror(err));
  snd_pcm_recover(handle, err, 1);
}
```

**Common error codes:**

```c
-EPIPE    (-32)   // Underrun (read) or overrun (write)
-ESTRPIPE (-86)   // Stream suspended
-EBADFD   (-77)   // PCM not in right state
-ENOTTY   (-25)   // Inappropriate ioctl for device
```

---

### 6. Comparison Table

| Aspect | snd_pcm_avail() | snd_pcm_delay() |
|--------|-----------------|-----------------|
| **Purpose** | How much to write | How much queued |
| **Use case** | Pull system | Latency monitoring |
| **Returns** | Frames (or error) | Error code |
| **Output** | Return value | Via pointer param |
| **Frequency** | Every frame | Occasionally |
| **Casey uses** | ‚úÖ Yes (pull) | ‚ùå No (not needed) |

**Web Dev Analogy:**

```javascript
// snd_pcm_avail() = socket.writableLength
const socket = new WebSocket('ws://server');
const canWrite = socket.bufferedAmount;  // How much can I send?
if (canWrite < 1000) {
  socket.send(data);
}

// snd_pcm_delay() = network latency measurement
const pingStart = Date.now();
socket.send('ping');
socket.on('pong', () => {
  const latency = Date.now() - pingStart;  // How long to reach server?
  console.log(`Latency: ${latency}ms`);
});
```

---

## üß™ Hands-On Exercises

### Exercise 1: Monitor avail and delay

Create `monitor_buffer.c`:
```c
#include <alsa/asoundlib.h>
#include <stdio.h>
#include <unistd.h>

int main() {
  snd_pcm_t *handle;
  snd_pcm_open(&handle, "default", SND_PCM_STREAM_PLAYBACK, 0);
  snd_pcm_set_params(handle, SND_PCM_FORMAT_S16_LE,
                     SND_PCM_ACCESS_RW_INTERLEAVED,
                     2, 48000, 1, 50000);  // 50ms buffer
  
  snd_pcm_uframes_t buffer_size;
  snd_pcm_get_params(handle, &buffer_size, NULL);
  
  int16_t samples[800 * 2];  // 16.67ms worth
  
  printf("Buffer size: %lu frames\n\n", buffer_size);
  printf("Frame | Avail | Delay | Avail+Delay | Buffer %%\n");
  printf("------|-------|-------|-------------|----------\n");
  
  for (int i = 0; i < 15; i++) {
    // Query both values
    snd_pcm_sframes_t avail = snd_pcm_avail(handle);
    snd_pcm_sframes_t delay;
    snd_pcm_delay(handle, &delay);
    
    // Calculate percentage full
    int percent = (delay * 100) / buffer_size;
    
    printf("%5d | %5ld | %5ld | %11ld | %3d%%\n",
           i, avail, delay, avail + delay, percent);
    
    // Write audio
    if (avail > 800) {
      snd_pcm_writei(handle, samples, 800);
    }
    
    usleep(16000);  // 16ms
  }
  
  snd_pcm_close(handle);
  return 0;
}
```

**Expected output:**
```
Frame | Avail | Delay | Avail+Delay | Buffer %
------|-------|-------|-------------|----------
    0 |  2400 |     0 |        2400 |   0%
    1 |  1600 |   800 |        2400 |  33%
    2 |  1368 |  1032 |        2400 |  43%
    3 |  1136 |  1264 |        2400 |  53%
    ...
```

**Questions:**
1. Is `avail + delay` always exactly `buffer_size`?
2. What happens to `delay` over time?
3. When does `avail` decrease vs increase?

---

### Exercise 2: Test Relationship

Create `test_relationship.c`:
```c
#include <alsa/asoundlib.h>
#include <stdio.h>

int main() {
  snd_pcm_t *handle;
  snd_pcm_open(&handle, "default", SND_PCM_STREAM_PLAYBACK, 0);
  snd_pcm_set_params(handle, SND_PCM_FORMAT_S16_LE,
                     SND_PCM_ACCESS_RW_INTERLEAVED,
                     2, 48000, 1, 50000);
  
  snd_pcm_uframes_t buffer_size;
  snd_pcm_get_params(handle, &buffer_size, NULL);
  
  int16_t samples[2400 * 2];
  
  printf("Testing: avail + delay ‚âà buffer_size\n\n");
  
  // Test 1: Empty buffer
  snd_pcm_sframes_t avail = snd_pcm_avail(handle);
  snd_pcm_sframes_t delay;
  snd_pcm_delay(handle, &delay);
  
  printf("Empty buffer:\n");
  printf("  buffer_size: %lu\n", buffer_size);
  printf("  avail:       %ld\n", avail);
  printf("  delay:       %ld\n", delay);
  printf("  sum:         %ld\n", avail + delay);
  printf("  difference:  %ld frames\n\n", buffer_size - (avail + delay));
  
  // Test 2: Half full
  snd_pcm_writei(handle, samples, 1200);
  avail = snd_pcm_avail(handle);
  snd_pcm_delay(handle, &delay);
  
  printf("Half full:\n");
  printf("  avail:       %ld\n", avail);
  printf("  delay:       %ld\n", delay);
  printf("  sum:         %ld\n", avail + delay);
  printf("  difference:  %ld frames\n\n", buffer_size - (avail + delay));
  
  // Test 3: Almost full
  snd_pcm_writei(handle, samples, 1100);
  avail = snd_pcm_avail(handle);
  snd_pcm_delay(handle, &delay);
  
  printf("Almost full:\n");
  printf("  avail:       %ld\n", avail);
  printf("  delay:       %ld\n", delay);
  printf("  sum:         %ld\n", avail + delay);
  printf("  difference:  %ld frames\n", buffer_size - (avail + delay));
  
  snd_pcm_close(handle);
  return 0;
}
```

---

### Exercise 3: Latency Monitoring

Create `latency_monitor.c`:
```c
#include <alsa/asoundlib.h>
#include <stdio.h>
#include <unistd.h>

void print_latency_bar(float latency_ms) {
  printf("Latency: [");
  int bars = (int)(latency_ms / 2);  // 2ms per bar
  for (int i = 0; i < 25; i++) {
    if (i < bars) printf("‚ñà");
    else printf("‚ñë");
  }
  printf("] %.1f ms\n", latency_ms);
}

int main() {
  snd_pcm_t *handle;
  snd_pcm_open(&handle, "default", SND_PCM_STREAM_PLAYBACK, 0);
  snd_pcm_set_params(handle, SND_PCM_FORMAT_S16_LE,
                     SND_PCM_ACCESS_RW_INTERLEAVED,
                     2, 48000, 1, 50000);
  
  int16_t samples[800 * 2];
  
  printf("Real-time latency monitoring (using snd_pcm_delay):\n\n");
  
  for (int i = 0; i < 20; i++) {
    // Write audio
    snd_pcm_sframes_t avail = snd_pcm_avail(handle);
    if (avail > 800) {
      snd_pcm_writei(handle, samples, 800);
    }
    
    // Monitor latency
    snd_pcm_sframes_t delay;
    snd_pcm_delay(handle, &delay);
    float latency_ms = delay / 48.0;  // At 48kHz
    
    print_latency_bar(latency_ms);
    
    usleep(16000);
  }
  
  snd_pcm_close(handle);
  return 0;
}
```

---

### Exercise 4: Error Detection

Create `test_errors.c`:
```c
#include <alsa/asoundlib.h>
#include <stdio.h>
#include <unistd.h>

int main() {
  snd_pcm_t *handle;
  snd_pcm_open(&handle, "default", SND_PCM_STREAM_PLAYBACK, 0);
  snd_pcm_set_params(handle, SND_PCM_FORMAT_S16_LE,
                     SND_PCM_ACCESS_RW_INTERLEAVED,
                     2, 48000, 1, 20000);  // Small buffer (20ms)
  
  int16_t samples[800 * 2];
  
  printf("Testing error detection:\n\n");
  
  // Fill buffer
  snd_pcm_writei(handle, samples, 800);
  snd_pcm_writei(handle, samples, 800);
  
  // Force underrun by waiting
  printf("Waiting 100ms to force underrun...\n");
  usleep(100000);
  
  // Check avail (should return error)
  snd_pcm_sframes_t avail = snd_pcm_avail(handle);
  if (avail < 0) {
    printf("‚ùå snd_pcm_avail() error: %s (code: %ld)\n",
           snd_strerror(avail), avail);
    
    if (avail == -EPIPE) {
      printf("   This is an underrun!\n");
    }
  }
  
  // Check delay (should also return error)
  snd_pcm_sframes_t delay;
  int err = snd_pcm_delay(handle, &delay);
  if (err < 0) {
    printf("‚ùå snd_pcm_delay() error: %s (code: %d)\n",
           snd_strerror(err), err);
  }
  
  // Recover
  printf("\nRecovering...\n");
  snd_pcm_recover(handle, avail, 1);
  
  avail = snd_pcm_avail(handle);
  printf("‚úÖ After recovery, avail = %ld\n", avail);
  
  snd_pcm_close(handle);
  return 0;
}
```

---

## üéì Comprehension Check

**Before moving to L3.3, answer these:**

1. **Awareness:** What's the difference between avail and delay?

2. **Comprehension:** Why is avail + delay ‚âà buffer_size (not exactly)?

3. **Application:** You want to know latency. Which function do you use?

4. **Analysis:** avail returns -EPIPE. What happened? How to fix?

5. **Synthesis:** Design a system that monitors latency and warns if > 100ms.

6. **Evaluation:** Should you call snd_pcm_delay() every frame? Why/why not?

---

## üîó Connection to Next Lesson

**L3.3: Synchronizing with Game Loop**
- You know how to query buffer state
- Next: HOW to integrate into game loop timing?
- When exactly to call snd_pcm_avail()?
- How to handle variable frame rates?

---

## üìù Reflection Questions (Write in UNITS-TRACKER.md)

1. **Aha Moment:** When did avail vs delay make sense?

2. **Experiment Result:** What was your measured avail+delay difference?

3. **Web Dev Connection:** Is this like socket buffers?

4. **Design Choice:** Why does Casey only use avail, not delay?

---

**When ready, update UNITS-TRACKER.md and move to L3.3!** ‚úÖ
