# Unit 3, Lesson 4: Handling Underruns and Recovery

> **Learning Goal:** Detect, recover from, and prevent ALSA underruns  
> **Time Estimate:** 45-60 minutes  
> **Prerequisite:** L3.3 (Game Loop Sync)

---

## ğŸ¯ The Mystery You're Solving

What happens when your game can't keep up with audio?

```c
// Normal case:
snd_pcm_writei(handle, buffer, 800);  // Returns: 800 âœ…

// Underrun case:
snd_pcm_writei(handle, buffer, 800);  // Returns: -32 âŒ (-EPIPE)
//                                       What is -EPIPE?
//                                       How to fix it?
//                                       Can we prevent it?
```

**Questions:**
- What IS an underrun (xrun)?
- What causes underruns?
- How to detect them?
- How to recover gracefully?
- How to prevent them?

---

## ğŸ“š Core Concepts

### 1. What is an Underrun?

**Definition:**
> **Underrun (Buffer Underrun / XRUN):** When ALSA's ring buffer empties completely because you didn't write audio fast enough.

**The timeline:**

```
t=0ms:   Buffer has 2400 frames (50ms)
         [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ]  â† Full
         
t=16ms:  Hardware consumed 768 frames
         [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘]  â† 1632 frames left
         You write 800 frames
         [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘]  â† 2432 frames (good!)
         
t=32ms:  Hardware consumed 768 more
         [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘]  â† 1664 frames left
         You write 800 frames
         [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘]  â† 2464 frames (good!)
         
t=100ms: SLOW FRAME! Game stuttered (loading asset)
         Hardware keeps consuming...
         [â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘]  â† 400 frames left
         [â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘]  â† 0 frames (UNDERRUN!)
         
         You finally try to write:
         snd_pcm_writei() returns -EPIPE âŒ
```

**What the user hears:**
- **Click/pop:** Discontinuity when buffer empties
- **Silence:** Until you recover and refill buffer
- **Glitch:** Artifacts when playback resumes

---

### 2. Common Causes of Underruns

**A. Game Loop Stalls**
```c
void game_loop() {
  while (running) {
    // Audio first
    write_audio();  // âœ… Writes 800 frames
    
    // Then game...
    load_asset();   // âŒ Takes 100ms! (blocks)
    //              â†’ By time we loop back, buffer empty!
  }
}
```

**B. Audio LAST in Loop**
```c
void game_loop() {
  while (running) {
    update_game();  // Could spike to 50ms
    render();       // Could spike to 30ms
    write_audio();  // âŒ Now we're 80ms late!
  }
}
```

**C. Thread Scheduling**
```c
// Linux scheduler preempts your thread
write_audio();    // Scheduled out for 20ms!
// â†’ Buffer empties while waiting
```

**D. Too Small Buffer**
```c
// Only 10ms buffer (480 frames at 48kHz)
snd_pcm_set_params(..., 10000);  // 10ms latency
// â†’ ANY frame >10ms causes underrun
```

---

### 3. Detecting Underruns

**Method 1: Check snd_pcm_writei() return value**

```c
snd_pcm_sframes_t written = snd_pcm_writei(handle, buffer, frames);

if (written < 0) {
  if (written == -EPIPE) {
    printf("âŒ UNDERRUN detected!\n");
    // Recover...
  } else {
    printf("âŒ Other error: %s\n", snd_strerror(written));
  }
}
```

**Method 2: Check snd_pcm_avail() return value**

```c
snd_pcm_sframes_t avail = snd_pcm_avail(handle);

if (avail < 0) {
  if (avail == -EPIPE) {
    printf("âŒ UNDERRUN detected!\n");
  }
}
```

**Method 3: Check PCM state**

```c
snd_pcm_state_t state = snd_pcm_state(handle);

switch (state) {
  case SND_PCM_STATE_XRUN:
    printf("âŒ Underrun state!\n");
    break;
  case SND_PCM_STATE_RUNNING:
    printf("âœ… Running normally\n");
    break;
  case SND_PCM_STATE_PREPARED:
    printf("â¸ Prepared but not started\n");
    break;
}
```

---

### 4. Recovering from Underruns

**The Magic Function: snd_pcm_recover()**

```c
int snd_pcm_recover(snd_pcm_t *pcm, int err, int silent);
// pcm:    ALSA handle
// err:    Error code from writei/avail (e.g., -EPIPE)
// silent: 0 = log error, 1 = silent recovery
```

**How it works:**

```c
// Internally, snd_pcm_recover() does:
if (err == -EPIPE) {
  snd_pcm_prepare(pcm);  // Reset PCM state
  // Now you can write again!
} else if (err == -ESTRPIPE) {
  // Suspend/resume (rare)
  while ((err = snd_pcm_resume(pcm)) == -EAGAIN) {
    sleep(1);
  }
  if (err < 0) {
    snd_pcm_prepare(pcm);
  }
}
```

**Complete recovery pattern:**

```c
snd_pcm_sframes_t frames = snd_pcm_avail(handle);

if (frames < 0) {
  // Error detected
  printf("Error: %s\n", snd_strerror(frames));
  
  // Attempt recovery
  int err = snd_pcm_recover(handle, frames, 1);  // silent=1
  
  if (err < 0) {
    printf("âŒ Recovery failed: %s\n", snd_strerror(err));
    // Drastic: Close and reopen
  } else {
    printf("âœ… Recovered successfully\n");
    // Continue normally
    frames = snd_pcm_avail(handle);  // Re-query
  }
}

// Normal case (or after recovery)
if (frames > 0) {
  generate_audio(buffer, frames);
  snd_pcm_writei(handle, buffer, frames);
}
```

---

### 5. Prevention Strategies

**A. Audio-First Pattern (Casey's)**
```c
void game_loop() {
  while (running) {
    handle_audio();  // â† Do this FIRST, always!
    // ... rest of game ...
  }
}
```

**B. Adequate Buffer Size**
```c
// Too small (risky):
snd_pcm_set_params(..., 10000);  // 10ms = underrun if frame >10ms

// Good:
snd_pcm_set_params(..., 33333);  // 33ms = 2 frames at 60 FPS

// Safe:
snd_pcm_set_params(..., 50000);  // 50ms = 3 frames at 60 FPS
```

**C. Monitor Buffer Level**
```c
snd_pcm_sframes_t delay;
snd_pcm_delay(handle, &delay);

if (delay < 400) {  // Less than 8ms buffered
  printf("âš ï¸  Warning: Buffer running low!\n");
  // Consider writing extra audio
}
```

**D. Clamp Frame Generation**
```c
snd_pcm_sframes_t frames = snd_pcm_avail(handle);

// Don't generate TOO much (wastes CPU)
if (frames > 2400) {
  frames = 2400;  // Cap at 50ms
}

if (frames > 0) {
  generate_audio(buffer, frames);
  snd_pcm_writei(handle, buffer, frames);
}
```

---

### 6. Real-World Recovery Pattern

**Production-ready error handling:**

```c
typedef struct {
  snd_pcm_t *handle;
  uint64_t underrun_count;
  uint64_t last_underrun_time;
} AudioState;

bool write_audio(AudioState *audio, int16_t *buffer, int frames) {
  snd_pcm_sframes_t written = snd_pcm_writei(audio->handle, buffer, frames);
  
  if (written < 0) {
    // Log error
    printf("[%lu] Audio error: %s\n", get_time_ms(), snd_strerror(written));
    
    // Track underruns
    if (written == -EPIPE) {
      audio->underrun_count++;
      audio->last_underrun_time = get_time_ms();
      
      // Too many underruns? Log warning
      if (audio->underrun_count > 100) {
        printf("âš ï¸  %lu underruns detected! System overloaded?\n",
               audio->underrun_count);
      }
    }
    
    // Attempt recovery
    int err = snd_pcm_recover(audio->handle, written, 0);  // non-silent
    
    if (err < 0) {
      printf("âŒ Recovery failed: %s\n", snd_strerror(err));
      return false;  // Fatal error
    }
    
    // Retry write after recovery
    written = snd_pcm_writei(audio->handle, buffer, frames);
    if (written < 0) {
      printf("âŒ Write failed even after recovery\n");
      return false;
    }
  }
  
  return true;  // Success
}
```

---

## ğŸ§ª Hands-On Exercises

### Exercise 1: Force an Underrun

Create `force_underrun.c`:
```c
#include <alsa/asoundlib.h>
#include <stdio.h>
#include <unistd.h>

int main() {
  snd_pcm_t *handle;
  snd_pcm_open(&handle, "default", SND_PCM_STREAM_PLAYBACK, 0);
  snd_pcm_set_params(handle, SND_PCM_FORMAT_S16_LE,
                     SND_PCM_ACCESS_RW_INTERLEAVED,
                     2, 48000, 1, 20000);  // Small buffer (20ms)
  
  int16_t buffer[800 * 2];
  
  printf("Writing initial audio...\n");
  snd_pcm_writei(handle, buffer, 800);
  snd_pcm_writei(handle, buffer, 800);
  
  printf("Sleeping 100ms to force underrun...\n");
  usleep(100000);  // 100ms > 20ms buffer
  
  printf("Attempting write after underrun...\n");
  snd_pcm_sframes_t written = snd_pcm_writei(handle, buffer, 800);
  
  if (written == -EPIPE) {
    printf("âŒ UNDERRUN! (error code: %ld)\n", written);
    printf("   Error string: %s\n", snd_strerror(written));
    
    printf("\nRecovering...\n");
    int err = snd_pcm_recover(handle, written, 0);
    
    if (err == 0) {
      printf("âœ… Recovery successful!\n");
      
      // Try writing again
      written = snd_pcm_writei(handle, buffer, 800);
      printf("   Wrote %ld frames after recovery\n", written);
    } else {
      printf("âŒ Recovery failed: %s\n", snd_strerror(err));
    }
  }
  
  snd_pcm_close(handle);
  return 0;
}
```

---

### Exercise 2: Monitor Underrun Rate

Create `underrun_monitor.c`:
```c
#include <alsa/asoundlib.h>
#include <stdio.h>
#include <unistd.h>
#include <time.h>

uint64_t get_time_ms() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return ts.tv_sec * 1000 + ts.tv_nsec / 1000000;
}

int main() {
  snd_pcm_t *handle;
  snd_pcm_open(&handle, "default", SND_PCM_STREAM_PLAYBACK, 0);
  snd_pcm_set_params(handle, SND_PCM_FORMAT_S16_LE,
                     SND_PCM_ACCESS_RW_INTERLEAVED,
                     2, 48000, 1, 30000);  // 30ms buffer
  
  int16_t buffer[2400 * 2];
  int underrun_count = 0;
  int frame_count = 0;
  
  printf("Running for 60 frames (with occasional delays)...\n\n");
  
  for (int i = 0; i < 60; i++) {
    // Simulate variable frame times
    if (i % 10 == 0) {
      printf("Frame %d: Simulating slow frame (40ms)...\n", i);
      usleep(40000);  // > 30ms buffer
    }
    
    snd_pcm_sframes_t frames = snd_pcm_avail(handle);
    
    if (frames < 0) {
      underrun_count++;
      printf("  âŒ Underrun #%d at frame %d\n", underrun_count, i);
      snd_pcm_recover(handle, frames, 1);
      frames = snd_pcm_avail(handle);
    }
    
    if (frames > 0) {
      snd_pcm_writei(handle, buffer, frames);
    }
    
    frame_count++;
    usleep(16000);  // Normal 16ms
  }
  
  printf("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
  printf("Total frames:   %d\n", frame_count);
  printf("Underruns:      %d\n", underrun_count);
  printf("Underrun rate:  %.1f%%\n",
         (underrun_count * 100.0) / frame_count);
  
  snd_pcm_close(handle);
  return 0;
}
```

---

### Exercise 3: Test Different Buffer Sizes

Create `buffer_size_test.c`:
```c
#include <alsa/asoundlib.h>
#include <stdio.h>
#include <unistd.h>

void test_buffer_size(int latency_ms) {
  snd_pcm_t *handle;
  snd_pcm_open(&handle, "default", SND_PCM_STREAM_PLAYBACK, 0);
  snd_pcm_set_params(handle, SND_PCM_FORMAT_S16_LE,
                     SND_PCM_ACCESS_RW_INTERLEAVED,
                     2, 48000, 1, latency_ms * 1000);
  
  int16_t buffer[4800 * 2];
  int underruns = 0;
  
  for (int i = 0; i < 20; i++) {
    // Occasional slow frame
    if (i == 10) usleep(50000);  // 50ms spike
    
    snd_pcm_sframes_t frames = snd_pcm_avail(handle);
    if (frames < 0) {
      underruns++;
      snd_pcm_recover(handle, frames, 1);
      frames = snd_pcm_avail(handle);
    }
    
    if (frames > 0) {
      snd_pcm_writei(handle, buffer, frames);
    }
    
    usleep(16000);
  }
  
  printf("%3dms buffer: %d underruns %s\n",
         latency_ms, underruns,
         underruns > 0 ? "âŒ" : "âœ…");
  
  snd_pcm_close(handle);
}

int main() {
  printf("Testing different buffer sizes:\n\n");
  
  test_buffer_size(10);
  test_buffer_size(20);
  test_buffer_size(30);
  test_buffer_size(40);
  test_buffer_size(50);
  test_buffer_size(100);
  
  return 0;
}
```

---

## ğŸ“ Comprehension Check

1. **Awareness:** What is an underrun and what causes it?

2. **Comprehension:** Why does `snd_pcm_recover()` fix underruns?

3. **Application:** Add underrun detection and recovery to your game.

4. **Analysis:** You get 10 underruns per minute. What's wrong?

5. **Synthesis:** Design a system that auto-adjusts buffer size based on underrun rate.

6. **Evaluation:** Is it better to prevent underruns or handle them gracefully?

---

## ğŸ”— Connection to Next Lesson

**L3.5: Audio Write Patterns**
- You can now handle errors
- Next: Best practices for audio generation
- Sine waves vs square waves
- Mixing multiple sounds
- Volume control

---

**When ready, move to L3.5 to complete Unit 3!** âœ…
