# Unit 3, Lesson 5: Audio Write Patterns (Best Practices)

> **Learning Goal:** Master patterns for writing audio efficiently and correctly  
> **Time Estimate:** 30-45 minutes  
> **Prerequisite:** L3.4 (Handling Underruns)

---

## ðŸŽ¯ The Mystery You're Solving

What's the BEST way to write audio in the game loop?

```c
// Pattern 1: Write exactly what ALSA needs
snd_pcm_sframes_t frames = snd_pcm_avail(handle);
write_audio(buffer, frames);

// Pattern 2: Write fixed chunks
write_audio(buffer, 800);  // Always 800 frames

// Pattern 3: Write until buffer full
while (snd_pcm_avail(handle) > 0) {
  write_audio(buffer, 800);
}
```

**Questions:**
- Which pattern is best for games?
- How much should you write per frame?
- Should you cap the amount?
- What about startup (empty buffer)?

---

## ðŸ“š Core Concepts

### 1. The Three Write Strategies

**A. Pull System (Casey's Choice - RECOMMENDED)**

```c
void game_loop() {
  while (running) {
    // Query exactly what ALSA needs
    snd_pcm_sframes_t frames = snd_pcm_avail(handle);
    
    if (frames > 0) {
      // Generate and write that amount
      generate_audio(buffer, frames);
      snd_pcm_writei(handle, buffer, frames);
    }
    
    // Rest of game...
  }
}
```

**Pros:**
- âœ… Adapts to actual need
- âœ… No underruns even with variable FPS
- âœ… Simple and efficient

**Cons:**
- âŒ Might generate large chunks on startup

---

**B. Fixed Chunk System**

```c
void game_loop() {
  while (running) {
    // Always write same amount
    int frames = 800;  // Fixed (16.67ms at 48kHz)
    
    generate_audio(buffer, frames);
    snd_pcm_writei(handle, buffer, frames);
    
    // Rest of game...
  }
}
```

**Pros:**
- âœ… Simple logic
- âœ… Predictable CPU usage

**Cons:**
- âŒ Underruns with variable FPS
- âŒ Doesn't adapt to timing variance

---

**C. Buffer Fill System**

```c
void game_loop() {
  while (running) {
    // Write until buffer full
    while (snd_pcm_avail(handle) > 800) {
      generate_audio(buffer, 800);
      snd_pcm_writei(handle, buffer, 800);
    }
    
    // Rest of game...
  }
}
```

**Pros:**
- âœ… Keeps buffer maximally filled

**Cons:**
- âŒ Unpredictable frame time (could loop 5+ times)
- âŒ Wastes CPU generating extra audio
- âŒ Increases latency

---

### 2. Casey's Pattern (Best for Games)

**The complete write pattern:**

```c
void linux_audio_write(LinuxSoundOutput *sound) {
  // 1. Query available space
  snd_pcm_sframes_t frames_to_write = SndPcmAvail(sound->handle);
  
  // 2. Handle errors
  if (frames_to_write < 0) {
    if (frames_to_write == -EPIPE) {
      // Underrun - recover
      SndPcmRecover(sound->handle, frames_to_write, 1);
    }
    return;  // Skip this frame
  }
  
  // 3. Optional: Cap maximum write (prevent long generation)
  if (frames_to_write > 2400) {  // Cap at 50ms
    frames_to_write = 2400;
  }
  
  // 4. Generate audio (if needed)
  if (frames_to_write > 0) {
    linux_fill_sound_buffer(sound, frames_to_write);
    
    // 5. Write to ALSA
    snd_pcm_sframes_t written = 
        SndPcmWritei(sound->handle, sound->buffer, frames_to_write);
    
    // 6. Handle write errors
    if (written < 0) {
      SndPcmRecover(sound->handle, written, 1);
    } else if (written < frames_to_write) {
      printf("âš ï¸  Partial write: %ld/%ld frames\n",
             written, frames_to_write);
    }
  }
}
```

---

### 3. Startup Pattern (Initial Fill)

**Problem: Empty buffer at startup**

```c
// First frame:
snd_pcm_avail(handle);  // Returns: 2400 frames (empty buffer!)

// If you write 2400 frames:
// - Takes time to generate (maybe 2-3ms)
// - Increases startup latency
```

**Solution A: Fill to target level**

```c
void audio_startup(snd_pcm_t *handle, int target_ms) {
  // Fill buffer to target latency (e.g., 33ms)
  int target_frames = (48000 * target_ms) / 1000;
  
  snd_pcm_sframes_t avail = snd_pcm_avail(handle);
  snd_pcm_sframes_t to_write = target_frames;
  
  if (to_write > avail) to_write = avail;
  
  // Generate silence initially (fast)
  int16_t *buffer = calloc(to_write * 2, sizeof(int16_t));
  snd_pcm_writei(handle, buffer, to_write);
  free(buffer);
  
  printf("Pre-filled buffer with %ld frames\n", to_write);
}
```

**Solution B: Write normally, let it fill over frames**

```c
// Frame 0: Write 800 frames  (buffer: 33% full)
// Frame 1: Write 800 frames  (buffer: 66% full)
// Frame 2: Write 800 frames  (buffer: 100% full)
// Frame 3+: Write ~800 frames (maintain level)

// Simpler, but takes 3 frames to reach target latency
```

---

### 4. Capping Write Amount

**Why cap?**

```c
// Without cap:
snd_pcm_sframes_t frames = snd_pcm_avail(handle);
// If game stuttered for 200ms:
// frames = 9600 frames (200ms worth!)

generate_audio(buffer, 9600);  // Takes 10ms to generate!
// Now this frame is 10ms longer, making problem worse!
```

**With cap:**

```c
snd_pcm_sframes_t frames = snd_pcm_avail(handle);

// Cap at reasonable maximum (e.g., 50ms)
if (frames > 2400) {
  frames = 2400;
}

generate_audio(buffer, frames);  // Max 2-3ms
```

**Choosing the cap:**
```c
// Too small (e.g., 10ms):
// - Can't handle slow frames
// - More underruns

// Too large (e.g., 200ms):
// - Audio generation dominates frame time
// - Creates feedback loop (slow generation â†’ slower frames)

// Sweet spot: 2-3 frames worth
int cap_frames = (samples_per_second / game_hz) * 2;
// At 60 FPS: cap = 800 * 2 = 1600 frames (33ms)
```

---

### 5. Handling Partial Writes

**Rare, but possible:**

```c
snd_pcm_sframes_t written = snd_pcm_writei(handle, buffer, 800);

if (written < 800 && written >= 0) {
  // Partial write! Only wrote part of buffer
  printf("Wrote %ld / 800 frames\n", written);
  
  // Options:
  // 1. Ignore (audio will glitch slightly)
  // 2. Write remaining next frame
  // 3. Treat as error and recover
  
  // For games: Option 1 is fine (rare enough)
}
```

**Casey's approach: Ignore partial writes**
- Happens rarely (<<1% of frames)
- Small audio glitch is acceptable
- Not worth the complexity

---

### 6. Complete Integration Pattern

**Production-ready game loop audio:**

```c
typedef struct {
  snd_pcm_t *handle;
  int16_t *buffer;
  int buffer_frames;
  int channels;
  int samples_per_second;
  int game_hz;
  
  // Statistics
  uint64_t total_writes;
  uint64_t underruns;
  uint64_t partial_writes;
} LinuxSoundOutput;

void linux_handle_audio(LinuxSoundOutput *sound) {
  // 1. Query
  snd_pcm_sframes_t frames_to_write = SndPcmAvail(sound->handle);
  
  // 2. Error check
  if (frames_to_write < 0) {
    sound->underruns++;
    SndPcmRecover(sound->handle, frames_to_write, 1);
    return;
  }
  
  // 3. Cap
  int cap = (sound->samples_per_second / sound->game_hz) * 3;
  if (frames_to_write > cap) {
    frames_to_write = cap;
  }
  
  // 4. Generate & write
  if (frames_to_write > 0) {
    linux_fill_sound_buffer(sound, frames_to_write);
    
    snd_pcm_sframes_t written = 
        SndPcmWritei(sound->handle, sound->buffer, frames_to_write);
    
    if (written < 0) {
      sound->underruns++;
      SndPcmRecover(sound->handle, written, 1);
    } else {
      sound->total_writes++;
      if (written < frames_to_write) {
        sound->partial_writes++;
      }
    }
  }
}

void game_loop(LinuxSoundOutput *sound) {
  while (running) {
    // Audio first!
    linux_handle_audio(sound);
    
    // Rest of game...
    process_input();
    update_game();
    render_frame();
  }
}
```

---

## ðŸ§ª Hands-On Exercises

### Exercise 1: Compare Write Patterns

Create `compare_patterns.c`:
```c
#include <alsa/asoundlib.h>
#include <stdio.h>
#include <unistd.h>
#include <time.h>

double get_time_ms() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return ts.tv_sec * 1000.0 + ts.tv_nsec / 1e6;
}

void test_pull_pattern() {
  printf("\n=== PULL Pattern (Query-based) ===\n");
  
  snd_pcm_t *handle;
  snd_pcm_open(&handle, "default", SND_PCM_STREAM_PLAYBACK, 0);
  snd_pcm_set_params(handle, SND_PCM_FORMAT_S16_LE,
                     SND_PCM_ACCESS_RW_INTERLEAVED,
                     2, 48000, 1, 50000);
  
  int16_t buffer[4800 * 2];
  int underruns = 0;
  double total_time = 0;
  
  for (int i = 0; i < 60; i++) {
    double start = get_time_ms();
    
    // PULL: Query then write
    snd_pcm_sframes_t frames = snd_pcm_avail(handle);
    if (frames < 0) {
      underruns++;
      snd_pcm_recover(handle, frames, 1);
      frames = snd_pcm_avail(handle);
    }
    if (frames > 0) {
      snd_pcm_writei(handle, buffer, frames);
    }
    
    double end = get_time_ms();
    total_time += (end - start);
    
    if (i == 30) usleep(60000);  // Slow frame
    else usleep(16000);
  }
  
  printf("Underruns: %d\n", underruns);
  printf("Avg time:  %.2f ms/frame\n", total_time / 60);
  
  snd_pcm_close(handle);
}

void test_fixed_pattern() {
  printf("\n=== FIXED Pattern (800 frames always) ===\n");
  
  snd_pcm_t *handle;
  snd_pcm_open(&handle, "default", SND_PCM_STREAM_PLAYBACK, 0);
  snd_pcm_set_params(handle, SND_PCM_FORMAT_S16_LE,
                     SND_PCM_ACCESS_RW_INTERLEAVED,
                     2, 48000, 1, 50000);
  
  int16_t buffer[800 * 2];
  int underruns = 0;
  double total_time = 0;
  
  for (int i = 0; i < 60; i++) {
    double start = get_time_ms();
    
    // FIXED: Always 800 frames
    snd_pcm_sframes_t written = snd_pcm_writei(handle, buffer, 800);
    if (written < 0) {
      underruns++;
      snd_pcm_recover(handle, written, 1);
    }
    
    double end = get_time_ms();
    total_time += (end - start);
    
    if (i == 30) usleep(60000);  // Slow frame
    else usleep(16000);
  }
  
  printf("Underruns: %d\n", underruns);
  printf("Avg time:  %.2f ms/frame\n", total_time / 60);
  
  snd_pcm_close(handle);
}

int main() {
  test_pull_pattern();
  test_fixed_pattern();
  return 0;
}
```

---

### Exercise 2: Test Write Caps

Create `test_caps.c`:
```c
#include <alsa/asoundlib.h>
#include <stdio.h>
#include <unistd.h>

void test_with_cap(int cap_frames) {
  snd_pcm_t *handle;
  snd_pcm_open(&handle, "default", SND_PCM_STREAM_PLAYBACK, 0);
  snd_pcm_set_params(handle, SND_PCM_FORMAT_S16_LE,
                     SND_PCM_ACCESS_RW_INTERLEAVED,
                     2, 48000, 1, 50000);
  
  int16_t buffer[4800 * 2];
  
  printf("\nCap: %d frames (%.1f ms)\n", cap_frames, cap_frames / 48.0);
  
  // Simulate slow frame
  usleep(100000);  // 100ms gap
  
  snd_pcm_sframes_t frames = snd_pcm_avail(handle);
  printf("  ALSA needs: %ld frames\n", frames);
  
  if (frames > cap_frames) {
    frames = cap_frames;
    printf("  Capped to:  %d frames\n", cap_frames);
  }
  
  snd_pcm_writei(handle, buffer, frames);
  
  snd_pcm_close(handle);
}

int main() {
  printf("Testing different cap values:\n");
  
  test_with_cap(800);   // 16.67ms
  test_with_cap(1600);  // 33ms
  test_with_cap(2400);  // 50ms
  test_with_cap(4800);  // 100ms (no cap)
  
  return 0;
}
```

---

### Exercise 3: Monitor Write Stats

Create `write_stats.c`:
```c
#include <alsa/asoundlib.h>
#include <stdio.h>
#include <unistd.h>

int main() {
  snd_pcm_t *handle;
  snd_pcm_open(&handle, "default", SND_PCM_STREAM_PLAYBACK, 0);
  snd_pcm_set_params(handle, SND_PCM_FORMAT_S16_LE,
                     SND_PCM_ACCESS_RW_INTERLEAVED,
                     2, 48000, 1, 50000);
  
  int16_t buffer[4800 * 2];
  
  int total_writes = 0;
  int underruns = 0;
  int partial_writes = 0;
  int skipped_frames = 0;
  long total_frames_written = 0;
  
  printf("Running 120 frames with statistics:\n\n");
  
  for (int i = 0; i < 120; i++) {
    snd_pcm_sframes_t frames = snd_pcm_avail(handle);
    
    if (frames < 0) {
      underruns++;
      snd_pcm_recover(handle, frames, 1);
      continue;
    }
    
    if (frames == 0) {
      skipped_frames++;
      usleep(16000);
      continue;
    }
    
    // Cap at 50ms
    if (frames > 2400) frames = 2400;
    
    snd_pcm_sframes_t written = snd_pcm_writei(handle, buffer, frames);
    
    if (written < 0) {
      underruns++;
      snd_pcm_recover(handle, written, 1);
    } else {
      total_writes++;
      total_frames_written += written;
      if (written < frames) {
        partial_writes++;
      }
    }
    
    // Variable frame time
    if (i % 30 == 0) usleep(50000);
    else usleep(16000);
  }
  
  printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
  printf("Total writes:    %d\n", total_writes);
  printf("Frames written:  %ld (avg %.0f/write)\n",
         total_frames_written, (double)total_frames_written / total_writes);
  printf("Underruns:       %d (%.1f%%)\n",
         underruns, (underruns * 100.0) / 120);
  printf("Partial writes:  %d (%.1f%%)\n",
         partial_writes, (partial_writes * 100.0) / total_writes);
  printf("Skipped frames:  %d\n", skipped_frames);
  
  snd_pcm_close(handle);
  return 0;
}
```

---

## ðŸŽ“ Unit 3 Completion Checklist

**Before moving to Unit 4, verify you can:**

- [ ] Explain pull vs push audio architecture
- [ ] Use `snd_pcm_avail()` to query buffer state
- [ ] Integrate audio at START of game loop
- [ ] Detect and recover from underruns
- [ ] Implement production-ready write pattern
- [ ] Choose appropriate write caps
- [ ] Handle errors gracefully

**Self-Assessment:**
- **Confidence (0-10):** ___
- **Can implement frame-aligned audio:** Yes / No
- **Understand all Unit 3 concepts:** Yes / No

---

## ðŸŽ‰ Unit 3 Complete!

**Congratulations! You now understand:**
- Pull system vs push system architecture
- How `snd_pcm_avail()` and `snd_pcm_delay()` work
- Audio-first game loop integration
- Underrun detection and recovery
- Production-ready write patterns

**Update UNITS-TRACKER.md:**
```markdown
## Unit 3: Frame-Aligned Audio [COMPLETED] âœ…
**Achieved Competence:** Level ___ (fill in)
**Time Spent:** ___ hours
**Key Insight:** ___
```

---

## ðŸ”— Next: Unit 4 (Debugging Audio)

Ready to learn:
- Common ALSA errors and fixes
- Buffer underrun diagnosis
- Audio glitch debugging
- Performance profiling
- ALSA debug tools

**Take a break, then continue to Unit 4!** ðŸŽŠ
