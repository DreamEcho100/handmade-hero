# L4.1: ALSA Error Codes & Error Handling

**Unit:** 4 - Error Handling & Debugging Audio Failures  
**Duration:** 60-90 minutes  
**Prerequisites:** L1.3 (Stub Functions), L2.3 (ALSA Init)  
**Connects to:** L4.3 (Init Failures), L4.4 (Click Detector)

---

## Learning Objectives

By the end of this lesson, you will be able to:

1. Identify common ALSA error codes and their meanings
2. Use `SndStrerror()` to convert error codes to human-readable strings
3. Distinguish between recoverable and fatal errors
4. Implement error handling patterns for audio failures
5. Debug audio issues using error codes as starting points

---

## The Problem: Cryptic Error Numbers

When ALSA fails, it doesn't throw JavaScript exceptions. It returns negative error codes:

```c
int err = SndPcmOpen(&handle, "default", SND_PCM_STREAM_PLAYBACK, 0);
if (err < 0) {
  // What does -16 mean? -22? -32?
  printf("Error: %d\n", err);  // Unhelpful!
}
```

**Web Dev Comparison:**
```javascript
// You expect:
try {
  await fetch('/api');
} catch (error) {
  console.log(error.message);  // "Network request failed"
}

// But ALSA gives you:
// Error: -16  (What does that mean?!)
```

---

## ALSA Error Code System

ALSA uses **negative errno values** from the Linux kernel. Here are the most common ones:

### Critical Errors (Require User Action)

| Error Code | Name | Meaning | Your Code Location |
|------------|------|---------|-------------------|
| `-2` | `-ENOENT` | File/device not found | `audio.c:232` (device doesn't exist) |
| `-16` | `-EBUSY` | Device already in use | `audio.c:237` (another app using audio) |
| `-19` | `-ENODEV` | No such device | `audio.c:232` (wrong device name) |
| `-22` | `-EINVAL` | Invalid argument | `audio.c:269` (bad sample rate/format) |

### Recoverable Errors (Code Can Handle)

| Error Code | Name | Meaning | Your Code Location |
|------------|------|---------|-------------------|
| `-32` | `-EPIPE` | Broken pipe (underrun) | `audio.c:364` (buffer ran dry) |
| `-77` | `-EBADFD` | Bad file descriptor | `audio.c:380` (device closed unexpectedly) |
| `-86` | `-ESTRPIPE` | Stream pipe error | `audio.c:386` (suspend/resume needed) |

---

## Understanding `-EPIPE` (The Most Common Error)

**What it means:** Buffer underrun â€” you didn't write audio fast enough!

**Why it happens:**
1. Your game loop took >16ms (missed a frame)
2. ALSA played all buffered samples
3. Had nothing left to play â†’ silence â†’ underrun

**How your code handles it:**
```c
// From audio.c:364-386
snd_pcm_sframes_t frames_written = SndPcmWritei(handle, samples, frames_to_write);

if (frames_written == -EPIPE) {
  printf("âš ï¸  Audio underrun! Recovering...\n");
  SndPcmRecover(handle, -EPIPE, 0);  // Magic recovery function
  
  // Try again (this time it works because recover prepared device)
  frames_written = SndPcmWritei(handle, samples, frames_to_write);
}
```

**Web Dev Analogy:**
```javascript
// Like a video stream buffering:
if (videoBuffer.length === 0) {
  console.log("Buffering...");  // Underrun
  await fillBuffer();           // Recover
  video.play();                 // Resume
}
```

---

## The `SndStrerror()` Function

**Purpose:** Convert error codes to human-readable strings

**Your implementation:**
```c
// From audio.c:115-118
ALSA_SND_STRERROR(AlsaSndStrerrorStub) {
  (void)errnum;
  return "ALSA not loaded";
}

// Later loaded from libasound.so:
alsa_snd_strerror *SndStrerror_ = AlsaSndStrerrorStub;
```

**Usage:**
```c
int err = SndPcmOpen(&handle, "default", LINUX_SND_PCM_STREAM_PLAYBACK, 0);
if (err < 0) {
  printf("âŒ Failed to open device: %s\n", SndStrerror(err));
  // Output: "Failed to open device: Device or resource busy"
}
```

---

## Error Handling Patterns in Your Code

### Pattern 1: Fatal Error (Stop Initialization)

```c
// From audio.c:232-246
int err = SndPcmOpen(&handle, "default", LINUX_SND_PCM_STREAM_PLAYBACK, 0);
if (err < 0) {
  fprintf(stderr, "âŒ Failed to open ALSA device: %s\n", SndStrerror(err));
  return false;  // Give up â€” can't continue without audio device
}
```

**Why fatal?** Can't make sound without opening the device.

### Pattern 2: Recoverable Error (Retry)

```c
// From audio.c:364-386
if (frames_written == -EPIPE) {
  SndPcmRecover(handle, -EPIPE, 0);  // Try to recover
  frames_written = SndPcmWritei(handle, samples, frames_to_write);  // Retry
}
```

**Why recoverable?** Underrun is temporary â€” just refill buffer.

### Pattern 3: Degraded Mode (Continue Without Feature)

```c
// From audio.c:224-230
if (!linux_audio_has_latency_measurement()) {
  printf("âš ï¸  snd_pcm_delay not available â€” using Day 9 mode\n");
  // Continue with simpler algorithm
}
```

**Why degrade?** Game can run with basic audio, just not perfect timing.

---

## Exercise 1: Trigger Each Error Deliberately

**Goal:** Learn what each error looks like in practice

### Step 1: Trigger `-EBUSY` (Device In Use)

```bash
# Terminal 1: Start your game
./build/handmade-hero

# Terminal 2: Try to open same device
aplay /usr/share/sounds/alsa/Front_Center.wav
# Should see: "Device or resource busy"
```

**Code to add** (audio.c:232):
```c
int err = SndPcmOpen(&handle, "default", LINUX_SND_PCM_STREAM_PLAYBACK, 0);
if (err == -EBUSY) {
  printf("ğŸ”´ ERROR -EBUSY: Another app is using audio!\n");
  printf("   Try: 'fuser -v /dev/snd/*' to find which process\n");
}
```

### Step 2: Trigger `-EINVAL` (Invalid Parameters)

**Modify audio.c:269:**
```c
// Original (works):
int err = SndPcmSetParams(handle, LINUX_SND_PCM_FORMAT_S16_LE, ...);

// Break it (invalid sample rate):
int err = SndPcmSetParams(handle, 
  LINUX_SND_PCM_FORMAT_S16_LE,
  LINUX_SND_PCM_ACCESS_RW_INTERLEAVED,
  2,        // channels (stereo)
  999999,   // âŒ INVALID SAMPLE RATE (too high)
  1,
  latency_microseconds
);

if (err == -EINVAL) {
  printf("ğŸ”´ ERROR -EINVAL: ALSA rejected sample rate 999999\n");
  printf("   %s\n", SndStrerror(err));
}
```

**Restore to 48000** after seeing the error!

### Step 3: Trigger `-EPIPE` (Underrun)

**Modify backend.c main loop (add intentional stall):**
```c
// In the game loop, before linux_fill_sound_buffer():
#if HANDMADE_INTERNAL
static int debug_stall_counter = 0;
if (++debug_stall_counter == 300) {  // Every 5 seconds at 60fps
  printf("â¸ï¸  Deliberately stalling for 100ms to cause underrun...\n");
  struct timespec sleep_time = {0, 100000000};  // 100ms
  nanosleep(&sleep_time, NULL);
}
#endif
```

**Expected output:**
```
âš ï¸  Audio underrun! Recovering...
```

**Remove the debug code** after observing the underrun!

---

## Exercise 2: Build an Error Decoder

**Goal:** Create a helper function to explain errors

**Add to audio.c:**
```c
#if HANDMADE_INTERNAL
void linux_debug_explain_error(int err) {
  printf("\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n");
  printf("â”‚ ğŸ” ALSA Error Analysis                 â”‚\n");
  printf("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n");
  printf("â”‚ Error Code: %d                         â”‚\n", err);
  printf("â”‚ Error Name: %s                         â”‚\n", SndStrerror(err));
  printf("â”‚                                         â”‚\n");
  
  switch (err) {
    case -EBUSY:
      printf("â”‚ Cause: Another app is using audio      â”‚\n");
      printf("â”‚ Fix: Close other apps (Spotify, etc)   â”‚\n");
      printf("â”‚ Command: fuser -v /dev/snd/*           â”‚\n");
      break;
    
    case -EINVAL:
      printf("â”‚ Cause: Invalid parameter (rate/format) â”‚\n");
      printf("â”‚ Fix: Check sample rate (48000 is safe) â”‚\n");
      printf("â”‚ Command: aplay -l (list devices)       â”‚\n");
      break;
    
    case -EPIPE:
      printf("â”‚ Cause: Buffer underrun (too slow)      â”‚\n");
      printf("â”‚ Fix: Increase latency or fix FPS drops â”‚\n");
      printf("â”‚ Current latency: %dms                  â”‚\n", 
             (int)((float)sound_output->latency_sample_count / 48000.0f * 1000.0f));
      break;
    
    case -ENOENT:
      printf("â”‚ Cause: Audio device not found          â”‚\n");
      printf("â”‚ Fix: Check device name (try 'default') â”‚\n");
      printf("â”‚ Command: aplay -L (list PCM devices)   â”‚\n");
      break;
    
    default:
      printf("â”‚ Unknown error â€” check ALSA docs        â”‚\n");
  }
  
  printf("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n");
}
#endif
```

**Use it:**
```c
int err = SndPcmOpen(&handle, "default", LINUX_SND_PCM_STREAM_PLAYBACK, 0);
if (err < 0) {
  linux_debug_explain_error(err);
  return false;
}
```

---

## Debugging Workflow

When audio fails, follow this process:

```
1. Note the error code
   â†“
2. Run linux_debug_explain_error(err)
   â†“
3. Google "ALSA [error name]"
   â†“
4. Check system state:
   - aplay -l  (list devices)
   - fuser -v /dev/snd/*  (who's using audio)
   - cat /proc/asound/cards  (detected hardware)
   â†“
5. Test minimal case:
   - aplay test.wav  (does simple playback work?)
   â†“
6. Fix and verify
```

---

## Key Takeaways

1. **ALSA errors are negative errno values** (not exceptions)
2. **`SndStrerror()` is your first debugging tool**
3. **`-EPIPE` (underrun) is recoverable** with `SndPcmRecover()`
4. **`-EBUSY` means another app owns the device**
5. **`-EINVAL` means you passed bad parameters**
6. **Always provide helpful error messages** (don't just print numbers!)

---

## Self-Check Quiz

Before moving on, answer these:

1. **Q:** What does error code `-32` mean?  
   **A:** `-EPIPE` â€” buffer underrun

2. **Q:** Is `-EBUSY` recoverable?  
   **A:** No â€” user must close other apps

3. **Q:** How do you convert error code to string?  
   **A:** `SndStrerror(err)`

4. **Q:** Where in your code handles underruns?  
   **A:** `audio.c:364-386`

5. **Q:** What command shows which process is using audio?  
   **A:** `fuser -v /dev/snd/*`

---

## Next Lesson

**L4.2: Day 9 vs Day 10 Strategy** â€” Learn the difference between reactive and predictive audio buffering.

---

**Time to complete:** 1-2 hours  
**Code modified:** audio.c (added debug helpers)  
**Competence level achieved:** Level 3 (Can modify and debug errors)
