# L4.4: The Click Detector

**Unit:** 4 - Error Handling & Debugging Audio Failures  
**Duration:** 45-60 minutes  
**Prerequisites:** L3.3 (Underrun/Overrun), L4.2 (Day 9 vs 10)  
**Connects to:** Unit 5 (Eliminating Clicks), L4.5 (Debug Visualization)

---

## Learning Objectives

1. Understand what causes audio clicks and pops
2. Identify the click detector in your code
3. Correlate clicks with frame drops
4. Distinguish between timing clicks and phase clicks
5. Use logging to track audio discontinuities

---

## What Causes Audio Clicks?

Audio clicks happen when the **waveform has discontinuities**:

```
Good (smooth sine wave):
  ‚àø‚àø‚àø‚àø‚àø‚àø‚àø‚àø‚àø‚àø‚àø‚àø

Bad (jump in waveform):
  ‚àø‚àø‚àø‚àø‚àø‚àø‚îÇ     ‚Üê Click!
        ‚îî‚îÄ‚àø‚àø‚àø‚àø
```

### Two Types of Clicks

#### Type 1: Timing Clicks (Buffer Issues)

**Cause:** Variable write amounts

```c
Frame 1: Write 800 samples
Frame 2: Write 400 samples  ‚Üê Half as much!
Frame 3: Write 800 samples

// Waveform jumps because sine wave phase got out of sync
```

#### Type 2: Phase Clicks (Math Issues)

**Cause:** Resetting phase each frame

```c
// BAD:
for (each frame) {
  float phase = 0;  ‚Üê Resets every frame!
  for (int i = 0; i < samples; i++) {
    sample = sin(phase);
    phase += 2*PI * freq / rate;
  }
}

// GOOD:
static float running_phase = 0;  ‚Üê Persists across frames
for (each frame) {
  for (int i = 0; i < samples; i++) {
    sample = sin(running_phase);
    running_phase += 2*PI * freq / rate;
  }
}
```

---

## Your Click Detector Code

**Location:** `audio.c:1000-1014`

```c
#if HANDMADE_INTERNAL
  // ‚úÖ CLICK DETECTOR: Alert if write amount changes dramatically
  static int64_t prev_write = 0;
  if (prev_write > 0 && frames_written > 0) {
    int64_t diff = frames_written - prev_write;
    if (diff < 0)
      diff = -diff;
    if (diff > prev_write / 2) { // >50% change
      printf("‚ö†Ô∏è  AUDIO CLICK LIKELY! Write jumped from %ld to %ld samples\n",
             prev_write, frames_written);
    }
  }
  prev_write = frames_written;
#endif
```

### How It Works

1. **Stores previous write amount** in `prev_write`
2. **Calculates change** from last frame
3. **Alerts if change >50%** of previous amount

**Example:**
```
Frame 1: wrote 800 samples ‚Üí prev_write = 800
Frame 2: wrote 900 samples ‚Üí diff = 100 (12.5%) ‚úÖ OK
Frame 3: wrote 400 samples ‚Üí diff = 500 (55.5%) ‚ö†Ô∏è  CLICK LIKELY!
```

---

## Exercise 1: Trigger Click Detection

### Method 1: Cause Frame Drop

**Add to backend.c (before audio write):**
```c
#if HANDMADE_INTERNAL
static int stall_counter = 0;
if (++stall_counter == 180) {  // Every 3 seconds at 60fps
  printf("üêå Deliberately stalling for 50ms...\n");
  struct timespec delay = {0, 50000000};  // 50ms
  nanosleep(&delay, NULL);
  stall_counter = 0;
}
#endif
```

**Expected output:**
```
üêå Deliberately stalling for 50ms...
‚ö†Ô∏è  AUDIO CLICK LIKELY! Write jumped from 800 to 1600 samples
```

**What happened:**
- Frame took 50ms instead of 16ms
- Had to catch up by writing 3x normal amount
- Waveform discontinuity ‚Üí click

### Method 2: Force Variable Writes

**Modify audio.c temporarily:**
```c
// In fill_sound_buffer function:
#if HANDMADE_INTERNAL
static int wobble = 0;
frames_to_write += (wobble++ % 2 == 0) ? 200 : -200;  // Vary amount
#endif
```

**Expected:** Constant click warnings

**Remove after testing!**

---

## Exercise 2: Enhanced Click Detector

**Improve the detector** to track more info:

```c
#if HANDMADE_INTERNAL
typedef struct {
  uint32_t total_clicks;
  uint32_t frames_since_last_click;
  int64_t worst_jump;
  float click_rate;  // clicks per second
} ClickStats;

static ClickStats g_click_stats = {0};

void detect_audio_click(int64_t frames_written, int64_t prev_write) {
  if (prev_write == 0) return;
  
  g_click_stats.frames_since_last_click++;
  
  int64_t diff = frames_written - prev_write;
  if (diff < 0) diff = -diff;
  
  if (diff > prev_write / 2) {  // >50% change
    g_click_stats.total_clicks++;
    
    // Track worst jump
    if (diff > g_click_stats.worst_jump) {
      g_click_stats.worst_jump = diff;
    }
    
    // Calculate click rate (clicks per second)
    g_click_stats.click_rate = 
      (float)g_click_stats.total_clicks / 
      ((float)g_click_stats.frames_since_last_click / 60.0f);
    
    printf("‚ö†Ô∏è  AUDIO CLICK #%u! Write: %ld ‚Üí %ld (diff: %ld, worst: %ld)\n",
           g_click_stats.total_clicks, 
           prev_write, 
           frames_written,
           diff,
           g_click_stats.worst_jump);
    
    g_click_stats.frames_since_last_click = 0;
  }
}

// Call it:
detect_audio_click(frames_written, prev_write);
prev_write = frames_written;
#endif
```

---

## Correlating Clicks with Frame Times

**Goal:** Prove clicks happen during frame drops

### Add FPS Tracking

**In backend.c main loop:**
```c
#if HANDMADE_INTERNAL
static float frame_times[300] = {0};
static int frame_time_index = 0;

frame_times[frame_time_index] = total_frame_time * 1000.0f;  // ms
frame_time_index = (frame_time_index + 1) % 300;

// When click detected, dump recent frame times:
void dump_recent_frame_times(void) {
  printf("\nüìä Last 10 frame times (ms):\n");
  for (int i = 0; i < 10; i++) {
    int idx = (frame_time_index - 10 + i + 300) % 300;
    printf("  [-%d] %.2fms", 10-i, frame_times[idx]);
    if (frame_times[idx] > 20.0f) printf(" ‚Üê SLOW!");
    printf("\n");
  }
  printf("\n");
}
#endif
```

**Expected correlation:**
```
üìä Last 10 frame times (ms):
  [-10] 16.23ms
  [-9] 16.45ms
  [-8] 16.12ms
  [-7] 15.98ms
  [-6] 16.34ms
  [-5] 35.67ms ‚Üê SLOW!  ‚Üê This caused the click!
  [-4] 16.21ms
  [-3] 16.45ms
  [-2] 16.12ms
  [-1] 16.34ms

‚ö†Ô∏è  AUDIO CLICK #3! Write: 800 ‚Üí 1600 (diff: 800)
```

---

## Debugging Strategy

When you hear a click:

```
1. Check click detector log
   ‚Üí "Write jumped from X to Y"
   
2. Check frame time log
   ‚Üí Was there a slow frame?
   
3. Determine root cause:
   a) If slow frame ‚Üí timing click (underrun)
   b) If no slow frame ‚Üí phase click (math bug)
   
4. Fix:
   a) Timing click ‚Üí increase latency or optimize game loop
   b) Phase click ‚Üí check sine wave math (running_sample_index)
```

---

## Exercise 3: Distinguish Click Types

### Test 1: Timing Click (Underrun)

**Cause:** Frame took too long

**Trigger:**
```c
// Add 100ms stall ‚Üí definitely causes underrun
nanosleep(&(struct timespec){0, 100000000}, NULL);
```

**Symptoms:**
- Click detector fires
- Frame time log shows slow frame
- `snd_pcm_delay` shows buffer ran dry

### Test 2: Phase Click (Math)

**Cause:** Wave phase reset

**Trigger** (DON'T ACTUALLY DO THIS):
```c
// BAD: Resets phase each frame
local_persist_var uint32_t running_sample_index = 0;  // Remove static!
```

**Symptoms:**
- Click detector might NOT fire (write amount constant)
- But you hear clicks anyway
- Sine wave "jumps" every frame

---

## Improving Your Detector

### Add Threshold Tuning

```c
#define CLICK_THRESHOLD_PERCENT 50  // Adjustable

if (diff > prev_write * CLICK_THRESHOLD_PERCENT / 100) {
  // Click detected
}
```

**Try:**
- `CLICK_THRESHOLD_PERCENT = 25` ‚Üí More sensitive
- `CLICK_THRESHOLD_PERCENT = 75` ‚Üí Less sensitive

### Add Waveform Sampling

**Advanced:** Sample actual waveform values

```c
#if HANDMADE_INTERNAL
void check_waveform_continuity(int16_t *samples, int count) {
  static int16_t last_sample = 0;
  
  if (last_sample != 0) {
    int16_t first = samples[0];
    int16_t diff = abs(first - last_sample);
    
    if (diff > 10000) {  // Large jump (>30% of max)
      printf("‚ö†Ô∏è  WAVEFORM DISCONTINUITY! %d ‚Üí %d (jump: %d)\n",
             last_sample, first, diff);
    }
  }
  
  last_sample = samples[count - 1];  // Save last sample
}
#endif
```

---

## Key Takeaways

1. **Clicks = waveform discontinuities**
2. **Two types:** timing (buffer) and phase (math)
3. **Your detector** tracks write amount changes (>50%)
4. **Correlate with frame times** to find root cause
5. **Fix timing clicks** with buffering, **fix phase clicks** with math

---

## Self-Check Quiz

1. **Q:** What causes a timing click?  
   **A:** Variable write amounts (buffer underrun/overrun)

2. **Q:** What causes a phase click?  
   **A:** Resetting sine wave phase each frame

3. **Q:** Where is the click detector code?  
   **A:** `audio.c:1000-1014`

4. **Q:** What threshold does it use?  
   **A:** 50% change in write amount

5. **Q:** How do you distinguish click types?  
   **A:** Check if frame time was slow (timing) or normal (phase)

---

## Next Lesson

**L4.5: Debug Visualization** ‚Äî Learn to render audio buffer state for visual debugging.

---

**Time to complete:** 45-60 minutes  
**Code modified:** audio.c, backend.c (added click tracking)  
**Competence level achieved:** Level 4 (Can diagnose clicks)
