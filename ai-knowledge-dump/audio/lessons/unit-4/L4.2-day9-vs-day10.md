# L4.2: Day 9 vs Day 10 Strategy (Reactive vs Predictive)

**Unit:** 4 - Error Handling & Debugging Audio Failures  
**Duration:** 90-120 minutes  
**Prerequisites:** L3.4 (Avail vs Delay), L2.6 (Latency)  
**Connects to:** L4.4 (Click Detector), L4.5 (Debug Visualization)

---

## Learning Objectives

By the end of this lesson, you will be able to:

1. Explain the difference between Day 9 (reactive) and Day 10 (predictive) audio strategies
2. Understand when to use `snd_pcm_avail()` vs `snd_pcm_delay()`
3. Identify which strategy your code is using
4. Compare audio quality between both approaches
5. Debug timing issues using cursor positions

---

## The Two Philosophies

Casey's Handmade Hero had two different approaches to audio buffering:

### Day 9: "Write What's Available" (Reactive)

```
Game: "Hey ALSA, how much space do you have?"
ALSA: "I can take 800 samples"
Game: "OK, here's 800 samples"
```

**Analogy:** Like filling a water bucket — you pour what fits, no guessing.

### Day 10: "Predict Where Cursor Will Be" (Predictive)

```
Game: "I'll finish this frame in 16ms, where will the play cursor be then?"
Game: *calculates* "It'll be at sample 12800, so I'll write from 12800 to 13600"
ALSA: *might be slightly off, but close*
```

**Analogy:** Like throwing a football — you aim where the receiver *will be*, not where they *are*.

---

## Your Code: Dual-Mode Implementation

**From audio.c:224-230** (feature detection):
```c
bool linux_audio_has_latency_measurement(void) {
  return SndPcmDelay_ != AlsaSndPcmDelayStub;
}
```

**Translation:**
- If `snd_pcm_delay` loaded → Day 10 mode
- If stub → Day 9 mode (fallback)

---

## Day 9 Strategy: Availability-Based

### How It Works

**Code location:** `audio.c:397-603`

```c
// Step 1: Ask how many frames we CAN write
long frames_available = SndPcmAvail(handle);
if (frames_available < 0) {
  // Error handling...
  return;
}

// Step 2: Calculate how many we SHOULD write this frame
int frames_to_write = sound_output->samples_per_second / sound_output->game_update_hz;

// Step 3: Only write if we can fit the whole frame
if (frames_available >= frames_to_write) {
  // Generate audio samples...
  SndPcmWritei(handle, samples, frames_to_write);
}
```

### Key Characteristics

| Aspect | Behavior |
|--------|----------|
| **Decision** | Based on current buffer state |
| **Safety** | Very safe — never writes too much |
| **Latency** | Can drift higher (buffer fills up) |
| **Timing** | Reactive — responds to actual state |
| **Best for** | Slow machines, unreliable timing |

### The Problem

Imagine your game loop is slightly inconsistent:
- Frame 1: 15ms
- Frame 2: 17ms (oops, took longer!)
- Frame 3: 16ms

**What happens:**
```
Frame 1: buffer has 800 space → write 800 samples
Frame 2: buffer has 750 space → write 800 samples (fits!)
Frame 3: buffer has 650 space → write 800 samples

// Over time, buffer fills up more than intended
// Latency increases from 33ms to 50ms to 66ms...
```

**The drift:** You're always playing catch-up, never "targeting" a specific latency.

---

## Day 10 Strategy: Prediction-Based

### How It Works

**Code location:** `audio.c:605-753`

```c
// Step 1: Where is the play cursor RIGHT NOW?
snd_pcm_sframes_t delay_frames = 0;
SndPcmDelay(handle, &delay_frames);
int64_t play_cursor = running_sample_index - delay_frames;

// Step 2: How long until next frame?
float seconds_until_flip = target_seconds_per_frame - work_seconds;

// Step 3: Where will play cursor be then?
int64_t expected_sound_bytes_per_frame = ...;
int64_t expected_frame_boundary = 
  play_cursor + (seconds_until_flip * samples_per_second);

// Step 4: Write FROM expected boundary
int64_t target_cursor = expected_frame_boundary + audio_latency_samples;
int frames_to_write = target_cursor - running_sample_index;

// Generate and write
SndPcmWritei(handle, samples, frames_to_write);
```

### Key Characteristics

| Aspect | Behavior |
|--------|----------|
| **Decision** | Based on predicted future state |
| **Safety** | Can be wrong if prediction fails |
| **Latency** | Maintains target (e.g., 33ms) |
| **Timing** | Proactive — aims for goal |
| **Best for** | Stable frame times, low latency |

### The Advantage

```
Target latency: 33ms (always)

Frame 1: predict cursor at +16ms → write to maintain 33ms
Frame 2: predict cursor at +16ms → write to maintain 33ms
Frame 3: predict cursor at +16ms → write to maintain 33ms

// Latency stays at 33ms (±5ms) consistently
```

**The goal:** Active targeting, not reactive filling.

---

## Comparing the Code

### Day 9: Check Availability

```c
// From audio.c:466-473
long frames_available = SndPcmAvail(handle);

// Safety check
if (frames_available >= frames_to_write) {
  // Write exactly one frame's worth
  SndPcmWritei(handle, samples, frames_to_write);
}
```

**Mental model:** "Can I fit this?"

### Day 10: Calculate Target

```c
// From audio.c:680-715
snd_pcm_sframes_t delay_frames = 0;
SndPcmDelay(handle, &delay_frames);

int64_t play_cursor = running_sample_index - delay_frames;
int64_t target_cursor = play_cursor + latency_samples + predicted_advancement;

int frames_to_write = target_cursor - running_sample_index;
SndPcmWritei(handle, samples, frames_to_write);
```

**Mental model:** "Where should I be?"

---

## Exercise 1: Disable Day 10, Compare Audio

**Goal:** Hear the difference between strategies

### Step 1: Force Day 9 Mode

**Edit audio.c:224:**
```c
bool linux_audio_has_latency_measurement(void) {
  return false;  // Force Day 9 even if snd_pcm_delay exists
}
```

### Step 2: Rebuild and Run

```bash
./build.sh
./build/handmade-hero
```

**Watch console output:**
```
⚠️  Mode: Day 9 (Availability-Based)
Latency measurement disabled
```

### Step 3: Listen for 30 Seconds

Notice:
- Does audio feel slightly "laggy"?
- Do you notice latency drift?

### Step 4: Re-Enable Day 10

**Restore audio.c:224:**
```c
bool linux_audio_has_latency_measurement(void) {
  return SndPcmDelay_ != AlsaSndPcmDelayStub;  // Original
}
```

### Step 5: Rebuild and Compare

```bash
./build.sh
./build/handmade-hero
```

**Notice:**
- Does audio feel more "responsive"?
- Does latency stay more consistent?

---

## Exercise 2: Measure Latency Drift

**Goal:** Quantify how much Day 9 drifts

### Add Logging to Day 9 Path

**Edit audio.c:~460** (in Day 9 function):
```c
#if HANDMADE_INTERNAL
static int frame_counter = 0;
static float latency_sum = 0;

if (++frame_counter % 60 == 0) {  // Every 60 frames
  float avg_latency_ms = latency_sum / 60.0f;
  printf("[Day 9] Avg latency: %.1fms (target: 33ms)\n", avg_latency_ms);
  latency_sum = 0;
}

// Estimate current latency
long frames_available = SndPcmAvail(handle);
long frames_in_buffer = buffer_capacity - frames_available;
float current_latency_ms = (float)frames_in_buffer / 48000.0f * 1000.0f;
latency_sum += current_latency_ms;
#endif
```

**Expected output (with Day 9 enabled):**
```
[Day 9] Avg latency: 35.2ms (target: 33ms)
[Day 9] Avg latency: 38.1ms (target: 33ms)  // Drifting up!
[Day 9] Avg latency: 41.5ms (target: 33ms)  // Still climbing
```

**With Day 10:**
```
[Day 10] Avg latency: 33.1ms (target: 33ms)
[Day 10] Avg latency: 32.9ms (target: 33ms)  // Stable!
[Day 10] Avg latency: 33.2ms (target: 33ms)
```

---

## When Day 10 Can Fail

### Scenario 1: Unpredictable Frame Times

If your game loop does this:
```
Frame 1: 10ms
Frame 2: 30ms (!!)  // Prediction was WAY off
Frame 3: 12ms
```

**What happens:**
```c
// We predicted: "cursor will advance 800 samples"
// Reality: cursor advanced 1500 samples (frame took longer)

// Result: We wrote to the WRONG position
//  → audio gap or double-write
//  → audible click/pop
```

**Solution:** Day 10 needs *stable frame times*. That's why Casey emphasizes fixed FPS!

### Scenario 2: System Suspend

```
User closes laptop lid
→ System suspends for 10 minutes
→ System resumes

Day 10: "I predicted cursor at sample 500,000,000"
Reality: "Cursor is at sample 100,000"

→ MASSIVE MISMATCH → clicks/pops
```

**Solution:** Detect suspend/resume, reset counters.

---

## The `SndPcmDelay()` Function

**What it tells you:** How many frames are queued for playback

```c
snd_pcm_sframes_t delay_frames = 0;
int err = SndPcmDelay(handle, &delay_frames);

// Example values:
// delay_frames = 1600  →  33ms of audio in buffer
// delay_frames = 800   →  16ms of audio in buffer
// delay_frames = 0     →  UNDERRUN IMMINENT!
```

**From delay to play cursor:**
```c
int64_t play_cursor = running_sample_index - delay_frames;
```

**Why subtract?**
- `running_sample_index` = total samples written
- `delay_frames` = samples not yet played
- **play_cursor** = samples actually heard by user

**Example:**
```
running_sample_index = 10,000 samples written
delay_frames = 800 samples in buffer

play_cursor = 10,000 - 800 = 9,200
  → User is hearing sample 9200
  → Samples 9201-10000 are queued
```

---

## Debugging with Cursors

### Visualizing the Buffer State

```
Day 9 (Availability):
  [======== BUFFER ========]
   ^                      ^
   Play                  Write
   (unknown)            (fill available space)

Day 10 (Prediction):
  [======== BUFFER ========]
   ^          ^           ^
   Play     Target       Write
  (measured) (calculated) (precise placement)
```

### Checking Your Code

**Where cursors are calculated** (audio.c):

**Day 9:**
```c
// No play cursor calculation
// Just: frames_available = SndPcmAvail(handle);
```

**Day 10:**
```c
// Line ~680
snd_pcm_sframes_t delay_frames = 0;
SndPcmDelay(handle, &delay_frames);
int64_t play_cursor_sample = running_index - delay_frames;

// Line ~715
int64_t target_cursor = play_cursor_sample + latency_target + advancement;
```

---

## Key Differences Summary

| Feature | Day 9 (Reactive) | Day 10 (Predictive) |
|---------|------------------|---------------------|
| **Primary API** | `snd_pcm_avail()` | `snd_pcm_delay()` |
| **Decision Logic** | "How much can I write?" | "Where should I write?" |
| **Latency Control** | Drifts over time | Maintains target |
| **Frame Time Req** | Tolerates variation | Needs stability |
| **Implementation** | Simple (20 lines) | Complex (50 lines) |
| **Failure Mode** | Latency creep | Clicks if prediction wrong |
| **Your Code** | `audio.c:397-603` | `audio.c:605-753` |

---

## Exercise 3: Inspect Your Current Mode

**Goal:** Verify which strategy is active

### Add Startup Debug

**In audio.c:~250** (after ALSA init):
```c
#if HANDMADE_INTERNAL
if (linux_audio_has_latency_measurement()) {
  printf("✅ Day 10 Mode: Predictive buffering enabled\n");
  printf("   Using snd_pcm_delay() for cursor tracking\n");
  printf("   Target latency: %dms\n", 
         (int)((float)sound_output->latency_sample_count / 48000.0f * 1000.0f));
} else {
  printf("⚠️  Day 9 Mode: Reactive buffering\n");
  printf("   Using snd_pcm_avail() only\n");
  printf("   Latency will drift\n");
}
#endif
```

**Run your game:**
```bash
./build/handmade-hero
```

**Expected output:**
```
✅ Day 10 Mode: Predictive buffering enabled
   Using snd_pcm_delay() for cursor tracking
   Target latency: 33ms
```

---

## When to Use Each Strategy

### Use Day 9 When:
- Frame times are highly variable
- Running on slow hardware
- Stability > low latency
- Debugging timing issues (simpler)

### Use Day 10 When:
- Frame times are stable (fixed FPS)
- Want consistent low latency
- Have `snd_pcm_delay()` available
- Willing to handle edge cases

### Your Code's Smart Choice:
```c
if (snd_pcm_delay exists) {
  use_day10();  // Better when available
} else {
  use_day9();   // Safe fallback
}
```

**This is good engineering!** Feature detection with graceful degradation.

---

## Self-Check Quiz

1. **Q:** What does `snd_pcm_avail()` return?  
   **A:** Number of frames available to write

2. **Q:** What does `snd_pcm_delay()` return?  
   **A:** Number of frames queued for playback

3. **Q:** Which strategy maintains target latency?  
   **A:** Day 10 (predictive)

4. **Q:** Which is safer on unstable frame rates?  
   **A:** Day 9 (reactive)

5. **Q:** Where is your fallback detection code?  
   **A:** `audio.c:224-230` (linux_audio_has_latency_measurement)

---

## Key Takeaways

1. **Day 9 = reactive** (respond to current state)
2. **Day 10 = predictive** (aim for future state)
3. **Your code supports both** with automatic fallback
4. **Day 10 requires stable frame times** to work well
5. **`snd_pcm_delay()` is the key difference** between modes

---

## Next Lesson

**L4.3: Initialization Failure Modes** — Learn what can go wrong during ALSA setup and how to handle it.

---

**Time to complete:** 1.5-2 hours  
**Code modified:** audio.c (added debug logging)  
**Competence level achieved:** Level 4 (Can debug timing differences)
