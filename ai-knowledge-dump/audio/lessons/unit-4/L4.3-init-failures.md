# L4.3: Initialization Failure Modes

**Unit:** 4 - Error Handling & Debugging Audio Failures  
**Duration:** 60-90 minutes  
**Prerequisites:** L2.3 (ALSA Init), L4.1 (Error Codes)  
**Connects to:** L1.3 (Graceful Degradation), L6.5 (Production Debugging)

---

## Learning Objectives

By the end of this lesson, you will be able to:

1. Identify each stage of ALSA initialization
2. Recognize failure modes at each stage
3. Implement proper error handling for initialization
4. Provide helpful error messages for users
5. Detect system configuration issues (PulseAudio vs ALSA)

---

## The Initialization Pipeline

Audio initialization has **5 critical stages**. Each can fail independently:

```
1. Load Library (dlopen)
   ↓
2. Load Symbols (dlsym)
   ↓
3. Open Device (snd_pcm_open)
   ↓
4. Configure Device (snd_pcm_set_params)
   ↓
5. Prepare Device (snd_pcm_prepare)
```

**Your code location:** `audio.c:133-362`

---

## Stage 1: Loading the ALSA Library

### The Code

**From audio.c:133-145:**
```c
void linux_load_alsa(void) {
  void *alsa_lib = dlopen("libasound.so.2", RTLD_NOW);
  if (!alsa_lib) {
    printf("⚠️  ALSA library not found: %s\n", dlerror());
    printf("   Continuing without audio...\n");
    return;
  }
  
  g_linux_sound_output.alsa_library = alsa_lib;
  // ...
}
```

### Common Failures

| Error | Cause | Solution |
|-------|-------|----------|
| `cannot open shared object file` | ALSA not installed | `sudo apt install libasound2` |
| `wrong ELF class` | 32-bit game, 64-bit ALSA | Rebuild with correct arch |
| `version mismatch` | Incompatible ALSA version | Update or downgrade ALSA |

### Testing Failure

**Deliberately break it:**
```c
void *alsa_lib = dlopen("libasound.so.999", RTLD_NOW);  // Bad version
```

**Expected output:**
```
⚠️  ALSA library not found: libasound.so.999: cannot open shared object file
   Continuing without audio...
```

**Restore:**
```c
void *alsa_lib = dlopen("libasound.so.2", RTLD_NOW);  // Original
```

---

## Stage 2: Loading Symbols

### The Code

**From audio.c:147-200:**
```c
*(void **)(&SndPcmOpen_) = dlsym(alsa_lib, "snd_pcm_open");
if (!SndPcmOpen_) {
  printf("❌ Failed to load snd_pcm_open: %s\n", dlerror());
  // Continue loading other symbols...
}
```

### Common Failures

| Error | Cause | Solution |
|-------|-------|----------|
| `undefined symbol` | Symbol doesn't exist in lib | Wrong ALSA version |
| `symbol renamed` | API changed | Check ALSA changelog |
| `function removed` | Deprecated function | Use alternative API |

### Improving Error Handling

**Current code** (audio.c:147-200) loads symbols but doesn't check each one:

**Better version:**
```c
bool linux_load_alsa_symbols(void *alsa_lib) {
  struct {
    void **func_ptr;
    const char *name;
  } symbols[] = {
    {(void **)&SndPcmOpen_, "snd_pcm_open"},
    {(void **)&SndPcmSetParams_, "snd_pcm_set_params"},
    {(void **)&SndPcmWritei_, "snd_pcm_writei"},
    {(void **)&SndPcmClose_, "snd_pcm_close"},
    {(void **)&SndStrerror_, "snd_strerror"},
    {(void **)&SndPcmAvail_, "snd_pcm_avail"},
    {(void **)&SndPcmRecover_, "snd_pcm_recover"},
  };
  
  bool all_loaded = true;
  for (size_t i = 0; i < ArraySize(symbols); i++) {
    *symbols[i].func_ptr = dlsym(alsa_lib, symbols[i].name);
    if (!*symbols[i].func_ptr) {
      printf("❌ Missing symbol: %s\n", symbols[i].name);
      all_loaded = false;
    }
  }
  
  return all_loaded;
}
```

**Why this is better:**
- Checks each symbol individually
- Reports which specific function failed
- Easier to maintain (add/remove symbols)

---

## Stage 3: Opening the PCM Device

### The Code

**From audio.c:232-246:**
```c
int err = SndPcmOpen(
  &g_linux_sound_output.handle,
  "default",                          // Device name
  LINUX_SND_PCM_STREAM_PLAYBACK,     // Direction (output)
  0                                   // Flags (blocking)
);

if (err < 0) {
  fprintf(stderr, "❌ Failed to open ALSA device 'default': %s\n", 
          SndStrerror(err));
  return false;
}
```

### Common Failures

#### Error 1: `-EBUSY` (Device In Use)

**Cause:** Another application is using the audio device

**Debug commands:**
```bash
# Find which process is using audio
fuser -v /dev/snd/*

# Output:
#   /dev/snd/pcmC0D0p:  viavi    2451 F.... pulseaudio
```

**Solution:**
```c
if (err == -EBUSY) {
  fprintf(stderr, "\n┌─────────────────────────────────────────┐\n");
  fprintf(stderr, "│ ❌ Audio device is busy                 │\n");
  fprintf(stderr, "├─────────────────────────────────────────┤\n");
  fprintf(stderr, "│ Another app is using audio. Try:       │\n");
  fprintf(stderr, "│                                         │\n");
  fprintf(stderr, "│ 1. Close music players (Spotify, etc)  │\n");
  fprintf(stderr, "│ 2. Stop other games                     │\n");
  fprintf(stderr, "│ 3. Run: fuser -v /dev/snd/*            │\n");
  fprintf(stderr, "└─────────────────────────────────────────┘\n\n");
}
```

#### Error 2: `-ENOENT` (Device Not Found)

**Cause:** Wrong device name or no sound card

**Debug commands:**
```bash
# List PCM devices
aplay -L

# List sound cards
cat /proc/asound/cards
```

**Solution:**
```c
if (err == -ENOENT || err == -ENODEV) {
  fprintf(stderr, "\n┌─────────────────────────────────────────┐\n");
  fprintf(stderr, "│ ❌ Audio device not found               │\n");
  fprintf(stderr, "├─────────────────────────────────────────┤\n");
  fprintf(stderr, "│ Check:                                  │\n");
  fprintf(stderr, "│ 1. Is sound card detected?              │\n");
  fprintf(stderr, "│    Run: cat /proc/asound/cards          │\n");
  fprintf(stderr, "│                                         │\n");
  fprintf(stderr, "│ 2. Is ALSA configured?                  │\n");
  fprintf(stderr, "│    Run: aplay -L                        │\n");
  fprintf(stderr, "└─────────────────────────────────────────┘\n\n");
}
```

#### Error 3: PulseAudio Conflict

**Cause:** PulseAudio is running and blocks direct ALSA access

**Detection:**
```bash
# Check if PulseAudio is running
pgrep -a pulseaudio
```

**Solution in code:**
```c
if (err == -EBUSY || err == -EACCES) {
  // Check if PulseAudio is running
  FILE *pulse_check = popen("pgrep pulseaudio", "r");
  if (pulse_check) {
    char buf[16];
    if (fgets(buf, sizeof(buf), pulse_check)) {
      fprintf(stderr, "\n⚠️  PulseAudio detected!\n\n");
      fprintf(stderr, "This game uses ALSA directly, which conflicts with PulseAudio.\n");
      fprintf(stderr, "\nOptions:\n");
      fprintf(stderr, "  1. Use PulseAudio plugin: device 'pulse' instead of 'default'\n");
      fprintf(stderr, "  2. Stop PulseAudio: pulseaudio --kill\n");
      fprintf(stderr, "  3. Wait for game to support PulseAudio\n\n");
    }
    pclose(pulse_check);
  }
}
```

---

## Stage 4: Configuring the Device

### The Code

**From audio.c:269-299:**
```c
int32_t latency_sample_count = game_update_hz * FRAMES_OF_AUDIO_LATENCY;
int32_t latency_microseconds = (latency_sample_count * 1000000) / samples_per_second;

int err = SndPcmSetParams(
  g_linux_sound_output.handle,
  LINUX_SND_PCM_FORMAT_S16_LE,         // 16-bit signed
  LINUX_SND_PCM_ACCESS_RW_INTERLEAVED, // Stereo interleaved
  2,                                    // Channels (stereo)
  (unsigned int)samples_per_second,    // Sample rate (48000)
  1,                                    // Soft resample (yes)
  (unsigned int)latency_microseconds   // Latency (33ms)
);

if (err < 0) {
  fprintf(stderr, "❌ Failed to set ALSA parameters: %s\n", SndStrerror(err));
  SndPcmClose(g_linux_sound_output.handle);
  return false;
}
```

### Common Failures

#### Error 1: `-EINVAL` (Invalid Sample Rate)

**Cause:** Hardware doesn't support requested sample rate

**Debug:**
```bash
# Check supported formats/rates
aplay -v /dev/zero --duration=1
```

**Solution:**
```c
if (err == -EINVAL) {
  fprintf(stderr, "\n❌ Hardware doesn't support these parameters:\n");
  fprintf(stderr, "   Format:       S16_LE (16-bit signed)\n");
  fprintf(stderr, "   Sample rate:  %d Hz\n", samples_per_second);
  fprintf(stderr, "   Channels:     2 (stereo)\n");
  fprintf(stderr, "\nTrying fallback rates...\n");
  
  int fallback_rates[] = {48000, 44100, 22050, 16000};
  for (size_t i = 0; i < ArraySize(fallback_rates); i++) {
    printf("  Trying %d Hz... ", fallback_rates[i]);
    err = SndPcmSetParams(handle, LINUX_SND_PCM_FORMAT_S16_LE,
                          LINUX_SND_PCM_ACCESS_RW_INTERLEAVED,
                          2, fallback_rates[i], 1, latency_microseconds);
    if (err == 0) {
      printf("✅ SUCCESS\n");
      sound_output->samples_per_second = fallback_rates[i];
      break;
    } else {
      printf("❌ %s\n", SndStrerror(err));
    }
  }
}
```

#### Error 2: `-EINVAL` (Latency Too Low)

**Cause:** Requested latency is too aggressive for hardware

**Solution:**
```c
if (err == -EINVAL) {
  // Try increasing latency
  int32_t original_latency = latency_microseconds;
  
  for (int multiplier = 2; multiplier <= 8; multiplier++) {
    latency_microseconds = original_latency * multiplier;
    printf("  Trying %dms latency... ", latency_microseconds / 1000);
    
    err = SndPcmSetParams(handle, ...);
    if (err == 0) {
      printf("✅ SUCCESS\n");
      sound_output->latency_sample_count = 
        (latency_microseconds * samples_per_second) / 1000000;
      break;
    } else {
      printf("❌ %s\n", SndStrerror(err));
    }
  }
}
```

---

## Stage 5: Preparing the Device

### The Code

**From audio.c:319-328:**
```c
err = SndPcmPrepare(g_linux_sound_output.handle);
if (err < 0) {
  fprintf(stderr, "❌ Failed to prepare ALSA device: %s\n", SndStrerror(err));
  SndPcmClose(g_linux_sound_output.handle);
  return false;
}
```

### Common Failures

This stage rarely fails if previous stages succeeded. But if it does:

```c
if (err < 0) {
  fprintf(stderr, "❌ Failed to prepare device: %s\n", SndStrerror(err));
  fprintf(stderr, "\nThis usually means hardware configuration issue.\n");
  fprintf(stderr, "Try:\n");
  fprintf(stderr, "  sudo alsactl restore  (restore ALSA mixer settings)\n");
  fprintf(stderr, "  sudo alsactl init     (reinitialize ALSA)\n");
}
```

---

## Exercise 1: Test Each Failure Mode

### Test 1: Missing Library

```bash
# Rename the library
sudo mv /usr/lib/x86_64-linux-gnu/libasound.so.2 \
         /usr/lib/x86_64-linux-gnu/libasound.so.2.bak

# Run game
./build/handmade-hero
# Expected: "ALSA library not found"

# Restore
sudo mv /usr/lib/x86_64-linux-gnu/libasound.so.2.bak \
         /usr/lib/x86_64-linux-gnu/libasound.so.2
```

### Test 2: Device Busy

```bash
# Terminal 1: Block the device
speaker-test -c 2 -r 48000 -f 1000

# Terminal 2: Run game
./build/handmade-hero
# Expected: "Audio device is busy"

# Stop speaker-test (Ctrl+C in Terminal 1)
```

### Test 3: Invalid Sample Rate

**Edit audio.c temporarily:**
```c
// Change from:
(unsigned int)samples_per_second,    // 48000

// To:
999999,    // ❌ Invalid rate
```

**Run:**
```bash
./build.sh && ./build/handmade-hero
# Expected: "Failed to set ALSA parameters: Invalid argument"
```

**Restore original code!**

---

## Exercise 2: Production-Ready Error Handler

**Add to audio.c:**
```c
void linux_audio_init_failed(const char *stage, int err, const char *device) {
  fprintf(stderr, "\n╔═══════════════════════════════════════════════════╗\n");
  fprintf(stderr, "║ ❌ AUDIO INITIALIZATION FAILED                    ║\n");
  fprintf(stderr, "╠═══════════════════════════════════════════════════╣\n");
  fprintf(stderr, "║ Stage:  %s\n", stage);
  if (err) {
    fprintf(stderr, "║ Error:  %s (%d)\n", SndStrerror(err), err);
  }
  if (device) {
    fprintf(stderr, "║ Device: %s\n", device);
  }
  fprintf(stderr, "╠═══════════════════════════════════════════════════╣\n");
  fprintf(stderr, "║ DIAGNOSTICS                                       ║\n");
  fprintf(stderr, "╠═══════════════════════════════════════════════════╣\n");
  
  // Auto-run diagnostics
  fprintf(stderr, "║ Sound cards detected:                             ║\n");
  system("cat /proc/asound/cards | sed 's/^/║   /'");
  
  fprintf(stderr, "║                                                   ║\n");
  fprintf(stderr, "║ ALSA devices:                                     ║\n");
  system("aplay -L | head -5 | sed 's/^/║   /'");
  
  fprintf(stderr, "║                                                   ║\n");
  fprintf(stderr, "║ Processes using audio:                            ║\n");
  system("fuser -v /dev/snd/* 2>&1 | sed 's/^/║   /'");
  
  fprintf(stderr, "╠═══════════════════════════════════════════════════╣\n");
  fprintf(stderr, "║ The game will continue WITHOUT audio.            ║\n");
  fprintf(stderr, "╚═══════════════════════════════════════════════════╝\n\n");
}
```

**Use it:**
```c
int err = SndPcmOpen(&handle, "default", LINUX_SND_PCM_STREAM_PLAYBACK, 0);
if (err < 0) {
  linux_audio_init_failed("Opening PCM device", err, "default");
  return false;
}
```

---

## Initialization Checklist

Use this checklist when debugging init failures:

```
□ Is ALSA installed?
  → dpkg -l | grep libasound2

□ Is a sound card detected?
  → cat /proc/asound/cards

□ Can aplay work?
  → aplay /usr/share/sounds/alsa/Front_Center.wav

□ Is PulseAudio blocking?
  → pgrep pulseaudio

□ Are permissions correct?
  → groups | grep audio

□ Is the device name correct?
  → aplay -L | grep default

□ Are sample rate/format supported?
  → aplay -v /dev/zero --duration=1
```

---

## Key Takeaways

1. **Initialization has 5 independent stages** — each can fail
2. **`dlopen` failure is common** on minimal systems
3. **`-EBUSY` means device conflict** — usually PulseAudio
4. **`-EINVAL` means bad parameters** — try fallbacks
5. **Always provide diagnostic info** — don't just say "failed"

---

## Self-Check Quiz

1. **Q:** What does `dlopen("libasound.so.2", RTLD_NOW)` do?  
   **A:** Loads the ALSA library into memory

2. **Q:** What's the most common cause of `-EBUSY`?  
   **A:** Another application (often PulseAudio) is using the device

3. **Q:** How do you check which process is using audio?  
   **A:** `fuser -v /dev/snd/*`

4. **Q:** What does `-EINVAL` during `snd_pcm_set_params` mean?  
   **A:** Hardware doesn't support the requested parameters

5. **Q:** Where should you clean up on init failure?  
   **A:** Close any opened resources (handle, library) before returning false

---

## Next Lesson

**L4.4: The Click Detector** — Learn to detect and diagnose audio discontinuities.

---

**Time to complete:** 1-1.5 hours  
**Code modified:** audio.c (added error diagnostics)  
**Competence level achieved:** Level 4 (Can debug init failures)
