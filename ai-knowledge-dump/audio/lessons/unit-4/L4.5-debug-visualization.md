# L4.5: Debug Visualization & Audio Markers

**Unit:** 4 - Error Handling & Debugging Audio Failures  
**Duration:** 60-75 minutes  
**Prerequisites:** L3.4 (Avail vs Delay), L4.2 (Day 9 vs 10)  
**Connects to:** Unit 5 (Tuning Latency), Casey's Day 19-20

---

## Learning Objectives

1. Understand Casey's debug marker system
2. Interpret the `LinuxDebugAudioMarker` structure
3. Visualize audio buffer state over time
4. Use markers to diagnose timing issues
5. Correlate audio state with frame timing

---

## Casey's Day 19: Audio Cursor Tracking

Casey added visual debugging in Day 19 of Handmade Hero to answer:

- **Where is the play cursor?** (what user is hearing)
- **Where is the write cursor?** (where we're writing)
- **How much latency do we have?** (gap between them)
- **Is timing stable?** (does gap stay constant?)

**Your implementation:** `audio.h:215-250`

---

## The Debug Marker Structure

**From audio.h:215-250:**

```c
typedef struct {
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ“Š CAPTURED BEFORE AUDIO WRITE (Output State)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  snd_pcm_sframes_t delay_frames;   // Frames queued for playback
  snd_pcm_sframes_t avail_frames;   // Frames we can write
  
  // Derived cursors:
  int64_t play_cursor_sample;    // running_index - delay
  int64_t write_cursor_sample;   // running_index + avail
  
  // Where we wrote:
  int64_t location;      // running_sample_index BEFORE write
  int64_t sample_count;  // How many samples we wrote
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ¯ PREDICTION (Expected State)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  int64_t expected_flip_play_cursor;  // Where cursor should be after flip
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ“¸ CAPTURED AFTER SCREEN FLIP (Flip State)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  snd_pcm_sframes_t flip_delay_frames;  // Delay after glXSwapBuffers
  snd_pcm_sframes_t flip_avail_frames;  // Avail after flip
  
  int64_t flip_play_cursor;    // Actual cursor position after flip
  int64_t flip_write_cursor;   // Write cursor after flip
} LinuxDebugAudioMarker;
```

---

## Visualizing the Buffer State

### ASCII Visualization

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ALSA Ring Buffer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                 â”‚
â”‚  [====================================]                         â”‚
â”‚   ^                  ^                ^                         â”‚
â”‚   â”‚                  â”‚                â”‚                         â”‚
â”‚   Play              Running          Write                      â”‚
â”‚  Cursor             Index            Cursor                     â”‚
â”‚  (heard)           (written)        (can write)                 â”‚
â”‚                                                                 â”‚
â”‚  â—„â”€â”€â”€â”€ Latency â”€â”€â”€â”€â–º                                           â”‚
â”‚     (delay_frames)                                             â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Healthy vs Unhealthy States

**Healthy (stable latency):**
```
Frame 1:  [====|--------]  Latency: 800 samples (16ms)
Frame 2:  [====|--------]  Latency: 800 samples (16ms)
Frame 3:  [====|--------]  Latency: 800 samples (16ms)
```

**Unhealthy (drifting):**
```
Frame 1:  [====|--------]  Latency: 800 samples (16ms)
Frame 2:  [=====|-------]  Latency: 1000 samples (20ms)
Frame 3:  [======|------]  Latency: 1200 samples (25ms)  â† Growing!
```

**Underrun imminent:**
```
Frame 1:  [=|------------]  Latency: 200 samples (4ms)  â† TOO LOW!
Frame 2:  [-------------]  Latency: 0 samples         â† UNDERRUN!
```

---

## Your Marker Array

**From audio.h:252-254:**
```c
#define MAX_DEBUG_AUDIO_MARKERS 30
extern LinuxDebugAudioMarker g_debug_audio_markers[MAX_DEBUG_AUDIO_MARKERS];
extern int g_debug_marker_index;
```

**Stores 30 frames** of history (0.5 seconds at 60fps)

---

## Exercise 1: Add Marker Logging

**Goal:** Print marker data to console

**Add to audio.c** (in fill_sound_buffer function):

```c
#if HANDMADE_INTERNAL
void linux_log_audio_marker(LinuxDebugAudioMarker *marker, int index) {
  printf("\nâ”Œâ”€ Frame %d Audio Marker â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n", index);
  
  // Before write
  printf("â”‚ BEFORE WRITE:                                    â”‚\n");
  printf("â”‚   Delay:  %ld frames (%.1fms)                   â”‚\n",
         (long)marker->delay_frames,
         (float)marker->delay_frames / 48000.0f * 1000.0f);
  printf("â”‚   Avail:  %ld frames                            â”‚\n",
         (long)marker->avail_frames);
  printf("â”‚   Play cursor:  %ld                             â”‚\n",
         marker->play_cursor_sample);
  printf("â”‚   Write cursor: %ld                             â”‚\n",
         marker->write_cursor_sample);
  
  // What we wrote
  printf("â”‚                                                  â”‚\n");
  printf("â”‚ WROTE:                                           â”‚\n");
  printf("â”‚   Location: %ld                                 â”‚\n",
         marker->location);
  printf("â”‚   Count:    %ld samples (%.1fms)                â”‚\n",
         marker->sample_count,
         (float)marker->sample_count / 48000.0f * 1000.0f);
  
  // After flip
  printf("â”‚                                                  â”‚\n");
  printf("â”‚ AFTER FLIP:                                      â”‚\n");
  printf("â”‚   Delay:  %ld frames (%.1fms)                   â”‚\n",
         (long)marker->flip_delay_frames,
         (float)marker->flip_delay_frames / 48000.0f * 1000.0f);
  printf("â”‚   Play cursor:  %ld                             â”‚\n",
         marker->flip_play_cursor);
  
  // Analysis
  printf("â”‚                                                  â”‚\n");
  printf("â”‚ ANALYSIS:                                        â”‚\n");
  int64_t predicted = marker->expected_flip_play_cursor;
  int64_t actual = marker->flip_play_cursor;
  int64_t error = actual - predicted;
  printf("â”‚   Prediction error: %ld samples (%.1fms)        â”‚\n",
         error,
         (float)error / 48000.0f * 1000.0f);
  
  printf("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n");
}

// Call every 60 frames (1 second at 60fps):
if (g_debug_marker_index % 60 == 0) {
  linux_log_audio_marker(
    &g_debug_audio_markers[(g_debug_marker_index - 1) % MAX_DEBUG_AUDIO_MARKERS],
    g_debug_marker_index
  );
}
#endif
```

---

## Exercise 2: Latency Stability Check

**Goal:** Detect latency drift automatically

```c
#if HANDMADE_INTERNAL
void check_latency_stability(void) {
  if (g_debug_marker_index < 60) return;  // Need history
  
  // Analyze last 60 frames
  float latencies[60];
  for (int i = 0; i < 60; i++) {
    int idx = (g_debug_marker_index - 60 + i) % MAX_DEBUG_AUDIO_MARKERS;
    latencies[i] = (float)g_debug_audio_markers[idx].delay_frames;
  }
  
  // Calculate stats
  float sum = 0, min = latencies[0], max = latencies[0];
  for (int i = 0; i < 60; i++) {
    sum += latencies[i];
    if (latencies[i] < min) min = latencies[i];
    if (latencies[i] > max) max = latencies[i];
  }
  float avg = sum / 60.0f;
  float range = max - min;
  
  printf("\nğŸ“Š Latency Stability (last 60 frames):\n");
  printf("   Avg: %.1f samples (%.1fms)\n", avg, avg / 48000.0f * 1000.0f);
  printf("   Min: %.1f samples (%.1fms)\n", min, min / 48000.0f * 1000.0f);
  printf("   Max: %.1f samples (%.1fms)\n", max, max / 48000.0f * 1000.0f);
  printf("   Range: %.1f samples (%.1fms)\n", range, range / 48000.0f * 1000.0f);
  
  if (range < avg * 0.1f) {
    printf("   âœ… STABLE (range < 10%% of avg)\n");
  } else if (range < avg * 0.25f) {
    printf("   âš ï¸  SLIGHTLY UNSTABLE (range 10-25%% of avg)\n");
  } else {
    printf("   âŒ UNSTABLE (range > 25%% of avg)\n");
  }
}

// Call every 5 seconds:
if (g_debug_marker_index % 300 == 0) {
  check_latency_stability();
}
#endif
```

---

## Exercise 3: Prediction Accuracy

**Goal:** Check if Day 10 predictions are accurate

```c
#if HANDMADE_INTERNAL
void check_prediction_accuracy(void) {
  if (g_debug_marker_index < 30) return;
  
  int good_predictions = 0;
  int total = 30;
  
  for (int i = 0; i < total; i++) {
    int idx = (g_debug_marker_index - total + i) % MAX_DEBUG_AUDIO_MARKERS;
    LinuxDebugAudioMarker *m = &g_debug_audio_markers[idx];
    
    int64_t predicted = m->expected_flip_play_cursor;
    int64_t actual = m->flip_play_cursor;
    int64_t error = actual - predicted;
    if (error < 0) error = -error;
    
    // Good if error < 5% of one frame
    if (error < 800 / 20) {  // 800 samples per frame / 20 = 5%
      good_predictions++;
    }
  }
  
  float accuracy = (float)good_predictions / total * 100.0f;
  
  printf("\nğŸ¯ Prediction Accuracy (last 30 frames):\n");
  printf("   Good: %d / %d (%.1f%%)\n", good_predictions, total, accuracy);
  
  if (accuracy > 95.0f) {
    printf("   âœ… EXCELLENT - Day 10 working perfectly\n");
  } else if (accuracy > 80.0f) {
    printf("   âš ï¸  GOOD - Slight timing variations\n");
  } else {
    printf("   âŒ POOR - Consider falling back to Day 9\n");
  }
}

// Call every 5 seconds:
if (g_debug_marker_index % 300 == 0) {
  check_prediction_accuracy();
}
#endif
```

---

## Interpreting Marker Data

### Scenario 1: Stable Performance

```
Frame 100:
  Delay:  1600 frames (33ms)
  Wrote:  800 samples (16ms)
  Prediction error: +12 samples (0.25ms)

Frame 101:
  Delay:  1600 frames (33ms)
  Wrote:  800 samples (16ms)
  Prediction error: -8 samples (0.16ms)
```

**Analysis:** âœ… Perfect! Latency constant, predictions accurate.

### Scenario 2: Latency Drift

```
Frame 100:
  Delay:  1600 frames (33ms)
  
Frame 150:
  Delay:  1800 frames (37ms)  â† Drifting up
  
Frame 200:
  Delay:  2000 frames (41ms)  â† Still growing!
```

**Analysis:** âš ï¸ Day 9 mode? Latency creeping up. Consider Day 10.

### Scenario 3: Underrun

```
Frame 100:
  Delay:  1600 frames (33ms)
  
Frame 101:
  Delay:  800 frames (16ms)   â† Dropped!
  
Frame 102:
  Delay:  100 frames (2ms)    â† About to underrun!
  
Frame 103:
  Delay:  0 frames (0ms)      â† UNDERRUN!
```

**Analysis:** âŒ Game loop too slow. Increase latency or optimize.

---

## Casey's Visual Debug Overlay

Casey renders markers as colored rectangles on screen. Your code has the placeholder:

**From audio.h:256-260:**
```c
void linux_debug_sync_display(GameOffscreenBuffer *buffer,
                              GameSoundOutput *sound_output,
                              LinuxDebugAudioMarker *markers,
                              int marker_count,
                              int current_marker_index);
```

**Future exercise** (Unit 8): Implement OpenGL overlay showing:
- Green bar = play cursor
- Red bar = write cursor
- Yellow bar = where we wrote
- Blue line = expected position

---

## Key Takeaways

1. **Markers track audio state** across frames
2. **30 frames of history** (0.5 seconds at 60fps)
3. **Three snapshots per frame:** before write, after write, after flip
4. **Stable latency** = healthy audio system
5. **Prediction accuracy** validates Day 10 strategy

---

## Self-Check Quiz

1. **Q:** What does `delay_frames` represent?  
   **A:** Frames queued for playback (latency)

2. **Q:** How is play cursor calculated?  
   **A:** `running_sample_index - delay_frames`

3. **Q:** What does `flip_play_cursor` capture?  
   **A:** Play cursor position after screen flip (glXSwapBuffers)

4. **Q:** How many markers are stored?  
   **A:** 30 (0.5 seconds at 60fps)

5. **Q:** What indicates stable latency?  
   **A:** Consistent `delay_frames` value across frames

---

## Next Unit

**Unit 5: Advanced Audio Patterns** â€” Learn platform abstraction, sine wave math, and memory management.

---

**Time to complete:** 60-75 minutes  
**Code modified:** audio.c (added marker logging and analysis)  
**Competence level achieved:** Level 5 (Can use markers for tuning)
