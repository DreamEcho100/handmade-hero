# L7.3: Priority Inversion & Mutexes - Real-Time Pitfalls

**Unit 7: Real-Time Audio Constraints**  
**Estimated Time:** 75-90 minutes  
**Competence Target:** Level 6 (Evaluation - can critique RT designs)

---

## Learning Objectives

By the end of this lesson, you will:

1. **Understand** priority inversion problem
2. **Analyze** the Mars Pathfinder case study
3. **Detect** priority inversion in your code
4. **Apply** priority inheritance protocol
5. **Design** lock-free alternatives to mutexes
6. **Evaluate** when mutexes are acceptable in RT code

---

## The Mystery: RT Thread Slower Than Normal Thread

### The Paradox

**Setup:**
- Thread A (priority 10, RT): Audio processing
- Thread B (priority 0, normal): Logging

**Expected:** A always preempts B

**Reality:**
```
Time:  0ms    5ms   10ms  15ms  20ms  25ms
A:     [RUN] [WAIT]‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[RUN]
B:               [RUN]‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[RUN]
       
Audio glitch after 15ms!? How is B blocking A?
```

**This is priority inversion!**

---

## Concept 1: Classic Priority Inversion

### The Three-Thread Scenario

**Players:**
- Thread H (High priority, RT 99): Audio
- Thread M (Medium priority, RT 50): Video rendering
- Thread L (Low priority, 0): Background save

**Shared resource:** Mutex protecting audio buffer

---

### Timeline of Disaster

```
T=0ms:  L locks mutex, starts writing
T=5ms:  H wakes up, needs mutex ‚Üí BLOCKED by L
T=6ms:  M wakes up, preempts L (higher priority)
T=15ms: M finishes, L resumes
T=20ms: L unlocks mutex
T=21ms: H finally gets mutex

Result: H (highest priority) waited 16ms for L (lowest priority)!
```

**Indirect blocking:** M (medium) indirectly blocked H (high) by delaying L (low).

---

### Web Dev Analogy

**Scenario:**
```javascript
// Low priority: Background data sync (holds database lock)
async function backgroundSync() {
  await db.lock();
  await syncData();  // Takes 10 seconds
  await db.unlock();
}

// High priority: User request (needs database)
async function handleUserRequest() {
  await db.lock();  // ‚Üê Blocked by background task!
  const data = await db.query();
  await db.unlock();
}

// Medium priority: Analytics processing
async function processAnalytics() {
  // Preempts background sync, indirectly delays user request
  await heavyComputation();
}
```

**User sees:** "Why is my request taking 15 seconds when it should take 100ms?"

---

## Concept 2: Mars Pathfinder Case Study

### The Real-World Failure (1997)

**Mission:** Mars Pathfinder rover

**Problem:** System rebooted randomly on Mars!

**Root cause:** Priority inversion in VxWorks RTOS

---

### The Bug

**Threads:**
- `bc_dist` (high priority): Critical bus management
- `ASI/MET` (medium priority): Science data processing
- `bc_sched` (low priority): Holds shared mutex

**What happened:**
```
1. bc_sched locks mutex
2. bc_dist needs mutex ‚Üí blocks
3. ASI/MET preempts bc_sched (medium > low)
4. ASI/MET runs for seconds
5. bc_dist starved ‚Üí watchdog timeout ‚Üí REBOOT
```

**Solution:** Enable priority inheritance in VxWorks.

**Read more:** [Mike Jones' famous write-up](https://www.rapitasystems.com/blog/what-really-happened-software-mars-pathfinder-spacecraft)

---

## Exercise 1: Reproduce Priority Inversion

### Step 1: Create Vulnerable Code

```c
#include <pthread.h>
#include <sched.h>
#include <stdio.h>
#include <unistd.h>

pthread_mutex_t shared_mutex = PTHREAD_MUTEX_INITIALIZER;

void SetThreadPriority(int priority) {
  struct sched_param param = { .sched_priority = priority };
  pthread_setschedparam(pthread_self(), SCHED_FIFO, &param);
}

void* LowPriorityThread(void* arg) {
  SetThreadPriority(1);
  
  printf("[L] Acquiring mutex...\n");
  pthread_mutex_lock(&shared_mutex);
  
  printf("[L] Got mutex, doing work for 2 seconds...\n");
  sleep(2);  // Simulate long operation
  
  pthread_mutex_unlock(&shared_mutex);
  printf("[L] Released mutex\n");
  
  return NULL;
}

void* MediumPriorityThread(void* arg) {
  SetThreadPriority(50);
  
  sleep(1);  // Let L get mutex first
  
  printf("[M] Starting CPU-intensive work...\n");
  for (int i = 0; i < 1000000000; i++) {
    // Busy loop - preempts L
  }
  printf("[M] Done\n");
  
  return NULL;
}

void* HighPriorityThread(void* arg) {
  SetThreadPriority(99);
  
  sleep(1);  // Let L get mutex first
  
  struct timespec start, end;
  clock_gettime(CLOCK_MONOTONIC, &start);
  
  printf("[H] Trying to acquire mutex...\n");
  pthread_mutex_lock(&shared_mutex);
  
  clock_gettime(CLOCK_MONOTONIC, &end);
  
  int64_t wait_ms = (end.tv_sec - start.tv_sec) * 1000 +
                    (end.tv_nsec - start.tv_nsec) / 1000000;
  
  printf("[H] Got mutex after %lld ms\n", wait_ms);
  
  pthread_mutex_unlock(&shared_mutex);
  
  return NULL;
}

int main() {
  pthread_t low, med, high;
  
  pthread_create(&low, NULL, LowPriorityThread, NULL);
  pthread_create(&med, NULL, MediumPriorityThread, NULL);
  pthread_create(&high, NULL, HighPriorityThread, NULL);
  
  pthread_join(high, NULL);
  pthread_join(med, NULL);
  pthread_join(low, NULL);
  
  return 0;
}
```

---

### Step 2: Compile and Run

```bash
gcc -o priority_inversion priority_inversion.c -lpthread

# Need root for SCHED_FIFO
sudo ./priority_inversion
```

**Output:**
```
[L] Acquiring mutex...
[L] Got mutex, doing work for 2 seconds...
[M] Starting CPU-intensive work...
[H] Trying to acquire mutex...
[M] Done
[L] Released mutex
[H] Got mutex after 3200 ms

High priority thread waited 3.2 seconds!
```

**Priority inversion confirmed!**

---

## Concept 3: Priority Inheritance Protocol

### The Solution

**Idea:** When high-priority thread blocks on mutex held by low-priority thread, **temporarily boost low thread's priority**.

**Timeline with priority inheritance:**
```
T=0ms:  L (priority 1) locks mutex
T=5ms:  H (priority 99) blocks on mutex
        ‚Üí L inherited priority 99!
T=6ms:  M (priority 50) tries to preempt
        ‚Üí Can't! L is now priority 99
T=7ms:  L (boosted to 99) finishes, unlocks
        ‚Üí L returns to priority 1
T=8ms:  H gets mutex

Result: H waited only 3ms (not 16ms)
```

---

### Enable in Code

```c
pthread_mutexattr_t attr;
pthread_mutex_t mutex;

pthread_mutexattr_init(&attr);

// Enable priority inheritance
pthread_mutexattr_setprotocol(&attr, PTHREAD_PRIO_INHERIT);

pthread_mutex_init(&mutex, &attr);
```

---

## Exercise 2: Fix with Priority Inheritance

**Modify previous example:**
```c
pthread_mutexattr_t attr;
pthread_mutex_t shared_mutex;

int main() {
  // Initialize mutex with priority inheritance
  pthread_mutexattr_init(&attr);
  pthread_mutexattr_setprotocol(&attr, PTHREAD_PRIO_INHERIT);
  pthread_mutex_init(&shared_mutex, &attr);
  
  pthread_t low, med, high;
  pthread_create(&low, NULL, LowPriorityThread, NULL);
  pthread_create(&med, NULL, MediumPriorityThread, NULL);
  pthread_create(&high, NULL, HighPriorityThread, NULL);
  
  pthread_join(high, NULL);
  pthread_join(med, NULL);
  pthread_join(low, NULL);
  
  pthread_mutexattr_destroy(&attr);
  pthread_mutex_destroy(&shared_mutex);
  
  return 0;
}
```

**Output:**
```
[L] Acquiring mutex...
[L] Got mutex, doing work for 2 seconds...
[M] Starting CPU-intensive work...
[H] Trying to acquire mutex...
[L] Released mutex
[H] Got mutex after 1050 ms
[M] Done

High priority thread waited 1.05 seconds (vs 3.2s before)
```

**Still not perfect, but much better!**

---

## Concept 4: Lock-Free Alternatives

### Why Avoid Mutexes in RT Audio?

**Problems:**
1. Priority inversion (even with inheritance)
2. Unbounded latency (wait time unpredictable)
3. Potential for deadlock
4. Cache line bouncing

**Casey's approach:** **No locks in audio callback!**

---

### Single-Producer, Single-Consumer Queue (Lock-Free)

```c
typedef struct {
  int16_t buffer[4800];
  _Atomic int write_index;
  _Atomic int read_index;
} LockFreeRingBuffer;

// Producer (game thread):
void PushSamples(LockFreeRingBuffer *rb, int16_t *samples, int count) {
  int write_pos = atomic_load(&rb->write_index);
  
  for (int i = 0; i < count; i++) {
    rb->buffer[write_pos] = samples[i];
    write_pos = (write_pos + 1) % 4800;
  }
  
  // Single atomic write (release semantics)
  atomic_store(&rb->write_index, write_pos);
}

// Consumer (audio thread):
void PullSamples(LockFreeRingBuffer *rb, int16_t *output, int count) {
  int read_pos = atomic_load(&rb->read_index);
  
  for (int i = 0; i < count; i++) {
    output[i] = rb->buffer[read_pos];
    read_pos = (read_pos + 1) % 4800;
  }
  
  // Single atomic write
  atomic_store(&rb->read_index, read_pos);
}
```

**Key:** Only one thread writes `write_index`, only one writes `read_index` ‚Üí no locks needed!

---

## Exercise 3: Detect Inversion in Your Code

### Step 1: Audit for Mutexes

```bash
# Search for mutex usage
grep -r "pthread_mutex" project/
grep -r "std::mutex" project/
```

**If found:** Ask "Is this mutex accessed by audio thread?"

---

### Step 2: Check Mutex Protocol

```c
// Add to your init code
pthread_mutexattr_t attr;
pthread_mutexattr_init(&attr);

int protocol;
pthread_mutexattr_getprotocol(&attr, &protocol);

printf("Mutex protocol: ");
switch (protocol) {
  case PTHREAD_PRIO_NONE:
    printf("NONE (vulnerable to inversion!)\n");
    break;
  case PTHREAD_PRIO_INHERIT:
    printf("INHERIT (protected)\n");
    break;
  case PTHREAD_PRIO_PROTECT:
    printf("PROTECT (priority ceiling)\n");
    break;
}
```

---

### Step 3: Instrument Lock Wait Times

```c
pthread_mutex_t my_mutex;

void InstrumentedLock() {
  struct timespec start, end;
  clock_gettime(CLOCK_MONOTONIC, &start);
  
  pthread_mutex_lock(&my_mutex);
  
  clock_gettime(CLOCK_MONOTONIC, &end);
  
  int64_t wait_us = (end.tv_sec - start.tv_sec) * 1000000 +
                    (end.tv_nsec - start.tv_nsec) / 1000;
  
  if (wait_us > 1000) {  // More than 1ms
    printf("‚ö†Ô∏è  Long mutex wait: %lld Œºs\n", wait_us);
  }
}
```

**If you see warnings:** Investigate why!

---

## Concept 5: When Mutexes Are OK

### Acceptable Patterns

**‚úÖ Safe scenarios:**
1. **Mutex never touched by audio thread**
   ```c
   pthread_mutex_lock(&render_mutex);  // OK, only render thread
   ```

2. **Audio thread always gets lock immediately**
   ```c
   // trylock instead of lock
   if (pthread_mutex_trylock(&stats_mutex) == 0) {
     UpdateStats();
     pthread_mutex_unlock(&stats_mutex);
   }
   // If fails, skip this frame (acceptable for stats)
   ```

3. **Critical section is tiny (< 10 Œºs)**
   ```c
   pthread_mutex_lock(&counter_mutex);
   counter++;  // ‚Üê Single instruction
   pthread_mutex_unlock(&counter_mutex);
   ```

**‚ùå Unsafe scenarios:**
1. Mutex held while doing I/O (file, network)
2. Mutex shared with low-priority thread
3. Critical section unbounded (loops, allocations)

---

## Self-Check Quiz

### Question 1
**What is priority inversion?**

A) High-priority thread runs slower than expected  
B) Low-priority thread preempts high-priority  
C) Mutex deadlock  
D) Scheduler bug  

<details>
<summary>Answer</summary>

**A) High-priority thread runs slower than expected**

Priority inversion occurs when a high-priority thread is indirectly blocked by a low-priority thread via a shared resource (mutex).
</details>

---

### Question 2
**What caused Mars Pathfinder to reboot?**

A) Hardware failure  
B) Priority inversion  
C) Memory corruption  
D) Power loss  

<details>
<summary>Answer</summary>

**B) Priority inversion**

High-priority bus management task was starved by medium-priority tasks, causing watchdog timeout and system reset.
</details>

---

### Question 3
**What does `PTHREAD_PRIO_INHERIT` do?**

A) Makes all threads same priority  
B) Boosts mutex holder to waiter's priority  
C) Prevents mutex from being used  
D) Disables priority scheduling  

<details>
<summary>Answer</summary>

**B) Boosts mutex holder to waiter's priority**

When a high-priority thread blocks on a mutex, the thread holding the mutex temporarily inherits the high priority.
</details>

---

### Question 4
**Should audio callback use mutexes?**

A) Yes, always  
B) No, never  
C) Only with priority inheritance  
D) Only trylock, never block  

<details>
<summary>Answer</summary>

**B) No, never (ideally)**

Audio callbacks should be lock-free. If absolutely necessary, use `trylock` and skip operation if fails. Blocking mutexes risk unbounded latency.
</details>

---

### Question 5
**What's a lock-free alternative to mutex for single-producer/single-consumer?**

A) Spin lock  
B) Semaphore  
C) Atomic ring buffer  
D) No alternative exists  

<details>
<summary>Answer</summary>

**C) Atomic ring buffer**

Using atomic `write_index` and `read_index`, single producer/consumer can safely share data without locks.
</details>

---

## Key Takeaways

### Priority Inversion Summary

| Aspect | Without Inheritance | With Inheritance |
|--------|-------------------|------------------|
| **Low holds mutex** | Priority 1 | Priority 1 |
| **High blocks on mutex** | Low stays priority 1 | **Low boosted to 99** |
| **Medium preempts low?** | Yes | No (low is now 99) |
| **High wait time** | Seconds | Milliseconds |

**Always use `PTHREAD_PRIO_INHERIT` if mutexes are unavoidable!**

---

### RT Audio Rules

**‚úÖ DO:**
- Use lock-free data structures
- Use `trylock`, never `lock`
- Keep critical sections < 10 Œºs
- Enable priority inheritance

**‚ùå DON'T:**
- Use blocking mutexes in audio callback
- Share locks with low-priority threads
- Allocate memory in critical section
- Use I/O in critical section

---

### Code Checklist

```c
// ‚úÖ Good: Lock-free
_Atomic int counter;
atomic_fetch_add(&counter, 1);

// ‚ö†Ô∏è  Acceptable: Tiny critical section + inheritance
pthread_mutexattr_setprotocol(&attr, PTHREAD_PRIO_INHERIT);
pthread_mutex_lock(&mutex);
counter++;  // Single instruction
pthread_mutex_unlock(&mutex);

// ‚ùå Bad: Blocking in audio thread
pthread_mutex_lock(&mutex);  // Unbounded wait!
ProcessAudio();
pthread_mutex_unlock(&mutex);
```

---

## Connection to Other Lessons

**Prerequisites:**
- L7.1: Scheduling Classes (RT priority)
- L7.2: CPU Affinity (cache effects)
- L5.5: Memory Management (lock-free patterns)

**Enables:**
- L8.3: Lock-Free Buffers (practical implementation)
- L9.1: Mixer Architecture (multi-source synchronization)

---

## Final Exercise: Audit Your Codebase

**Checklist:**
- [ ] `grep "pthread_mutex" project/` ‚Üí List all mutexes
- [ ] For each mutex: "Is it accessed by audio thread?"
- [ ] If yes: "Can I replace with atomic operations?"
- [ ] If no: "Add `PTHREAD_PRIO_INHERIT` anyway (safety)"
- [ ] Add instrumentation to detect long waits

**Goal:** Zero blocking mutexes in audio path!

---

## Completion: Unit 7 Done! üéâ

**You've learned:**
- ‚úÖ Real-time scheduling (SCHED_FIFO)
- ‚úÖ CPU affinity and cache effects
- ‚úÖ Priority inversion and how to prevent it

**Competence level:** 6/6 (Evaluation)  
You can now **design and critique** real-time audio systems!

---

## Next Unit Preview

**Unit 8: Performance Profiling & Optimization**
- L8.1: perf & Flamegraphs (find bottlenecks)
- L8.2: SIMD for Audio (vectorize processing)
- L8.3: Lock-Free Ring Buffers (implement from scratch)

**Teaser:**
```bash
perf record -F 999 -g ./game
perf script | flamegraph.pl > flame.svg
# See EXACTLY where CPU time goes!
```

---

**Estimated Completion Time:** 75-90 minutes  
**Difficulty:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (Expert)  
**Competence Level Achieved:** 6/6 (Evaluation)

**Progress:** Unit 7 is 100% COMPLETE! üéä

