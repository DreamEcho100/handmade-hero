# Unit 2, Lesson 3: ALSA Initialization

> **Learning Goal:** Understand `snd_pcm_set_params()` and what ALSA initialization does  
> **Time Estimate:** 45-60 minutes  
> **Prerequisite:** L2.2 (PCM Basics)

---

## üéØ The Mystery You're Solving

In `audio.c:269-285`, you see:

```c
bool linux_init_sound(GameSoundOutput *sound_output, 
                      int32_t samples_per_second,
                      int32_t buffer_size_bytes, 
                      int32_t game_update_hz) {
  // Open device
  int err = SndPcmOpen(&handle, "default", 
                       LINUX_SND_PCM_STREAM_PLAYBACK, 0);
  
  // Configure EVERYTHING in one call
  err = SndPcmSetParams(handle,
                        LINUX_SND_PCM_FORMAT_S16_LE,  // Format
                        LINUX_SND_PCM_ACCESS_RW_INTERLEAVED,  // Access
                        2,  // Channels
                        samples_per_second,  // Sample rate
                        1,  // Soft resample
                        latency_microseconds);  // Latency
}
```

**Questions:**
- What does "default" device mean?
- What's the difference between ALSA "hardware" and "software" devices?
- What does `snd_pcm_set_params()` actually configure?
- Why pass latency in MICROseconds, not frames?

---

## üìö Core Concepts

### 1. ALSA Device Names

**Physical devices (hardware):**
```c
"hw:0,0"     // Hardware device: Card 0, Device 0 (direct hardware access)
"hw:1,0"     // Hardware device: Card 1, Device 0 (second sound card)
```

**Logical devices (plugins/virtual):**
```c
"default"    // Smart plugin (auto-selects best device, handles resampling)
"plughw:0,0" // Plugin wrapper around hw:0,0 (format conversion)
"pulse"      // Route through PulseAudio (if running)
"null"       // Dummy device (no actual output, for testing)
```

**What's the difference?**

```
"hw:0,0" (Direct Hardware):
  ‚úÖ Lowest latency (no overhead)
  ‚úÖ Exclusive access (only you can use device)
  ‚ùå Must match EXACT hardware format (48kHz only, etc.)
  ‚ùå No mixing (can't play multiple sounds at once)
  ‚ùå No resampling (crashes if rates don't match)

"default" (Plugin):
  ‚úÖ Format conversion (accepts any rate/format)
  ‚úÖ Mixing (multiple apps can play audio)
  ‚úÖ Automatic resampling (44.1kHz ‚Üí 48kHz)
  ‚ùå Slightly higher latency (+5-10ms)
  ‚ùå Goes through dmix/PulseAudio layer
```

**Your code uses "default":**
```c
SndPcmOpen(&handle, "default", LINUX_SND_PCM_STREAM_PLAYBACK, 0);
//                  ^--- Smart choice! Works on most systems
```

**Web Dev Analogy:**
```javascript
// "hw:0,0" = Direct WebGL (raw GPU, exclusive)
const canvas = document.createElement('canvas');
const gl = canvas.getContext('webgl2', { antialias: false });

// "default" = Canvas 2D context (abstracted, convenient)
const ctx = canvas.getContext('2d');  // Browser handles details
```

---

### 2. Stream Direction (Playback vs Capture)

```c
typedef enum {
  LINUX_SND_PCM_STREAM_PLAYBACK = 0,  // Output (speakers)
  LINUX_SND_PCM_STREAM_CAPTURE = 1    // Input (microphone)
} linux_snd_pcm_stream_t;
```

**Your game uses PLAYBACK:**
```c
SndPcmOpen(&handle, "default", LINUX_SND_PCM_STREAM_PLAYBACK, 0);
//                             ^--- Output audio
```

**If you wanted to record audio:**
```c
SndPcmOpen(&handle, "default", LINUX_SND_PCM_STREAM_CAPTURE, 0);
//                             ^--- Input audio

// Then read samples instead of write:
SndPcmReadi(handle, buffer, frames);
```

---

### 3. Open Modes (Blocking vs Non-Blocking)

```c
SndPcmOpen(&handle, "default", LINUX_SND_PCM_STREAM_PLAYBACK, 0);
//                                                             ^--- Mode flags
```

**Possible modes:**

```c
0                    // Blocking mode (default)
SND_PCM_NONBLOCK     // Non-blocking mode
SND_PCM_ASYNC        // Asynchronous mode (rare)
```

**Blocking mode (what you use):**
```c
// If buffer full, snd_pcm_writei() WAITS until space available
snd_pcm_writei(handle, samples, 1024);
// ^--- Blocks until ALSA has room for samples
```

**Non-blocking mode:**
```c
SndPcmOpen(&handle, "default", LINUX_SND_PCM_STREAM_PLAYBACK, SND_PCM_NONBLOCK);

// If buffer full, returns immediately with error
long written = snd_pcm_writei(handle, samples, 1024);
if (written == -EAGAIN) {
  // Buffer full! Try again later
}
```

**Casey's choice: Blocking mode**
- Simpler logic (no EAGAIN handling)
- Game loop controls timing anyway
- Audio writes are small (returns quickly)

---

### 4. The Magic of `snd_pcm_set_params()`

**Old way (ALSA before ~2010):**
```c
// Painful! 20+ lines to configure
snd_pcm_hw_params_t *params;
snd_pcm_hw_params_malloc(&params);
snd_pcm_hw_params_any(handle, params);
snd_pcm_hw_params_set_access(handle, params, SND_PCM_ACCESS_RW_INTERLEAVED);
snd_pcm_hw_params_set_format(handle, params, SND_PCM_FORMAT_S16_LE);
snd_pcm_hw_params_set_channels(handle, params, 2);
snd_pcm_hw_params_set_rate_near(handle, params, &rate, 0);
snd_pcm_hw_params_set_period_size_near(handle, params, &period, 0);
snd_pcm_hw_params_set_buffer_size_near(handle, params, &buffer, 0);
snd_pcm_hw_params(handle, params);
snd_pcm_hw_params_free(params);
// ... also need sw_params!
```

**New way (simple API - Casey's choice):**
```c
SndPcmSetParams(handle,
                LINUX_SND_PCM_FORMAT_S16_LE,          // Format: 16-bit signed
                LINUX_SND_PCM_ACCESS_RW_INTERLEAVED,  // Access: L-R-L-R
                2,                                     // Channels: Stereo
                samples_per_second,                   // Rate: 48000 Hz
                1,                                     // Resample: Yes
                latency_microseconds);                // Latency: 66ms
//              ^--- All in ONE call!
```

**What each parameter does:**

#### **A. Format (`LINUX_SND_PCM_FORMAT_S16_LE`)**
```c
// Tells ALSA: "I'm sending 16-bit signed samples, little-endian"
typedef enum {
  LINUX_SND_PCM_FORMAT_S16_LE = 2  // Your choice
} linux_snd_pcm_format_t;
```

#### **B. Access (`LINUX_SND_PCM_ACCESS_RW_INTERLEAVED`)**
```c
// Tells ALSA: "Samples are L-R-L-R-L-R (not L-L-L then R-R-R)"
typedef enum {
  LINUX_SND_PCM_ACCESS_RW_INTERLEAVED = 3  // Your choice
} linux_snd_pcm_access_t;
```

#### **C. Channels (2)**
```c
// Tells ALSA: "2 channels (stereo)"
// Could be 1 (mono), 6 (5.1 surround), 8 (7.1 surround)
```

#### **D. Sample Rate (48000)**
```c
// Tells ALSA: "48,000 samples per second"
// ALSA will resample if hardware doesn't support this rate
```

#### **E. Soft Resample (1)**
```c
// 1 = Allow software resampling (if hardware can't do 48kHz)
// 0 = Fail if hardware doesn't support exact rate
```

**Why allow resampling?**
```c
// Your sound card might only support 44.1kHz or 96kHz
// If soft_resample = 1:
//   ALSA converts 48kHz ‚Üí 44.1kHz automatically
// If soft_resample = 0:
//   snd_pcm_set_params() returns error
```

#### **F. Latency (microseconds)**
```c
int32_t latency_sample_count = game_update_hz * FRAMES_OF_AUDIO_LATENCY;
int32_t latency_microseconds = (latency_sample_count * 1000000) / samples_per_second;

// Example: 60 FPS, 2 frames latency, 48kHz
// latency_sample_count = 60 * 2 = 120 samples... WAIT, that's wrong!
// Should be: samples_per_second / game_update_hz * 2
//          = 48000 / 60 * 2 = 1600 samples
// latency_microseconds = 1600 * 1000000 / 48000 = 33,333 ¬µs = 33ms
```

**What ALSA does with latency:**
```c
// ALSA calculates buffer size from latency:
// buffer_size ‚âà (latency_¬µs / 1000000) * sample_rate
// buffer_size ‚âà (33333 / 1000000) * 48000 = 1600 frames

// ALSA then splits buffer into "periods":
// periods = 4 (typical)
// period_size = buffer_size / periods = 1600 / 4 = 400 frames

// You can write up to period_size frames at a time
```

---

### 5. What Happens During Initialization

**Step-by-step execution:**

```c
// 1. Open device (get file descriptor to /dev/snd/pcmC0D0p)
int err = SndPcmOpen(&handle, "default", LINUX_SND_PCM_STREAM_PLAYBACK, 0);
if (err < 0) {
  // Device doesn't exist, or already in use (hw:0,0), or permissions
}

// 2. Configure hardware parameters
err = SndPcmSetParams(handle,
                      LINUX_SND_PCM_FORMAT_S16_LE,
                      LINUX_SND_PCM_ACCESS_RW_INTERLEAVED,
                      2,                    // Stereo
                      48000,                // 48kHz
                      1,                    // Allow resampling
                      33333);               // 33ms latency

// Internally, ALSA:
// - Checks if hardware supports 48kHz stereo S16_LE
// - If not, enables software resampling plugin
// - Allocates kernel ring buffer (size = latency * rate)
// - Configures DMA for hardware
// - Sets up period interrupts (for buffer sync)

// 3. Device is now READY to accept audio writes
SndPcmWritei(handle, samples, frames);
```

**Internal ALSA state machine:**
```
OPEN ‚Üí HW_PARAMS_ANY ‚Üí HW_PARAMS_SET ‚Üí PREPARED ‚Üí RUNNING
  ^                                         ^          ^
  SndPcmOpen()                              |          SndPcmWritei()
                                            |          (auto-starts)
                                    SndPcmSetParams()
```

---

## üß™ Hands-On Exercises

### Exercise 1: Test Different Devices

Create `test_devices.c`:
```c
#include <alsa/asoundlib.h>
#include <stdio.h>

void test_device(const char *name) {
  printf("\nTesting device: %s\n", name);
  
  snd_pcm_t *handle;
  int err = snd_pcm_open(&handle, name, SND_PCM_STREAM_PLAYBACK, 0);
  
  if (err < 0) {
    printf("  ‚ùå Failed: %s\n", snd_strerror(err));
    return;
  }
  
  printf("  ‚úÖ Opened successfully\n");
  
  // Try to configure
  err = snd_pcm_set_params(handle,
                           SND_PCM_FORMAT_S16_LE,
                           SND_PCM_ACCESS_RW_INTERLEAVED,
                           2, 48000, 1, 50000);  // 50ms latency
  
  if (err < 0) {
    printf("  ‚ùå Configuration failed: %s\n", snd_strerror(err));
  } else {
    printf("  ‚úÖ Configured: 48kHz, 16-bit, stereo, 50ms latency\n");
  }
  
  snd_pcm_close(handle);
}

int main() {
  test_device("default");
  test_device("hw:0,0");
  test_device("plughw:0,0");
  test_device("pulse");
  test_device("null");
  test_device("nonexistent");  // Should fail
  
  return 0;
}
```

**Compile and run:**
```bash
gcc -o test_devices test_devices.c -lasound
./test_devices
```

**Questions:**
1. Which devices succeeded?
2. Did "hw:0,0" work? If not, why? (Hint: exclusive access)
3. What's the difference between "default" and "plughw:0,0"?

---

### Exercise 2: Test Format Support

Create `test_formats.c`:
```c
#include <alsa/asoundlib.h>
#include <stdio.h>

void test_format(snd_pcm_format_t format, const char *name) {
  snd_pcm_t *handle;
  snd_pcm_open(&handle, "default", SND_PCM_STREAM_PLAYBACK, 0);
  
  int err = snd_pcm_set_params(handle, format,
                               SND_PCM_ACCESS_RW_INTERLEAVED,
                               2, 48000, 1, 50000);
  
  printf("%-20s: %s\n", name, err < 0 ? "‚ùå Not supported" : "‚úÖ Supported");
  
  snd_pcm_close(handle);
}

int main() {
  printf("Testing audio formats:\n\n");
  
  test_format(SND_PCM_FORMAT_U8, "8-bit unsigned");
  test_format(SND_PCM_FORMAT_S16_LE, "16-bit signed LE");
  test_format(SND_PCM_FORMAT_S16_BE, "16-bit signed BE");
  test_format(SND_PCM_FORMAT_S24_LE, "24-bit signed LE");
  test_format(SND_PCM_FORMAT_S32_LE, "32-bit signed LE");
  test_format(SND_PCM_FORMAT_FLOAT_LE, "32-bit float LE");
  
  return 0;
}
```

**Expected output:**
```
8-bit unsigned      : ‚úÖ Supported (software conversion)
16-bit signed LE    : ‚úÖ Supported (native)
16-bit signed BE    : ‚úÖ Supported (software conversion)
24-bit signed LE    : ‚úÖ Supported (if hardware supports)
32-bit signed LE    : ‚úÖ Supported (software conversion)
32-bit float LE     : ‚úÖ Supported (software conversion)
```

---

### Exercise 3: Measure Initialization Time

Create `init_benchmark.c`:
```c
#include <alsa/asoundlib.h>
#include <stdio.h>
#include <time.h>

double get_time_ms() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return ts.tv_sec * 1000.0 + ts.tv_nsec / 1e6;
}

int main() {
  double start, end;
  
  // Benchmark: Open
  start = get_time_ms();
  snd_pcm_t *handle;
  int err = snd_pcm_open(&handle, "default", SND_PCM_STREAM_PLAYBACK, 0);
  end = get_time_ms();
  
  printf("snd_pcm_open():       %.2f ms\n", end - start);
  
  // Benchmark: Configure
  start = get_time_ms();
  err = snd_pcm_set_params(handle,
                           SND_PCM_FORMAT_S16_LE,
                           SND_PCM_ACCESS_RW_INTERLEAVED,
                           2, 48000, 1, 50000);
  end = get_time_ms();
  
  printf("snd_pcm_set_params(): %.2f ms\n", end - start);
  
  // Total
  printf("Total init time:      %.2f ms\n", end - start);
  
  snd_pcm_close(handle);
  return 0;
}
```

**Typical output:**
```
snd_pcm_open():       5.23 ms
snd_pcm_set_params(): 12.45 ms
Total init time:      17.68 ms
```

**Question:** Why does init take 10-20ms? (Hint: Kernel driver setup, DMA allocation)

---

### Exercise 4: Add Better Error Handling to Your Code

**Modify `audio.c` to handle specific errors:**

```c
bool linux_init_sound(GameSoundOutput *sound_output,
                      int32_t samples_per_second,
                      int32_t buffer_size_bytes,
                      int32_t game_update_hz) {
  
  // Try opening device
  int err = SndPcmOpen(&g_linux_sound_output.handle, "default",
                       LINUX_SND_PCM_STREAM_PLAYBACK, 0);
  
  if (err < 0) {
    printf("‚ùå Failed to open audio device: %s\n", SndStrerror(err));
    
    // Provide helpful error messages
    if (err == -ENOENT) {
      printf("   No audio device found. Check `aplay -l`\n");
    } else if (err == -EBUSY) {
      printf("   Device busy. Close other audio applications.\n");
    } else if (err == -EACCES) {
      printf("   Permission denied. Add user to 'audio' group.\n");
    }
    
    return false;
  }
  
  // Calculate latency
  int32_t latency_sample_count = samples_per_second / game_update_hz * 
                                  FRAMES_OF_AUDIO_LATENCY;
  int32_t latency_microseconds = (latency_sample_count * 1000000) / 
                                  samples_per_second;
  
  printf("üîä Configuring audio:\n");
  printf("   Sample rate: %d Hz\n", samples_per_second);
  printf("   Channels: 2 (stereo)\n");
  printf("   Format: S16_LE (16-bit signed)\n");
  printf("   Latency: %d ¬µs (%.1f ms, %d frames @ %d FPS)\n",
         latency_microseconds,
         latency_microseconds / 1000.0f,
         FRAMES_OF_AUDIO_LATENCY,
         game_update_hz);
  
  // Configure device
  err = SndPcmSetParams(g_linux_sound_output.handle,
                        LINUX_SND_PCM_FORMAT_S16_LE,
                        LINUX_SND_PCM_ACCESS_RW_INTERLEAVED,
                        2,
                        samples_per_second,
                        1,  // Allow resampling
                        latency_microseconds);
  
  if (err < 0) {
    printf("‚ùå Failed to configure audio: %s\n", SndStrerror(err));
    
    if (err == -EINVAL) {
      printf("   Invalid parameters. Try different sample rate/latency.\n");
    }
    
    SndPcmClose(g_linux_sound_output.handle);
    g_linux_sound_output.handle = NULL;
    return false;
  }
  
  printf("‚úÖ Audio initialized successfully!\n");
  return true;
}
```

---

## üéì Comprehension Check

**Before moving to L2.4, answer these:**

1. **Awareness:** What's the difference between "hw:0,0" and "default"?

2. **Comprehension:** Why does `snd_pcm_set_params()` take latency in MICROseconds?

3. **Application:** Modify code to use "hw:0,0" instead of "default". What breaks?

4. **Analysis:** If `snd_pcm_open()` fails with -EBUSY, what's the likely cause?

5. **Synthesis:** Design initialization for a game with 5.1 surround (6 channels).

6. **Evaluation:** Should you allow software resampling? Trade-offs?

---

## üîó Connection to Next Lesson

**L2.4: Ring Buffers**
- Device is now configured and ready
- Next: Where does your audio data GO?
- How does ALSA's ring buffer work?
- What's a "period" vs "buffer"?

---

## üìù Reflection Questions (Write in UNITS-TRACKER.md)

1. **Aha Moment:** When did ALSA device types make sense?

2. **Error Handling:** What errors did you encounter in exercises?

3. **Web Dev Connection:** Is this like WebGL context creation?

4. **Design Choice:** Why use "default" over "hw:0,0"?

---

**When ready, update UNITS-TRACKER.md and move to L2.4!** ‚úÖ
