# Unit 2, Lesson 4: Ring Buffers (ALSA's, not yours)

> **Learning Goal:** Understand ALSA's kernel ring buffer and how it differs from your buffer  
> **Time Estimate:** 45-60 minutes  
> **Prerequisite:** L2.3 (ALSA Initialization)

---

## ğŸ¯ The Mystery You're Solving

You have TWO buffers in your audio system:

```c
// YOUR buffer (linear, in userspace)
PlatformMemoryBlock sample_buffer;  // Your backbuffer

// ALSA's buffer (ring, in kernel space)
// Configured by snd_pcm_set_params() - you don't allocate it!
```

**Questions:**
- What's a "ring buffer"? Why circular?
- Where does ALSA's ring buffer live? (Kernel memory)
- How does your linear buffer relate to ALSA's ring buffer?
- What's a "period" vs "buffer size"?
- Why does buffer wrap-around matter?

---

## ğŸ“š Core Concepts

### 1. What is a Ring Buffer?

**Linear buffer (array):**
```
samples[10]:  [0][1][2][3][4][5][6][7][8][9]
               ^                           ^
              start                       end
              
If you reach end, you're DONE (can't write more)
```

**Ring buffer (circular):**
```
       [0]
   [9]     [1]
[8]           [2]
   [7]     [3]
       [6]
     [5] [4]

Write pointer wraps around:
0 â†’ 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 6 â†’ 7 â†’ 8 â†’ 9 â†’ 0 â†’ 1 â†’ ...
```

**Why circular for audio?**

```c
// Linear buffer (BAD for continuous audio):
write(buffer, samples, 1000);  // Fill buffer
write(buffer, samples, 1000);  // ERROR! Buffer full!
// Now what? Allocate new buffer? Shift data? Expensive!

// Ring buffer (GOOD for continuous audio):
write(ring, samples, 1000);  // Write at position 0-999
write(ring, samples, 1000);  // Write at position 1000-1999
write(ring, samples, 1000);  // Wraps to position 0-999 (overwrites old data)
// Audio keeps flowing forever!
```

**Web Dev Analogy:**
```javascript
// Linear buffer = Array (fixed size)
const buffer = new Array(10);
buffer.push(item);  // What if full? Need to resize!

// Ring buffer = Circular queue
class RingBuffer {
  constructor(size) {
    this.buffer = new Array(size);
    this.writePos = 0;
  }
  
  write(item) {
    this.buffer[this.writePos] = item;
    this.writePos = (this.writePos + 1) % this.buffer.length;  // Wrap!
  }
}
```

---

### 2. ALSA's Ring Buffer (Kernel Space)

**Where it lives:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Your Game (Userspace)       â”‚
â”‚  sample_buffer (linear)      â”‚ â† Your backbuffer
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              â”‚ snd_pcm_writei()
              â–¼
========================================
         KERNEL BOUNDARY
========================================
              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ALSA Kernel Driver          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Ring Buffer           â”‚  â”‚ â† ALSA's ring buffer
â”‚  â”‚  (DMA-mapped memory)   â”‚  â”‚    (you don't allocate!)
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              â–¼
        Sound Card Hardware
```

**How it's created:**
```c
// YOU call:
SndPcmSetParams(handle, format, access, channels, rate, resample, latency);
//                                                                  ^--- This determines buffer size!

// ALSA INTERNALLY does:
// 1. Calculate buffer size from latency
buffer_size = (latency_microseconds / 1000000.0) * sample_rate;
// Example: (50000 Âµs / 1000000) * 48000 = 2400 frames

// 2. Allocate kernel memory for ring buffer
kernel_buffer = kmalloc(buffer_size * channels * bytes_per_sample);

// 3. Setup DMA (Direct Memory Access) to sound card
setup_dma(kernel_buffer, buffer_size);
```

**You NEVER see this buffer directly!** You only write to it via system calls.

---

### 3. Buffer Size vs Period Size

**ALSA divides the buffer into "periods" (chunks):**

```
Total Buffer (e.g., 2400 frames)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Period 1â”‚ Period 2â”‚ Period 3â”‚ Period 4â”‚  â† Typically 4 periods
â”‚ 600 fr  â”‚ 600 fr  â”‚ 600 fr  â”‚ 600 fr  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Why periods?**

1. **Interrupt timing:** Hardware triggers interrupt every period
2. **Write granularity:** You should write ~period_size frames at a time
3. **Latency control:** Smaller periods = lower latency (but more CPU overhead)

**Typical configurations:**

```c
Latency     Buffer Size     Periods    Period Size    Interrupt Rate
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
10 ms       480 frames      4          120 frames     400 Hz (every 2.5ms)
50 ms      2400 frames      4          600 frames      80 Hz (every 12.5ms)
100 ms     4800 frames      4         1200 frames      40 Hz (every 25ms)
```

**Your code doesn't set periods directly** (snd_pcm_set_params does it automatically).

---

### 4. Write Pointer vs Play Pointer

**ALSA tracks TWO positions in the ring buffer:**

```
Ring Buffer (circular):

        Play â†â”€â”           â† Hardware reads here (what's playing NOW)
         â”‚     â”‚
    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”
    â”‚[][][][][][][]â”‚
    â””â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â–²â”€â”€â”€â”˜
         â”‚     â”‚
       Write â”€â”€â”˜           â† You write here (future audio)
       
Space between = LATENCY (unplayed audio waiting in buffer)
```

**Example timeline:**

```c
Frame 0:
  Play cursor:  0
  Write cursor: 2400  (50ms ahead at 48kHz)
  
  You write: samples[0..599] (1 period)
  
Frame 1 (16ms later at 60 FPS):
  Play cursor:  768  (moved forward 16ms worth = 768 samples at 48kHz)
  Write cursor: 3168 (768 + 2400)
  
  You write: samples[600..1199] (next period)
```

**Getting cursor positions:**

```c
// How many frames are queued (not yet played)?
snd_pcm_sframes_t delay;
SndPcmDelay(handle, &delay);
// delay = frames between write cursor and play cursor

// How many frames can you write?
snd_pcm_sframes_t avail = SndPcmAvail(handle);
// avail = free space in buffer
```

---

### 5. Your Buffer vs ALSA's Buffer

**YOUR buffer (sample_buffer):**
```c
// Linear buffer in userspace
PlatformMemoryBlock sample_buffer;
sample_buffer.size = buffer_size_bytes;  // e.g., 9600 bytes = 2400 frames stereo

// You WRITE game-generated audio here:
int16_t *samples = (int16_t*)sample_buffer.base;
for (int i = 0; i < sample_count; i++) {
  *samples++ = sine_wave_sample;  // Left
  *samples++ = sine_wave_sample;  // Right
}
```

**ALSA's buffer (kernel ring buffer):**
```c
// Ring buffer in kernel space (you don't see it)
// Allocated by ALSA when you call snd_pcm_set_params()

// You COPY from your buffer to ALSA's buffer:
SndPcmWritei(handle, sample_buffer.base, frames_to_write);
//           ^       ^                    ^
//           |       Your linear buffer   How many frames
//           ALSA handle
//
// Internally: memcpy(kernel_ring_buffer + write_pos, sample_buffer, size)
```

**Data flow:**

```
Step 1: Game generates audio
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Your sample_buffer      â”‚
â”‚ [s0][s1][s2][s3]...     â”‚ â† Generated by game logic
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 2: Copy to ALSA via syscall
         â”‚
         â”‚ SndPcmWritei() - system call!
         â–¼
========================================
         KERNEL BOUNDARY
========================================
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ALSA's ring buffer      â”‚
â”‚ [s0][s1][s2][s3]...     â”‚ â† Copied by kernel
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ DMA transfer
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Sound Card Hardware     â”‚
â”‚ DAC â†’ Speakers          â”‚ â† Hardware reads ring buffer
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Why TWO buffers?**

1. **Security:** Kernel can validate your data before trusting it
2. **Isolation:** Your buffer can be any size; ALSA's is fixed
3. **Performance:** DMA reads from kernel memory (can't read userspace directly)

---

## ğŸ§ª Hands-On Exercises

### Exercise 1: Implement a Ring Buffer

Create `ring_buffer_demo.c`:
```c
#include <stdio.h>
#include <stdint.h>

typedef struct {
  int16_t *buffer;
  int size;
  int write_pos;
  int read_pos;
} RingBuffer;

void ring_init(RingBuffer *ring, int size) {
  ring->buffer = malloc(size * sizeof(int16_t));
  ring->size = size;
  ring->write_pos = 0;
  ring->read_pos = 0;
}

// Write with wrap-around
void ring_write(RingBuffer *ring, int16_t value) {
  ring->buffer[ring->write_pos] = value;
  ring->write_pos = (ring->write_pos + 1) % ring->size;  // Wrap!
  
  printf("Wrote %d at pos %d\n", value, ring->write_pos - 1);
}

// Read with wrap-around
int16_t ring_read(RingBuffer *ring) {
  int16_t value = ring->buffer[ring->read_pos];
  ring->read_pos = (ring->read_pos + 1) % ring->size;  // Wrap!
  
  printf("Read %d from pos %d\n", value, ring->read_pos - 1);
  return value;
}

int main() {
  RingBuffer ring;
  ring_init(&ring, 5);  // Tiny buffer for demonstration
  
  // Write 10 values (wraps around twice)
  for (int i = 0; i < 10; i++) {
    ring_write(&ring, i * 10);
  }
  
  printf("\nBuffer state:\n");
  for (int i = 0; i < ring.size; i++) {
    printf("  [%d] = %d\n", i, ring.buffer[i]);
  }
  
  // Read 5 values
  printf("\nReading:\n");
  for (int i = 0; i < 5; i++) {
    ring_read(&ring);
  }
  
  return 0;
}
```

**Expected output:**
```
Wrote 0 at pos 0
Wrote 10 at pos 1
Wrote 20 at pos 2
Wrote 30 at pos 3
Wrote 40 at pos 4
Wrote 50 at pos 0   â† Wrapped!
Wrote 60 at pos 1
Wrote 70 at pos 2
Wrote 80 at pos 3
Wrote 90 at pos 4

Buffer state:
  [0] = 50    â† Overwrote 0
  [1] = 60    â† Overwrote 10
  [2] = 70    â† Overwrote 20
  [3] = 80    â† Overwrote 30
  [4] = 90    â† Overwrote 40
```

**Questions:**
1. What happens if write catches up to read? (Buffer overrun)
2. What happens if read catches up to write? (Buffer underrun)
3. How to detect these conditions?

---

### Exercise 2: Query ALSA Buffer Info

Create `query_buffer.c`:
```c
#include <alsa/asoundlib.h>
#include <stdio.h>

int main() {
  snd_pcm_t *handle;
  snd_pcm_open(&handle, "default", SND_PCM_STREAM_PLAYBACK, 0);
  snd_pcm_set_params(handle, SND_PCM_FORMAT_S16_LE,
                     SND_PCM_ACCESS_RW_INTERLEAVED,
                     2, 48000, 1, 50000);  // 50ms latency
  
  // Get buffer size
  snd_pcm_uframes_t buffer_size;
  snd_pcm_get_params(handle, &buffer_size, NULL);
  
  printf("ALSA Ring Buffer Info:\n");
  printf("  Buffer size: %lu frames\n", buffer_size);
  printf("  At 48kHz: %.1f ms\n", buffer_size / 48.0);
  printf("  At 48kHz stereo 16-bit: %lu bytes\n", 
         buffer_size * 2 * sizeof(int16_t));
  
  // Get period size
  snd_pcm_uframes_t period_size;
  snd_pcm_get_params(handle, NULL, &period_size);
  
  printf("\nPeriod Info:\n");
  printf("  Period size: %lu frames\n", period_size);
  printf("  Periods in buffer: %lu\n", buffer_size / period_size);
  printf("  Interrupt rate: %.1f Hz\n", 48000.0 / period_size);
  
  snd_pcm_close(handle);
  return 0;
}
```

**Compile and run:**
```bash
gcc -o query_buffer query_buffer.c -lasound
./query_buffer
```

**Expected output:**
```
ALSA Ring Buffer Info:
  Buffer size: 2400 frames
  At 48kHz: 50.0 ms
  At 48kHz stereo 16-bit: 9600 bytes

Period Info:
  Period size: 600 frames
  Periods in buffer: 4
  Interrupt rate: 80.0 Hz
```

---

### Exercise 3: Simulate Buffer Underrun

Create `underrun_test.c`:
```c
#include <alsa/asoundlib.h>
#include <stdio.h>
#include <unistd.h>

int main() {
  snd_pcm_t *handle;
  snd_pcm_open(&handle, "default", SND_PCM_STREAM_PLAYBACK, 0);
  snd_pcm_set_params(handle, SND_PCM_FORMAT_S16_LE,
                     SND_PCM_ACCESS_RW_INTERLEAVED,
                     2, 48000, 1, 50000);
  
  int16_t samples[960];  // 10ms of audio at 48kHz stereo
  
  // Write initial audio
  printf("Writing initial audio...\n");
  for (int i = 0; i < 5; i++) {
    snd_pcm_writei(handle, samples, 480);
  }
  
  printf("Sleeping 100ms (longer than 50ms buffer)...\n");
  usleep(100000);  // 100ms - buffer will underrun!
  
  printf("Trying to write after underrun...\n");
  long written = snd_pcm_writei(handle, samples, 480);
  
  if (written == -EPIPE) {
    printf("âŒ UNDERRUN DETECTED! (EPIPE error)\n");
    
    // Recover
    snd_pcm_recover(handle, -EPIPE, 1);
    printf("âœ… Recovered from underrun\n");
    
    // Try again
    written = snd_pcm_writei(handle, samples, 480);
    printf("   Wrote %ld frames after recovery\n", written);
  }
  
  snd_pcm_close(handle);
  return 0;
}
```

**Output:**
```
Writing initial audio...
Sleeping 100ms (longer than 50ms buffer)...
Trying to write after underrun...
âŒ UNDERRUN DETECTED! (EPIPE error)
âœ… Recovered from underrun
   Wrote 480 frames after recovery
```

---

### Exercise 4: Visualize Buffer Fill Level

Create `buffer_monitor.c`:
```c
#include <alsa/asoundlib.h>
#include <stdio.h>
#include <math.h>
#include <unistd.h>

void print_bar(int filled, int total) {
  printf("[");
  int bar_width = 50;
  int fill_width = (filled * bar_width) / total;
  
  for (int i = 0; i < bar_width; i++) {
    printf(i < fill_width ? "â–ˆ" : "â–‘");
  }
  printf("] %d/%d frames\n", filled, total);
}

int main() {
  snd_pcm_t *handle;
  snd_pcm_open(&handle, "default", SND_PCM_STREAM_PLAYBACK, 0);
  snd_pcm_set_params(handle, SND_PCM_FORMAT_S16_LE,
                     SND_PCM_ACCESS_RW_INTERLEAVED,
                     2, 48000, 1, 50000);
  
  snd_pcm_uframes_t buffer_size;
  snd_pcm_get_params(handle, &buffer_size, NULL);
  
  int16_t samples[480];  // 10ms chunks
  
  printf("Monitoring ALSA buffer fill level:\n\n");
  
  for (int frame = 0; frame < 10; frame++) {
    // Generate audio
    for (int i = 0; i < 480; i++) {
      float t = (frame * 480 + i) / 48000.0;
      samples[i] = (int16_t)(sin(2 * M_PI * 440 * t) * 10000);
    }
    
    // Write to ALSA
    snd_pcm_writei(handle, samples, 480);
    
    // Check buffer status
    snd_pcm_sframes_t delay;
    snd_pcm_delay(handle, &delay);
    
    printf("Frame %d: ", frame);
    print_bar(delay, buffer_size);
    
    usleep(10000);  // 10ms
  }
  
  snd_pcm_drain(handle);
  snd_pcm_close(handle);
  return 0;
}
```

---

## ğŸ“ Comprehension Check

**Before moving to L2.5, answer these:**

1. **Awareness:** What's the difference between your `sample_buffer` and ALSA's ring buffer?

2. **Comprehension:** Why does a ring buffer wrap around? What problem does it solve?

3. **Application:** Calculate buffer size for 100ms latency at 48kHz stereo 16-bit.

4. **Analysis:** If buffer size is 2400 frames with 4 periods, what's period size?

5. **Synthesis:** Design a ring buffer for video frames (30 FPS, 5 frame latency).

6. **Evaluation:** Smaller periods = lower latency. Why not use 1ms periods?

---

## ğŸ”— Connection to Next Lesson

**L2.5: Sample Formats**
- You know ALSA uses S16_LE format
- Next: What are ALL the possible formats?
- How to convert between formats?
- When would you use something other than S16_LE?

---

## ğŸ“ Reflection Questions (Write in UNITS-TRACKER.md)

1. **Aha Moment:** When did the ring buffer concept click?

2. **Buffer Insight:** Why TWO buffers (yours + ALSA's)?

3. **Web Dev Connection:** Is this like double buffering in graphics?

4. **Performance:** What's the cost of copying to kernel buffer?

---

**When ready, update UNITS-TRACKER.md and move to L2.5!** âœ…
