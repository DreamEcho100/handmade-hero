# Unit 2, Lesson 2: PCM Audio Basics

> **Learning Goal:** Understand PCM audio format and why 48kHz/16-bit/stereo is standard  
> **Time Estimate:** 45-60 minutes  
> **Prerequisite:** L2.1 (Kernel vs Userspace)

---

## ğŸ¯ The Mystery You're Solving

In `audio.c:269`, you see:
```c
int samples_per_second = 48000;  // Why 48000?
int16_t sample;                  // Why int16_t?
int channels = 2;                // Why 2?
```

**Questions:**
- What does "PCM" mean? (Pulse Code Modulation)
- Why 48kHz instead of 44.1kHz or 96kHz?
- Why 16-bit samples instead of 8-bit or 32-bit?
- How does stereo (L/R) work in memory?

---

## ğŸ“š Core Concepts

### 1. What is PCM (Pulse Code Modulation)?

**Analog sound (continuous wave):**
```
Microphone picks up air pressure changes:

    â•±â•²    â•±â•²    â•±â•²    â† Sound wave (continuous)
   â•±  â•²  â•±  â•²  â•±  â•²
  â•±    â•²â•±    â•²â•±    â•²
 â•±
```

**Digital audio (discrete samples):**
```
Sample the wave at fixed time intervals:

    â”‚ â•±â•² â”‚  â•±â•² â”‚  â•±â•²    â† Sample points (discrete)
    â”‚â•±  â•²â”‚ â•±  â•²â”‚ â•±  â•²
    â€¢    â€¢     â€¢     â€¢  â† Captured values
    ^    ^     ^     ^
    0   20Âµs  40Âµs  60Âµs  (at 48kHz)
```

**PCM = Store each sample as a number:**
```c
// At 48kHz, we capture 48,000 samples per second
int16_t samples[48000] = {
    0,      // t = 0.000000s
    1234,   // t = 0.000021s (21 microseconds later)
    5678,   // t = 0.000042s
    -3456,  // t = 0.000063s
    // ... 47,996 more samples
};
```

**Reconstruction (DAC converts back to analog):**
```
DAC reads samples and outputs voltage:

samples[] = {0, 1234, 5678, -3456, ...}
              â†“    â†“     â†“      â†“
            â•±â•²    â•±â•²    â•±â•²     â† Reconstructed wave
           â•±  â•²  â•±  â•²  â•±  â•²       (low-pass filtered)
          â•±    â•²â•±    â•²â•±    â•²
         â•±
```

**Web Dev Analogy:**
```javascript
// Analog = SVG (continuous path)
<path d="M0,0 Q50,100 100,0" />  // Smooth curve

// Digital PCM = Canvas pixels (discrete points)
const pixels = [0, 128, 255, 200, 100, 0];
pixels.forEach((value, x) => {
  ctx.fillRect(x, value, 1, 1);  // One pixel per sample
});
```

---

### 2. Sample Rate: Why 48kHz?

**Nyquist-Shannon Sampling Theorem:**
> To perfectly reconstruct a signal, you must sample at TWICE the highest frequency.

**Human hearing:**
- Range: 20 Hz to 20,000 Hz (20 kHz)
- Highest frequency we hear: ~20 kHz
- Minimum sample rate: 2 Ã— 20 kHz = **40 kHz**

**Common sample rates:**

| Rate | Usage | Math | Why? |
|------|-------|------|------|
| **44.1 kHz** | CD Audio | 2 Ã— 20 kHz + margin | Historical (NTSC video sync) |
| **48 kHz** | Pro Audio/Video | 2 Ã— 20 kHz + margin | Film/TV standard (divisible by 24fps) |
| **96 kHz** | High-Res Audio | 2 Ã— 40 kHz (ultrasonic) | "Better" (debatable if humans can hear) |
| **192 kHz** | Studio Mastering | 2 Ã— 80 kHz | Overkill for playback |

**Why 48kHz became standard:**

```
Film runs at 24 FPS
48,000 Hz Ã· 24 FPS = 2,000 samples per frame (clean division!)

CD audio at 44.1 kHz
44,100 Hz Ã· 24 FPS = 1,837.5 samples per frame (messy!)
```

**Your code:**
```c
int samples_per_second = 48000;
int game_update_hz = 60;  // Game runs at 60 FPS

// Samples per frame = 48000 / 60 = 800 samples (clean!)
int samples_per_frame = samples_per_second / game_update_hz;
```

**Web Dev Analogy:**
```javascript
// Why 60 FPS for animation?
// Because monitors refresh at 60 Hz (or multiples: 120, 144)
requestAnimationFrame(() => {
  // Called 60 times/second
  // Each frame = 16.67ms
});

// Why 48kHz for audio?
// Because film runs at 24 FPS (or multiples: 48, 96)
// Each frame = 20.83ms = 1000 samples at 48kHz
```

---

### 3. Bit Depth: Why 16-bit?

**What is bit depth?**
- Number of bits to represent each sample
- More bits = more precision = quieter noise floor

**Common bit depths:**

```
8-bit:  256 levels    (-128 to +127)
        â”‚ â”€â”‚â”€ â”‚ â”€â”‚â”€ â”‚
        â””â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”˜  â† Rough staircase
        Noise: -48 dB (audible hiss)

16-bit: 65,536 levels (-32,768 to +32,767)
        â”‚â”‚â”‚â”‚â”‚â”‚â”‚â”‚â”‚â”‚â”‚â”‚â”‚
        â”‚â”‚â”‚â”‚â”‚â”‚â”‚â”‚â”‚â”‚â”‚â”‚â”‚  â† Smooth curve
        Noise: -96 dB (CD quality, inaudible in most environments)

24-bit: 16,777,216 levels
        â”‚â”‚â”‚â”‚â”‚â”‚â”‚â”‚â”‚â”‚â”‚â”‚â”‚
        â”‚â”‚â”‚â”‚â”‚â”‚â”‚â”‚â”‚â”‚â”‚â”‚â”‚  â† Indistinguishable from 16-bit in practice
        Noise: -144 dB (studio mastering, overkill for playback)
```

**Dynamic range (signal-to-noise ratio):**
```
Bit Depth    Dynamic Range    Practical Meaning
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
8-bit        48 dB            Audible hiss (old games)
16-bit       96 dB            CD quality (silent room ~30 dB)
24-bit      144 dB            Studio (quieter than human hearing)
32-bit      192 dB            Math precision (not audible quality)
```

**Why 16-bit for games?**

```c
// 16-bit signed integer
int16_t sample;  // Range: -32,768 to +32,767

// 0 = silence
// +32,767 = maximum positive pressure
// -32,768 = maximum negative pressure

// Sine wave example:
for (int i = 0; i < 48000; i++) {
  float t = (float)i / 48000.0f;
  float sine = sin(2.0f * M_PI * 440.0f * t);  // 440 Hz (A note)
  
  int16_t sample = (int16_t)(sine * 32767.0f);  // Scale to 16-bit
  //                                   ^---- Max amplitude
}
```

**Memory cost:**
```
1 second of audio at 48kHz, 16-bit, stereo:
= 48,000 samples/sec Ã— 2 bytes/sample Ã— 2 channels
= 192,000 bytes/sec
= 192 KB/sec
= ~11 MB/minute

Compare to 8-bit mono (old games):
= 48,000 samples/sec Ã— 1 byte/sample Ã— 1 channel
= 48 KB/sec
= ~2.8 MB/minute (4x smaller!)
```

**Web Dev Analogy:**
```javascript
// 8-bit color (256 colors)
const pixel8bit = 0xFF;  // 0-255

// 16-bit color (65K colors)
const pixel16bit = 0xFFFF;  // RGB565 encoding

// 24-bit color (16M colors)
const pixel24bit = 0xFFFFFF;  // Full RGB

// For audio, 16-bit is the "24-bit color" of sound
// Good enough that more bits don't improve perceived quality
```

---

### 4. Channels: Mono vs Stereo

**Mono (1 channel):**
```c
int16_t mono_buffer[1024] = {
  sample0,   // t=0
  sample1,   // t=1/48000
  sample2,   // t=2/48000
  // ...
};

// All speakers play the same sound
```

**Stereo (2 channels):**
```c
int16_t stereo_buffer[2048] = {
  L0, R0,    // t=0:      Left sample, Right sample
  L1, R1,    // t=1/48000
  L2, R2,    // t=2/48000
  // ...
};

// INTERLEAVED format (L-R-L-R-L-R...)
// This is what ALSA expects!
```

**Memory layout:**
```
Stereo Interleaved (what ALSA uses):

Address     Value        Channel
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
0x1000:     0x1234       Left sample 0
0x1002:     0x5678       Right sample 0
0x1004:     0xABCD       Left sample 1
0x1006:     0xEF01       Right sample 1
...
```

**Non-interleaved (what some APIs use):**
```
Address     Value        Channel
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
0x1000:     0x1234       Left sample 0
0x1002:     0xABCD       Left sample 1
0x1004:     0x2345       Left sample 2
...
0x2000:     0x5678       Right sample 0
0x2002:     0xEF01       Right sample 1
0x2004:     0x6789       Right sample 2
...
```

**Your code (stereo interleaved):**
```c
int16_t *samples = (int16_t*)buffer->base;

for (int sample_index = 0; sample_index < sample_count; sample_index++) {
  float sine = sin(phase);
  int16_t sample_value = (int16_t)(sine * volume);
  
  // Write BOTH channels (interleaved)
  *samples++ = sample_value;  // Left
  *samples++ = sample_value;  // Right (same value = centered)
  
  phase += phase_increment;
}
```

**Panning (moving sound left/right):**
```c
int16_t left_volume = (100 - pan_position) * volume / 100;
int16_t right_volume = (100 + pan_position) * volume / 100;

*samples++ = (int16_t)(sine * left_volume);   // Left louder
*samples++ = (int16_t)(sine * right_volume);  // Right quieter
```

---

### 5. ALSA Format Constants

**In `audio.h:38-45`:**
```c
typedef enum {
  LINUX_SND_PCM_FORMAT_S16_LE = 2  // Signed 16-bit Little Endian
} linux_snd_pcm_format_t;
```

**What does `S16_LE` mean?**

```
S   = Signed (can be negative)
16  = 16 bits per sample
LE  = Little Endian (byte order)
```

**Endianness (byte order):**

```c
int16_t value = 0x1234;

Little Endian (x86, ARM):
  Address:  0x1000  0x1001
  Bytes:    0x34    0x12    â† Low byte first
            â””â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”˜
            Little end comes first

Big Endian (network byte order):
  Address:  0x1000  0x1001
  Bytes:    0x12    0x34    â† High byte first
            â””â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”˜
            Big end comes first
```

**Other ALSA formats (not used in your code):**
```c
SND_PCM_FORMAT_U8      // Unsigned 8-bit (0-255)
SND_PCM_FORMAT_S16_BE  // Signed 16-bit Big Endian
SND_PCM_FORMAT_S24_LE  // Signed 24-bit (3 bytes)
SND_PCM_FORMAT_S32_LE  // Signed 32-bit (4 bytes)
SND_PCM_FORMAT_FLOAT   // 32-bit float (-1.0 to +1.0)
```

---

## ğŸ§ª Hands-On Exercises

### Exercise 1: Generate Pure Tones

Create `generate_tones.c`:
```c
#include <stdio.h>
#include <math.h>
#include <stdint.h>

void write_wav_header(FILE *f, int sample_rate, int num_samples) {
  int byte_rate = sample_rate * 2 * 2;  // 16-bit stereo
  int data_size = num_samples * 2 * 2;
  
  fwrite("RIFF", 1, 4, f);
  int chunk_size = 36 + data_size;
  fwrite(&chunk_size, 4, 1, f);
  fwrite("WAVE", 1, 4, f);
  
  fwrite("fmt ", 1, 4, f);
  int fmt_size = 16;
  fwrite(&fmt_size, 4, 1, f);
  short fmt = 1;  // PCM
  fwrite(&fmt, 2, 1, f);
  short channels = 2;
  fwrite(&channels, 2, 1, f);
  fwrite(&sample_rate, 4, 1, f);
  fwrite(&byte_rate, 4, 1, f);
  short block_align = 4;
  fwrite(&block_align, 2, 1, f);
  short bits = 16;
  fwrite(&bits, 2, 1, f);
  
  fwrite("data", 1, 4, f);
  fwrite(&data_size, 4, 1, f);
}

int main() {
  int sample_rate = 48000;
  int duration = 3;  // seconds
  int num_samples = sample_rate * duration;
  
  FILE *f = fopen("tone.wav", "wb");
  write_wav_header(f, sample_rate, num_samples);
  
  // Generate 440 Hz sine wave (A note)
  for (int i = 0; i < num_samples; i++) {
    float t = (float)i / sample_rate;
    float sine = sin(2.0f * M_PI * 440.0f * t);
    
    int16_t sample = (int16_t)(sine * 16000);  // 50% volume
    
    // Write stereo (same to both channels)
    fwrite(&sample, 2, 1, f);  // Left
    fwrite(&sample, 2, 1, f);  // Right
  }
  
  fclose(f);
  printf("Generated tone.wav (440 Hz, 3 seconds, 48kHz, 16-bit stereo)\n");
  return 0;
}
```

**Compile and run:**
```bash
gcc -o generate_tones generate_tones.c -lm
./generate_tones
aplay tone.wav  # Or open in Audacity
```

**Experiments:**
1. Change frequency to 220 Hz, 880 Hz, 1760 Hz (musical octaves)
2. Generate 8-bit audio: `uint8_t sample = (uint8_t)((sine + 1.0f) * 127.5f);`
3. Generate stereo panning: Left = `sine * (1 - pan)`, Right = `sine * pan`

---

### Exercise 2: Visualize Sample Rates

Create `sample_rate_demo.c`:
```c
#include <stdio.h>
#include <math.h>
#include <stdint.h>

void generate_file(const char *filename, int sample_rate) {
  // Same WAV header code as Exercise 1...
  
  // Generate 100 Hz sine wave
  for (int i = 0; i < sample_rate; i++) {  // 1 second
    float t = (float)i / sample_rate;
    float sine = sin(2.0f * M_PI * 100.0f * t);
    int16_t sample = (int16_t)(sine * 16000);
    
    fwrite(&sample, 2, 1, f);  // Left
    fwrite(&sample, 2, 1, f);  // Right
  }
  
  fclose(f);
}

int main() {
  generate_file("rate_8k.wav", 8000);    // Old phone quality
  generate_file("rate_16k.wav", 16000);  // Voice calls
  generate_file("rate_44k.wav", 44100);  // CD quality
  generate_file("rate_48k.wav", 48000);  // Pro audio
  
  printf("Generated 4 files. Compare quality in Audacity!\n");
  return 0;
}
```

**Listen and compare:**
```bash
aplay rate_8k.wav   # Sounds muffled
aplay rate_48k.wav  # Sounds clear
```

**Questions:**
1. Can you hear the difference between 44.1 kHz and 48 kHz?
2. Why does 8 kHz sound "phone-like"?
3. What's the highest frequency you can represent at 8 kHz? (Hint: Nyquist)

---

### Exercise 3: Bit Depth Comparison

Create `bit_depth_demo.c`:
```c
#include <stdio.h>
#include <math.h>
#include <stdint.h>

// Generate 8-bit audio (quantized to 256 levels)
void generate_8bit(FILE *f, int sample_rate) {
  for (int i = 0; i < sample_rate; i++) {
    float t = (float)i / sample_rate;
    float sine = sin(2.0f * M_PI * 440.0f * t);
    
    // Quantize to 8-bit, then expand to 16-bit
    int8_t sample8 = (int8_t)(sine * 127.0f);
    int16_t sample16 = sample8 * 256;  // Scale back up
    
    fwrite(&sample16, 2, 1, f);
    fwrite(&sample16, 2, 1, f);
  }
}

// Generate 4-bit audio (only 16 levels!)
void generate_4bit(FILE *f, int sample_rate) {
  for (int i = 0; i < sample_rate; i++) {
    float t = (float)i / sample_rate;
    float sine = sin(2.0f * M_PI * 440.0f * t);
    
    // Quantize to 4-bit (16 levels)
    int sample4 = (int)(sine * 7.5f);  // -7 to +7
    int16_t sample16 = sample4 * 4096;  // Scale to 16-bit
    
    fwrite(&sample16, 2, 1, f);
    fwrite(&sample16, 2, 1, f);
  }
}
```

**Listen for quantization noise (hiss/crackle).**

---

### Exercise 4: Stereo Panning Demo

Create `panning_demo.c`:
```c
#include <stdio.h>
#include <math.h>
#include <stdint.h>

int main() {
  int sample_rate = 48000;
  int duration = 5;  // seconds
  
  FILE *f = fopen("pan_sweep.wav", "wb");
  // WAV header...
  
  for (int i = 0; i < sample_rate * duration; i++) {
    float t = (float)i / sample_rate;
    float sine = sin(2.0f * M_PI * 440.0f * t);
    
    // Pan sweeps from left (-1) to right (+1) over 5 seconds
    float pan = (t / duration) * 2.0f - 1.0f;
    
    float left_gain = (1.0f - pan) * 0.5f;   // 1.0 â†’ 0.0
    float right_gain = (1.0f + pan) * 0.5f;  // 0.0 â†’ 1.0
    
    int16_t left = (int16_t)(sine * left_gain * 16000);
    int16_t right = (int16_t)(sine * right_gain * 16000);
    
    fwrite(&left, 2, 1, f);
    fwrite(&right, 2, 1, f);
  }
  
  fclose(f);
  printf("Generated pan_sweep.wav (sweeps left â†’ right)\n");
  return 0;
}
```

**Test with headphones!**

---

## ğŸ“ Comprehension Check

**Before moving to L2.3, answer these:**

1. **Awareness:** What does "48kHz 16-bit stereo" mean in plain English?

2. **Comprehension:** Why is 96 kHz "better" than 48 kHz? (Hint: Nyquist theorem)

3. **Application:** Calculate memory needed for 10 minutes of 48kHz 16-bit stereo audio.

4. **Analysis:** Your game generates mono audio but ALSA expects stereo. How to convert?

5. **Synthesis:** Design an audio format for a game with 8 channels (7.1 surround). Memory cost?

6. **Evaluation:** Would 32-bit float audio sound "better" than 16-bit int? Why/why not?

---

## ğŸ”— Connection to Next Lesson

**L2.3: ALSA Initialization**
- You know audio is 48kHz/16-bit/stereo
- Next: How to TELL ALSA those parameters?
- What does `snd_pcm_set_params()` actually do?

---

## ğŸ“ Reflection Questions (Write in UNITS-TRACKER.md)

1. **Aha Moment:** When did PCM sampling make sense?

2. **Experiment Result:** Could you hear difference between sample rates?

3. **Web Dev Connection:** Is this like canvas pixel density?

4. **Design Choice:** Why not use 32-bit float for everything?

---

**When ready, update UNITS-TRACKER.md and move to L2.3!** âœ…
