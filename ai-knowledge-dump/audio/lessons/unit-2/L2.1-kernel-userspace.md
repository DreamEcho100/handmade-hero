# Unit 2, Lesson 1: Kernel vs Userspace Audio

> **Learning Goal:** Understand where ALSA lives and why audio needs kernel drivers  
> **Time Estimate:** 45-60 minutes  
> **Prerequisite:** Unit 1 Complete (Dynamic Library Loading)

---

## ğŸ¯ The Mystery You're Solving

You call `snd_pcm_writei()` with audio samples, but where do they GO?

**Questions:**

- What is "kernel space" vs "user space"?
- Why does audio need a kernel driver?
- What's the difference between ALSA (library) and ALSA (kernel driver)?
- How does audio data travel from your game to the speakers?

---

## ğŸ“š Core Concepts

### 1. The Linux Audio Stack (From Game to Speakers)

```
Your Game (Userspace)
  â”‚
  â”œâ”€ libasound.so.2 (ALSA library)
  â”‚    â””â”€ snd_pcm_writei() â† You call this
  â”‚
  â”œâ”€ System Call (crosses userspace â†’ kernel boundary)
  â”‚    â””â”€ ioctl() or write()
  â”‚
  â”œâ”€ ALSA Kernel Driver (Kernel Space)
  â”‚    â”œâ”€ Ring buffer management
  â”‚    â”œâ”€ DMA setup (Direct Memory Access)
  â”‚    â””â”€ Hardware abstraction
  â”‚
  â”œâ”€ Sound Card Hardware
  â”‚    â”œâ”€ DAC (Digital-to-Analog Converter)
  â”‚    â””â”€ Amplifier
  â”‚
  â””â”€ ğŸ”Š Speakers (Physical Sound)
```

**Web Dev Analogy:**

```
Your React App (Browser)
  â”‚
  â”œâ”€ fetch() API (Browser API)
  â”‚
  â”œâ”€ Browser Network Stack (Browser internals)
  â”‚
  â”œâ”€ OS Network Stack (Kernel TCP/IP)
  â”‚
  â”œâ”€ Network Driver (Kernel)
  â”‚
  â”œâ”€ Network Card Hardware
  â”‚
  â””â”€ ğŸŒ Internet
```

---

### 2. Userspace vs Kernel Space

**Memory Protection in Linux:**

```
Virtual Memory Layout (64-bit Linux)

0xFFFFFFFF FFFFFFFF  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                     â”‚   Kernel Space      â”‚ â† Ring 0 (privileged)
                     â”‚   - Device drivers  â”‚   Can access hardware
                     â”‚   - System calls    â”‚   Can modify any memory
                     â”‚   - Interrupts      â”‚
0xFFFF8000 00000000  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                     â”‚   (unmapped gap)    â”‚
0x00007FFF FFFFFFFF  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                     â”‚   User Stack        â”‚
                     â”‚   User Heap         â”‚ â† Ring 3 (unprivileged)
                     â”‚   Shared Libraries  â”‚   CANNOT access hardware
                     â”‚   (.so files)       â”‚   CANNOT touch kernel memory
                     â”‚   Program Code      â”‚
0x0000000000400000   â”‚   (.text section)   â”‚
0x0000000000000000   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Why this separation?**

1. **Security:** Your game can't crash the kernel (and whole system)
2. **Stability:** Bug in your code only kills your process
3. **Isolation:** Multiple programs can't interfere with each other
4. **Hardware Protection:** Only kernel can touch hardware registers

**What happens when you cross the boundary?**

```c
// Your game (userspace)
int16_t samples[1024] = { /* audio data */ };

// ALSA library (still userspace)
snd_pcm_writei(handle, samples, 1024);
  â”‚
  â””â”€> Calls system call (syscall instruction)
        â”‚
        â”œâ”€ CPU switches from Ring 3 â†’ Ring 0
        â”œâ”€ Kernel validates request
        â”œâ”€ Kernel copies samples to kernel buffer
        â”œâ”€ Kernel programs DMA controller
        â””â”€ CPU switches back Ring 0 â†’ Ring 3
```

**Cost of crossing:**

- **Time:** ~500-2000 CPU cycles (~200ns on modern CPU)
- **Context Switch:** Save registers, switch page tables, restore registers
- **Validation:** Kernel checks pointers are valid (security)

**Web Dev Analogy:**

```javascript
// JavaScript (userspace equivalent)
const buffer = new Uint8Array(1024);

// Browser API (crosses JS â†’ Browser C++ code)
audioContext.decodeAudioData(buffer).then((audioBuffer) => {
  // Browser validated buffer, did heavy lifting in C++
  // Returns result back to JavaScript land
});
```

---

### 3. ALSA Library vs ALSA Kernel Driver

**Two separate components (confusingly both called "ALSA"):**

#### **A. ALSA Library (`libasound.so.2`)**

- **Lives:** Userspace (loaded by dlopen)
- **Language:** C
- **Job:** Provide nice API, wrap ugly system calls
- **Example Code:**
  ```c
  int snd_pcm_writei(snd_pcm_t *pcm, const void *buffer, unsigned long frames) {
    // Validate inputs
    if (!pcm || !buffer) return -EINVAL;

    // Issue system call to kernel
    return ioctl(pcm->fd, SNDRV_PCM_IOCTL_WRITEI_FRAMES, &xfer);
    //     ^--- System call! Crosses to kernel space
  }
  ```

#### **B. ALSA Kernel Driver (in Linux kernel)**

- **Lives:** Kernel space (part of Linux kernel)
- **Language:** C (compiled into kernel or kernel module)
- **Job:** Talk to hardware, manage buffers, handle interrupts
- **Example Code (simplified):**
  ```c
  // This runs in KERNEL SPACE!
  static long snd_pcm_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {
    switch (cmd) {
      case SNDRV_PCM_IOCTL_WRITEI_FRAMES:
        // Copy data from userspace to kernel buffer
        copy_from_user(kernel_buffer, user_buffer, size);

        // Program DMA to transfer to sound card
        setup_dma_transfer(kernel_buffer, size);

        return 0;
    }
  }
  ```

**Visualization:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Your Game Process (Userspace)       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  main() {                   â”‚     â”‚
â”‚  â”‚    SndPcmWritei(samples);   â”‚ â”€â”€â”€â”€â”¼â”€â”
â”‚  â”‚  }                          â”‚     â”‚ â”‚ System Call
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚ â”‚ (ioctl)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
                                         â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  libasound.so.2 (Userspace Library)  â”‚ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚ â”‚
â”‚  â”‚  snd_pcm_writei() {         â”‚ <â”€â”€â”€â”¼â”€â”˜
â”‚  â”‚    ioctl(fd, WRITE, ...);   â”‚ â”€â”€â”€â”€â”¼â”€â”
â”‚  â”‚  }                          â”‚     â”‚ â”‚ System Call
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚ â”‚ (crosses boundary)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
                                         â–¼
========================================
         KERNEL BOUNDARY
========================================
                                         â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  Linux Kernel (Kernel Space)         â”‚ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚ â”‚
â”‚  â”‚  ALSA Driver                â”‚ <â”€â”€â”€â”¼â”€â”˜
â”‚  â”‚  - copy_from_user()         â”‚     â”‚
â”‚  â”‚  - setup_dma()              â”‚ â”€â”€â”€â”€â”¼â”€â”
â”‚  â”‚  - trigger interrupt        â”‚     â”‚ â”‚ Hardware I/O
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
                                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Sound Card Hardware                 â”‚
â”‚  - DAC converts digital â†’ analog     â”‚
â”‚  - Amplifier â†’ Speakers              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 4. System Calls: The Gate Between Worlds

**What is a system call?**

```c
// Normal function call (stays in userspace)
int add(int a, int b) {
  return a + b;  // Fast! ~1 CPU cycle
}

// System call (crosses to kernel)
int write(int fd, const void *buf, size_t count) {
  // CPU executes special "syscall" instruction
  // Hardware switches to kernel mode
  // Kernel validates request, does work
  // Hardware switches back to user mode
  // Expensive! ~500-2000 CPU cycles
}
```

**Common system calls in ALSA:**

```c
// Open audio device (system call)
int fd = open("/dev/snd/pcmC0D0p", O_RDWR);

// Configure device (system call)
ioctl(fd, SNDRV_PCM_IOCTL_HW_PARAMS, &params);

// Write audio data (system call)
ioctl(fd, SNDRV_PCM_IOCTL_WRITEI_FRAMES, &xfer);

// Check buffer status (system call)
ioctl(fd, SNDRV_PCM_IOCTL_DELAY, &delay);
```

**Why not stay in kernel all the time?**

- Security: Bug in your code would crash entire system
- Complexity: Kernel code is HARD to debug (no printf, no gdb)
- Portability: Userspace code works on any Linux (kernel drivers are version-specific)

---

### 5. The Device File System (`/dev/snd/`)

**ALSA exposes audio hardware as files:**

```bash
$ ls -l /dev/snd/
crw-rw----+ 1 root audio 116,  0 Jan 14 10:30 controlC0
crw-rw----+ 1 root audio 116, 16 Jan 14 10:30 pcmC0D0c
crw-rw----+ 1 root audio 116, 17 Jan 14 10:30 pcmC0D0p
crw-rw----+ 1 root audio 116,  1 Jan 14 10:30 seq
crw-rw----+ 1 root audio 116, 33 Jan 14 10:30 timer
```

**Decoding device names:**

```
pcmC0D0p
â”‚â”‚â”‚â”‚â”‚â”‚â”‚â””â”€ p = Playback (output)
â”‚â”‚â”‚â”‚â”‚â”‚â”‚   c = Capture (input/recording)
â”‚â”‚â”‚â”‚â”‚â”‚â””â”€â”€ Device 0 (first audio device)
â”‚â”‚â”‚â”‚â”‚â””â”€â”€â”€ D = Device
â”‚â”‚â”‚â”‚â””â”€â”€â”€â”€ Card 0 (first sound card)
â”‚â”‚â”‚â””â”€â”€â”€â”€â”€ C = Card
â”‚â”‚â””â”€â”€â”€â”€â”€â”€ pcm = PCM audio device
â”‚â””â”€â”€â”€â”€â”€â”€â”€ /dev/snd/ directory
```

**Your code opens these like files:**

```c
// ALSA library does this internally:
int fd = open("/dev/snd/pcmC0D0p", O_RDWR | O_NONBLOCK);
if (fd < 0) {
  return -1;  // No audio device!
}

// Now you can ioctl() to talk to kernel driver
ioctl(fd, SNDRV_PCM_IOCTL_HW_PARAMS, &params);
```

**Web Dev Analogy:**

```javascript
// Opening device = opening WebSocket
const socket = new WebSocket("ws://localhost/audio");

// Configuring = sending control messages
socket.send(JSON.stringify({ type: "configure", rate: 48000 }));

// Writing samples = sending data
socket.send(audioBuffer);
```

---

## ğŸ§ª Hands-On Exercises

### Exercise 1: Explore Audio Devices

**A. List your audio devices:**

```bash
ls -la /dev/snd/
```

**Questions:**

1. How many sound cards do you have? (Count `controlCX`)
2. Which device would you use for playback? (Hint: ends with `p`)
3. What are the permissions? (Who can access audio?)

**B. Find which programs are using audio:**

```bash
lsof /dev/snd/*
```

**C. Check loaded ALSA kernel modules:**

```bash
lsmod | grep snd
```

**Expected output:**

```
snd_hda_intel         49152  5
snd_hda_codec        131072  1 snd_hda_intel
snd_pcm              106496  2 snd_hda_intel,snd_hda_codec
snd                   86016  10 snd_hda_intel,snd_hda_codec,snd_pcm
```

**Question:** What's your sound card driver? (`snd_hda_intel` = Intel HD Audio)

---

### Exercise 2: Trace System Calls

**A. See what system calls `snd_pcm_open()` makes:**

Create `trace_alsa.c`:

```c
#include <alsa/asoundlib.h>
#include <stdio.h>

int main() {
  snd_pcm_t *handle;
  int err = snd_pcm_open(&handle, "default", SND_PCM_STREAM_PLAYBACK, 0);

  if (err < 0) {
    printf("Error: %s\n", snd_strerror(err));
    return 1;
  }

  printf("Device opened successfully\n");
  snd_pcm_close(handle);
  return 0;
}
```

**Compile:**

```bash
gcc -o trace_alsa trace_alsa.c -lasound
```

**Trace system calls:**

```bash
strace -e open,openat,ioctl ./trace_alsa 2>&1 | grep snd
```

**Expected output:**

```
openat(AT_FDCWD, "/dev/snd/controlC0", O_RDWR|O_CLOEXEC) = 3
openat(AT_FDCWD, "/dev/snd/pcmC0D0p", O_RDWR|O_NONBLOCK|O_CLOEXEC) = 3
ioctl(3, SNDRV_PCM_IOCTL_INFO, ...) = 0
ioctl(3, SNDRV_PCM_IOCTL_TTSTAMP, ...) = 0
ioctl(3, SNDRV_PCM_IOCTL_HW_REFINE, ...) = 0
```

**Analysis:**

1. How many system calls for one `snd_pcm_open()`? (Hint: Count `ioctl`)
2. Which device file was opened?
3. Why both `controlC0` AND `pcmC0D0p`?

---

### Exercise 3: Measure System Call Overhead

Create `syscall_cost.c`:

```c
#include <stdio.h>
#include <time.h>
#include <unistd.h>

double get_time_ns() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return ts.tv_sec * 1e9 + ts.tv_nsec;
}

int main() {
  // Benchmark: Normal function call
  double start = get_time_ns();
  for (int i = 0; i < 1000000; i++) {
    int x = 42;  // Just variable assignment
    (void)x;
  }
  double end = get_time_ns();
  printf("1M variable assignments: %.2f ms (%.2f ns/call)\n",
         (end - start) / 1e6, (end - start) / 1e6);

  // Benchmark: System call (getpid is cheapest)
  start = get_time_ns();
  for (int i = 0; i < 100000; i++) {
    getpid();  // System call!
  }
  end = get_time_ns();
  printf("100k getpid() syscalls: %.2f ms (%.2f ns/call)\n",
         (end - start) / 1e6, (end - start) / 1e5);

  printf("\nSyscall overhead: ~%.0fx slower\n",
         ((end - start) / 1e5) / ((end - start) / 1e6));

  return 0;
}
```

**Compile and run:**

```bash
gcc -o syscall_cost syscall_cost.c
./syscall_cost
```

**Expected output:**

```
1M variable assignments: 0.50 ms (0.50 ns/call)
100k getpid() syscalls: 15.00 ms (150.00 ns/call)

Syscall overhead: ~10x slower
```

**Question:** Why does Casey batch audio writes instead of calling `snd_pcm_writei()` every sample?

<details>
<summary>Answer</summary>
System calls are expensive (~150-500ns). Writing 1024 samples at once = 1 syscall. Writing one-by-one = 1024 syscalls = 1000x slower!
</details>

---

### Exercise 4: Check Kernel Ring Buffer

**A. See ALSA kernel messages:**

```bash
dmesg | grep -i snd
```

**Expected output:**

```
[    2.345678] snd_hda_intel 0000:00:1f.3: enabling device (0000 -> 0002)
[    2.456789] snd_hda_codec_realtek hdaudioC0D0: autoconfig for ALC295
[    2.567890] input: HDA Intel PCH Headphone as /devices/...
```

**B. Force an audio error:**

```c
// Try to open non-existent device
snd_pcm_t *handle;
int err = snd_pcm_open(&handle, "hw:99,99", SND_PCM_STREAM_PLAYBACK, 0);
printf("Error: %s\n", snd_strerror(err));
```

**Check dmesg again:**

```bash
dmesg | tail -5
```

**Did kernel log the error?**

---

## ğŸ“ Comprehension Check

**Before moving to L2.2, answer these:**

1. **Awareness:** What directory contains ALSA device files?

2. **Comprehension:** Why can't your game directly write to sound card registers?

3. **Application:** Use `strace` to count how many syscalls `snd_pcm_writei()` makes.

4. **Analysis:** If syscalls take 200ns, and you write audio 60 times/second, how much time is spent in syscalls?

5. **Synthesis:** Design a userspace-only audio system (no kernel). What problems would you face?

6. **Evaluation:** Could audio work without kernel drivers? (Hint: USB audio class)

---

## ğŸ”— Connection to Next Lesson

**L2.2: PCM Audio Basics**

- You know audio data crosses to kernel via system calls
- Next: What FORMAT is that data? (PCM)
- What do "48kHz", "16-bit", "stereo" actually mean?
- Why those specific numbers?

---

## ğŸ“ Reflection Questions (Write in UNITS-TRACKER.md)

1. **Aha Moment:** When did the userspace/kernel split make sense?

2. **System Call Insight:** How much overhead did you measure?

3. **Web Dev Connection:** Is this like client/server architecture?

4. **Design Question:** Why not run everything in kernel space for speed?

---

**When ready, update UNITS-TRACKER.md and move to L2.2!** âœ…
