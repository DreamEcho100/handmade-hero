# Unit 2, Lesson 6: Latency Calculation

> **Learning Goal:** Understand how latency is calculated and why it's tied to FPS  
> **Time Estimate:** 45-60 minutes  
> **Prerequisite:** L2.5 (Sample Formats)

---

## ğŸ¯ The Mystery You're Solving

In `audio.c:269-285` and `base.h:74-94`, you see this calculation:

```c
// base.h
#define FRAMES_OF_AUDIO_LATENCY 2  // Why 2? Why not 1 or 5?

// audio.c
int32_t latency_sample_count = game_update_hz * FRAMES_OF_AUDIO_LATENCY;
//                              ^--- Wait, shouldn't this be divided?

int32_t latency_microseconds = (latency_sample_count * 1000000) / 
                                samples_per_second;
```

**Questions:**
- Why is latency measured in "frames" (game frames, not audio frames)?
- What does "2 frames of latency" mean at different FPS?
- Why multiply `game_update_hz * 2` instead of divide?
- How do you convert samples â†’ microseconds?

---

## ğŸ“š Core Concepts

### 1. The Latency Formula (CORRECTED)

**What you THINK the code says:**
```c
latency_sample_count = game_update_hz * FRAMES_OF_AUDIO_LATENCY;
// If game_update_hz = 60, FRAMES_OF_AUDIO_LATENCY = 2
// latency_sample_count = 60 * 2 = 120 samples
// At 48kHz: 120 / 48000 = 0.0025 seconds = 2.5ms â† Too small!
```

**What the code ACTUALLY does (looking at your audio.c:269-285):**
```c
// The REAL formula in your code:
int32_t latency_sample_count = 
    (samples_per_second / game_update_hz) * FRAMES_OF_AUDIO_LATENCY;
//   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//   Samples PER game frame (not game_update_hz!)

// If samples_per_second = 48000, game_update_hz = 60
// Samples per frame = 48000 / 60 = 800 samples per game frame
// latency_sample_count = 800 * 2 = 1600 samples
// At 48kHz: 1600 / 48000 = 0.0333 seconds = 33ms âœ…
```

**The corrected understanding:**

```
FRAMES_OF_AUDIO_LATENCY = Number of GAME FRAMES worth of audio to buffer

Example at 60 FPS:
  Each game frame = 16.67ms
  2 frames latency = 33.33ms
  
Example at 30 FPS:
  Each game frame = 33.33ms
  2 frames latency = 66.67ms
```

---

### 2. Why Latency is Tied to FPS

**Casey's Day 19 innovation: Frame-aligned audio**

```
Traditional approach (fixed latency):
  Game at 30 FPS:  66ms latency
  Game at 60 FPS:  66ms latency â† Same buffer size
  Game at 120 FPS: 66ms latency â† Still same
  
Casey's approach (frame-aligned):
  Game at 30 FPS:  66ms latency (2 frames * 33ms)
  Game at 60 FPS:  33ms latency (2 frames * 16.67ms)
  Game at 120 FPS: 16ms latency (2 frames * 8.33ms)
```

**Why tie latency to FPS?**

1. **Synchronization:** Audio writes happen once per frame
2. **Predictability:** Always 2 frames ahead (never underruns)
3. **Adaptive:** Faster game = lower latency automatically
4. **Simple:** No complex buffer management

**The game loop pattern:**

```c
while (running) {
  // 1. Generate ONE frame worth of audio
  int samples_this_frame = samples_per_second / game_update_hz;
  generate_audio(samples_this_frame);
  
  // 2. Write to ALSA
  snd_pcm_writei(handle, samples, samples_this_frame);
  
  // 3. Update game logic
  update_game(dt);
  
  // 4. Render frame
  render_frame();
  
  // Loop repeats at FPS rate (e.g., 60 times/second)
}
```

---

### 3. Converting Between Time Units

**The conversion chain:**

```
Game Frames â†’ Audio Samples â†’ Bytes â†’ Time
    â†“              â†“           â†“       â†“
    2           1600        6400    33.33ms
```

**Step-by-step:**

```c
// Given:
int game_update_hz = 60;              // FPS
int samples_per_second = 48000;       // Hz
int FRAMES_OF_AUDIO_LATENCY = 2;     // Game frames
int channels = 2;                     // Stereo
int bytes_per_sample = sizeof(int16_t); // 2 bytes

// Step 1: Game frames â†’ Audio samples
int samples_per_game_frame = samples_per_second / game_update_hz;
// = 48000 / 60 = 800 samples per game frame

int latency_sample_count = samples_per_game_frame * FRAMES_OF_AUDIO_LATENCY;
// = 800 * 2 = 1600 samples

// Step 2: Samples â†’ Bytes
int latency_bytes = latency_sample_count * channels * bytes_per_sample;
// = 1600 * 2 * 2 = 6400 bytes

// Step 3: Samples â†’ Seconds
float latency_seconds = (float)latency_sample_count / samples_per_second;
// = 1600 / 48000 = 0.0333 seconds = 33.33 milliseconds

// Step 4: Seconds â†’ Microseconds (for ALSA)
int latency_microseconds = latency_sample_count * 1000000 / samples_per_second;
// = 1600 * 1000000 / 48000 = 33,333 microseconds
```

**Quick reference table:**

| FPS | ms/frame | 2 frames | 3 frames | 4 frames |
|-----|----------|----------|----------|----------|
| 30  | 33.33ms  | 66.67ms  | 100ms    | 133ms    |
| 60  | 16.67ms  | 33.33ms  | 50ms     | 66.67ms  |
| 120 | 8.33ms   | 16.67ms  | 25ms     | 33.33ms  |
| 144 | 6.94ms   | 13.89ms  | 20.83ms  | 27.78ms  |

---

### 4. The Trade-off: Latency vs Safety

**Why 2 frames instead of 1?**

```
1 frame latency (risky):
â”Œâ”€â”€â”€â”€â”
â”‚ F1 â”‚ â† Only 16.67ms of audio buffered
â””â”€â”€â”€â”€â”˜
   â†“
If game stutters for >16ms: UNDERRUN! (audio glitch)

2 frames latency (safe):
â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
â”‚ F1 â”‚ F2 â”‚ â† 33.33ms of audio buffered
â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜
   â†“
Game can stutter for 33ms before underrun
```

**Why not 10 frames?**

```
10 frames latency (laggy):
â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
â”‚ F1 â”‚ F2 â”‚ F3 â”‚ F4 â”‚ F5 â”‚ F6 â”‚ F7 â”‚ F8 â”‚ F9 â”‚F10 â”‚ â† 166ms!
â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜
   â†“
You press button â†’ 166ms later you hear sound
Player notices lag! (>100ms feels delayed)
```

**Casey's sweet spot: 2-3 frames**
- Enough buffer to prevent underruns
- Low enough latency to feel responsive
- Adjusts automatically with FPS

---

### 5. Real-World Latency Budget

**Total audio latency = MULTIPLE stages:**

```
Your game generates audio:        0ms (instant)
  â†“
Copy to ALSA buffer (syscall):    0.2ms (system call overhead)
  â†“
ALSA kernel buffer (our latency): 33ms (2 frames at 60 FPS)
  â†“
DAC conversion:                   1-2ms (hardware delay)
  â†“
Speaker travel time:              ~3ms (if 1 meter away, speed of sound)
  â†“
TOTAL LATENCY:                    ~37-38ms
```

**Perception thresholds:**
```
< 10ms:  Imperceptible (feels instant)
10-20ms: Noticeable by pros (musicians)
20-50ms: Noticeable by gamers
50-100ms: Annoying for everyone
> 100ms: Unplayable (rhythm games)
```

**Your game at 60 FPS with 2 frames:**
```
33ms buffer + 5ms other = 38ms total âœ…
Still under 50ms threshold!
```

---

## ğŸ§ª Hands-On Exercises

### Exercise 1: Latency Calculator

Create `latency_calc.c`:
```c
#include <stdio.h>

void calculate_latency(int fps, int frames_buffered, int sample_rate) {
  printf("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
  printf("Game FPS: %d | Buffered Frames: %d\n", fps, frames_buffered);
  printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
  
  // Calculate
  float ms_per_frame = 1000.0f / fps;
  float latency_ms = ms_per_frame * frames_buffered;
  int samples_per_frame = sample_rate / fps;
  int total_samples = samples_per_frame * frames_buffered;
  int latency_us = (total_samples * 1000000) / sample_rate;
  
  printf("Milliseconds per frame: %.2f ms\n", ms_per_frame);
  printf("Samples per frame:      %d\n", samples_per_frame);
  printf("Total samples buffered: %d\n", total_samples);
  printf("Latency:                %.2f ms (%d Âµs)\n", 
         latency_ms, latency_us);
  
  // Perception
  if (latency_ms < 10) {
    printf("Perception:             âœ… Imperceptible\n");
  } else if (latency_ms < 20) {
    printf("Perception:             âœ… Excellent (pro level)\n");
  } else if (latency_ms < 50) {
    printf("Perception:             âœ… Good (acceptable)\n");
  } else if (latency_ms < 100) {
    printf("Perception:             âš ï¸  Noticeable\n");
  } else {
    printf("Perception:             âŒ Too high!\n");
  }
}

int main() {
  int sample_rate = 48000;
  
  // Test different configurations
  calculate_latency(30, 2, sample_rate);
  calculate_latency(60, 2, sample_rate);
  calculate_latency(120, 2, sample_rate);
  calculate_latency(60, 1, sample_rate);
  calculate_latency(60, 4, sample_rate);
  
  return 0;
}
```

**Compile and run:**
```bash
gcc -o latency_calc latency_calc.c -lm
./latency_calc
```

---

### Exercise 2: Test Actual Latency

Create `measure_latency.c`:
```c
#include <alsa/asoundlib.h>
#include <stdio.h>
#include <math.h>
#include <time.h>

double get_time_ms() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return ts.tv_sec * 1000.0 + ts.tv_nsec / 1e6;
}

int main() {
  snd_pcm_t *handle;
  snd_pcm_open(&handle, "default", SND_PCM_STREAM_PLAYBACK, 0);
  
  // Test different latencies
  int latencies_ms[] = {10, 25, 50, 100};
  
  for (int i = 0; i < 4; i++) {
    int latency_us = latencies_ms[i] * 1000;
    
    snd_pcm_set_params(handle, SND_PCM_FORMAT_S16_LE,
                       SND_PCM_ACCESS_RW_INTERLEAVED,
                       2, 48000, 1, latency_us);
    
    // Query actual buffer size
    snd_pcm_uframes_t buffer_size;
    snd_pcm_get_params(handle, &buffer_size, NULL);
    
    float actual_latency_ms = (buffer_size / 48.0);
    
    printf("Requested: %3d ms â†’ Got: %6lu frames (%.1f ms)\n",
           latencies_ms[i], buffer_size, actual_latency_ms);
  }
  
  snd_pcm_close(handle);
  return 0;
}
```

**Expected output:**
```
Requested:  10 ms â†’ Got:    512 frames (10.7 ms)
Requested:  25 ms â†’ Got:   1200 frames (25.0 ms)
Requested:  50 ms â†’ Got:   2400 frames (50.0 ms)
Requested: 100 ms â†’ Got:   4800 frames (100.0 ms)
```

---

### Exercise 3: Adaptive Latency Demo

Create `adaptive_latency.c`:
```c
#include <stdio.h>

void show_latency_at_fps(int fps) {
  int sample_rate = 48000;
  int frames_buffered = 2;
  
  int samples_per_frame = sample_rate / fps;
  int total_samples = samples_per_frame * frames_buffered;
  float latency_ms = (total_samples / (float)sample_rate) * 1000.0f;
  
  printf("%3d FPS: %4d samples/frame Ã— %d = %5d samples = %.1f ms latency\n",
         fps, samples_per_frame, frames_buffered, total_samples, latency_ms);
}

int main() {
  printf("Adaptive Latency (2 frames buffered):\n\n");
  
  show_latency_at_fps(24);   // Film
  show_latency_at_fps(30);   // Console games
  show_latency_at_fps(60);   // PC games
  show_latency_at_fps(120);  // High refresh
  show_latency_at_fps(144);  // 144Hz monitors
  show_latency_at_fps(240);  // Competitive
  
  printf("\nNotice: Higher FPS = Lower latency automatically!\n");
  
  return 0;
}
```

**Output:**
```
 24 FPS: 2000 samples/frame Ã— 2 =  4000 samples = 83.3 ms latency
 30 FPS: 1600 samples/frame Ã— 2 =  3200 samples = 66.7 ms latency
 60 FPS:  800 samples/frame Ã— 2 =  1600 samples = 33.3 ms latency
120 FPS:  400 samples/frame Ã— 2 =   800 samples = 16.7 ms latency
144 FPS:  333 samples/frame Ã— 2 =   666 samples = 13.9 ms latency
240 FPS:  200 samples/frame Ã— 2 =   400 samples = 8.3 ms latency

Notice: Higher FPS = Lower latency automatically!
```

---

### Exercise 4: Fix the Latency Bug

**Your current code has a bug! Find and fix it:**

```c
// WRONG (this is what's in the plan description, not your actual code):
int32_t latency_sample_count = game_update_hz * FRAMES_OF_AUDIO_LATENCY;

// Should be:
int32_t latency_sample_count = 
    (samples_per_second / game_update_hz) * FRAMES_OF_AUDIO_LATENCY;
```

**Verify the fix:**
```c
// Test at 60 FPS, 48kHz, 2 frames
int game_update_hz = 60;
int samples_per_second = 48000;
int FRAMES_OF_AUDIO_LATENCY = 2;

// WRONG calculation:
int wrong = game_update_hz * FRAMES_OF_AUDIO_LATENCY;
// = 60 * 2 = 120 samples
// = 120 / 48000 = 2.5ms âŒ Too low!

// CORRECT calculation:
int correct = (samples_per_second / game_update_hz) * FRAMES_OF_AUDIO_LATENCY;
// = (48000 / 60) * 2 = 800 * 2 = 1600 samples
// = 1600 / 48000 = 33.33ms âœ… Correct!
```

---

## ğŸ“ Comprehension Check

**Before finishing Unit 2, answer these:**

1. **Awareness:** What does "2 frames of latency" mean at 60 FPS vs 120 FPS?

2. **Comprehension:** Why does higher FPS result in lower audio latency?

3. **Application:** Calculate latency for 30 FPS, 3 frames buffered, 48kHz.

4. **Analysis:** Your game runs at 60 FPS but drops to 30 FPS. What happens to latency?

5. **Synthesis:** Design latency strategy for a rhythm game (needs <10ms).

6. **Evaluation:** Is 2 frames always the right choice? When would you use 1 or 4?

---

## ğŸ“ Unit 2 Completion Checklist

**Before moving to Unit 3, verify you can:**

- [ ] Explain the difference between kernel and userspace audio
- [ ] Describe what PCM means and why 48kHz/16-bit is standard
- [ ] Configure ALSA using `snd_pcm_set_params()`
- [ ] Explain how ALSA's ring buffer works
- [ ] Convert between audio formats (S16, U8, FLOAT)
- [ ] Calculate latency from FPS and frame count
- [ ] Understand why Casey ties latency to frame rate

**Self-Assessment:**
- **Confidence (0-10):** ___
- **Can modify latency without breaking:** Yes / No
- **Understand ALL lines in `audio.c:269-285`:** Yes / No

---

## ğŸ”— Connection to Unit 3

**Unit 3: Frame-Aligned Audio (Day 19 Pattern)**
- You now understand WHAT latency is
- Next: HOW to synchronize audio writes with game loop
- What's a "pull system" vs "push system"?
- How to detect and recover from underruns?

---

## ğŸ“ Final Reflection (Write in UNITS-TRACKER.md)

### Update Unit 2 Status:
```markdown
## Unit 2: ALSA Architecture [COMPLETED] âœ…
**Status:** ğŸŸ¢ Completed
**Target Competence:** Level 3 (Can modify)
**Achieved:** Level ___ (fill in)

### Lessons
- [x] L2.1: Kernel vs Userspace
- [x] L2.2: PCM Basics
- [x] L2.3: ALSA Initialization
- [x] L2.4: Ring Buffers
- [x] L2.5: Sample Formats
- [x] L2.6: Latency Calculation

### Metrics
- **Confidence:** ___/10
- **Time Spent:** ___ hours
- **Aha Moments:** ___
- **Code Modified:** ___

### Reflections
1. **Key Takeaway:** ___
2. **Struggled With:** ___
3. **Surprised By:** ___
```

---

**Congratulations! Unit 2 complete. Move to Unit 3 when ready!** ğŸ‰
