# Unit 2, Lesson 5: Sample Formats

> **Learning Goal:** Understand different PCM formats and when to use each  
> **Time Estimate:** 30-45 minutes  
> **Prerequisite:** L2.4 (Ring Buffers)

---

## ðŸŽ¯ The Mystery You're Solving

In `audio.h:38-40`, you only define ONE format:

```c
typedef enum {
  LINUX_SND_PCM_FORMAT_S16_LE = 2  // Why only this one?
} linux_snd_pcm_format_t;
```

**Questions:**
- What other formats exist? (U8, S24, S32, FLOAT?)
- Why did Casey choose S16_LE for Handmade Hero?
- When would you use a different format?
- What does "LE" (Little Endian) actually mean in memory?

---

## ðŸ“š Core Concepts

### 1. The Complete ALSA Format Zoo

**ALSA supports 40+ formats! Here are the common ones:**

```c
// Unsigned formats (0 = silence, not center)
SND_PCM_FORMAT_U8           // 0-255 (8-bit unsigned)

// Signed formats (0 = silence, center of range)
SND_PCM_FORMAT_S16_LE       // -32768 to +32767 (16-bit, Little Endian)
SND_PCM_FORMAT_S16_BE       // -32768 to +32767 (16-bit, Big Endian)
SND_PCM_FORMAT_S24_LE       // -8388608 to +8388607 (24-bit packed)
SND_PCM_FORMAT_S24_3LE      // 24-bit in 3 bytes
SND_PCM_FORMAT_S32_LE       // -2147483648 to +2147483647 (32-bit)

// Floating point
SND_PCM_FORMAT_FLOAT_LE     // -1.0 to +1.0 (32-bit IEEE 754)
SND_PCM_FORMAT_FLOAT64_LE   // -1.0 to +1.0 (64-bit IEEE 754)
```

**Why S16_LE is most common:**

| Format | Pros | Cons | Use Case |
|--------|------|------|----------|
| **U8** | Tiny (1 byte/sample) | Audible hiss | Retro games, voice |
| **S16_LE** | Good quality, standard | Limited dynamic range | Games, music playback |
| **S24_LE** | Studio quality | 50% larger than S16 | Pro audio, mastering |
| **S32_LE** | Math precision | 2x size of S16 | DSP processing |
| **FLOAT** | Math convenience | Same size as S32 | Real-time effects |

---

### 2. Signed vs Unsigned

**Unsigned 8-bit (U8):**
```c
uint8_t sample = 128;  // Silence (center of 0-255 range)

Waveform:
255 â”€â”      â”Œâ”€  â† Maximum positive
     â”‚      â”‚
128 â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€  â† Silence (zero amplitude)
     â”‚      â”‚
  0 â”€â”˜      â””â”€  â† Maximum negative
```

**Signed 16-bit (S16):**
```c
int16_t sample = 0;  // Silence (zero)

Waveform:
+32767 â”€â”      â”Œâ”€  â† Maximum positive
        â”‚      â”‚
     0 â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€  â† Silence (zero amplitude)
        â”‚      â”‚
-32768 â”€â”˜      â””â”€  â† Maximum negative
```

**Why signed is better:**
- Zero means silence (intuitive)
- Math is simpler: `mix = sample1 + sample2`
- No DC offset to remove

**Converting U8 to S16:**
```c
uint8_t u8_sample = 200;
int16_t s16_sample = (u8_sample - 128) * 256;
//                   ^^^^^^^^^^^^^^^^^  ^^^
//                   Center at 0        Scale to 16-bit
```

---

### 3. Bit Depth and Dynamic Range

**The math:**
```
Dynamic Range (dB) = 20 Ã— logâ‚â‚€(2^bits)
                   â‰ˆ 6.02 Ã— bits

8-bit:  6.02 Ã— 8  = 48 dB   (audible hiss)
16-bit: 6.02 Ã— 16 = 96 dB   (CD quality)
24-bit: 6.02 Ã— 24 = 144 dB  (studio quality)
32-bit: 6.02 Ã— 32 = 192 dB  (overkill - quieter than atoms moving!)
```

**Real-world comparison:**

```
Environment         Loudness    Equivalent Bit Depth
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Threshold of hearing   0 dB     (N/A - absolute silence)
Quiet library         30 dB     ~5-bit
Normal conversation   60 dB     ~10-bit
Loud nightclub        90 dB     ~15-bit
Threshold of pain    120 dB     ~20-bit
Jet engine          140 dB     ~23-bit
```

**Why 16-bit is enough for games:**
- Quietest game room: ~30 dB
- Dynamic range needed: 90 dB (30 dB to 120 dB pain)
- 16-bit provides: 96 dB âœ…

---

### 4. Endianness (Byte Order)

**What is "Little Endian"?**

```c
int16_t value = 0x1234;

Little Endian (x86, ARM - most CPUs):
  Memory Address:  0x1000  0x1001
  Bytes:           0x34    0x12    â† Low byte first
                   â””â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”˜
                   "Little end" comes first

Big Endian (network byte order, old PowerPC):
  Memory Address:  0x1000  0x1001
  Bytes:           0x12    0x34    â† High byte first
                   â””â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”˜
                   "Big end" comes first
```

**Why it matters:**

```c
// Writing S16_LE on little-endian CPU (x86):
int16_t sample = 0x1234;
fwrite(&sample, 2, 1, file);
// File contains: 34 12 (correct!)

// Reading S16_BE on little-endian CPU:
int16_t sample;
fread(&sample, 2, 1, file);  // File contains: 12 34
// sample = 0x3412 (WRONG! Bytes swapped)

// Need to swap:
sample = (sample >> 8) | (sample << 8);  // Now 0x1234
```

**Your CPU is probably little-endian:**
```bash
lscpu | grep "Byte Order"
# Output: Byte Order:   Little Endian
```

**Casey's choice: S16_LE** - matches x86/ARM CPUs (no byte swapping needed!)

---

### 5. Special Formats

#### **A. 24-bit Audio (Tricky!)**

**S24_LE (32-bit container):**
```c
// Stored in 4 bytes, but only 24 bits used
Memory: [LL][MM][HH][00]
         ^   ^   ^   ^
         Low Mid High Padding (unused)
         
int32_t s24_sample = 0x00123456;  // Top byte unused
```

**S24_3LE (packed, 3 bytes):**
```c
// Stored in exactly 3 bytes (no padding)
Memory: [LL][MM][HH]
         ^   ^   ^
         Low Mid High
         
// Harder to work with (not aligned to 4-byte boundary)
```

**Why 24-bit exists:**
- Studio recording (capture full dynamic range)
- Not needed for playback (16-bit is enough)
- Your game uses 16-bit âœ…

#### **B. Floating Point Audio**

**FLOAT (32-bit IEEE 754):**
```c
float sample = 0.5f;  // Range: -1.0 to +1.0

// 0.0 = silence
// +1.0 = maximum positive
// -1.0 = maximum negative

// Easy math!
float mixed = sample1 * 0.5f + sample2 * 0.5f;  // Mix two sources
```

**Why NOT use float for games?**
- Same size as S32 (4 bytes vs 2 bytes for S16)
- Slower on some hardware
- ALSA converts to S16 anyway (on most consumer sound cards)
- Casey's rule: Use simplest format that works

**When to use float:**
- Real-time audio processing (effects, filters)
- Multi-track mixing (avoid integer overflow)
- Plugin APIs (VST expects float)

---

## ðŸ§ª Hands-On Exercises

### Exercise 1: Format Conversion

Create `convert_formats.c`:
```c
#include <stdio.h>
#include <stdint.h>
#include <math.h>

// Convert S16 to U8
uint8_t s16_to_u8(int16_t s16) {
  // Scale from [-32768, 32767] to [0, 255]
  return (s16 / 256) + 128;
}

// Convert S16 to FLOAT
float s16_to_float(int16_t s16) {
  return s16 / 32768.0f;  // Scale to [-1.0, 1.0]
}

// Convert FLOAT to S16
int16_t float_to_s16(float f) {
  // Clamp to [-1.0, 1.0] then scale
  if (f > 1.0f) f = 1.0f;
  if (f < -1.0f) f = -1.0f;
  return (int16_t)(f * 32767.0f);
}

int main() {
  int16_t samples_s16[] = {0, 16384, 32767, -16384, -32768};
  
  printf("S16      U8     FLOAT\n");
  printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
  
  for (int i = 0; i < 5; i++) {
    uint8_t u8 = s16_to_u8(samples_s16[i]);
    float f = s16_to_float(samples_s16[i]);
    
    printf("%6d   %3d   %+.3f\n", samples_s16[i], u8, f);
  }
  
  return 0;
}
```

**Expected output:**
```
S16      U8     FLOAT
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     0   128   +0.000
 16384   192   +0.500
 32767   255   +1.000
-16384    64   -0.500
-32768     0   -1.000
```

---

### Exercise 2: Byte Order Demo

Create `endian_test.c`:
```c
#include <stdio.h>
#include <stdint.h>

void print_bytes(void *ptr, int size) {
  uint8_t *bytes = (uint8_t*)ptr;
  for (int i = 0; i < size; i++) {
    printf("%02X ", bytes[i]);
  }
  printf("\n");
}

int main() {
  int16_t value = 0x1234;
  
  printf("Value: 0x%04X\n", value);
  printf("Memory: ");
  print_bytes(&value, 2);
  
  // Check endianness
  if (*(uint8_t*)&value == 0x34) {
    printf("CPU is LITTLE ENDIAN (x86/ARM)\n");
  } else {
    printf("CPU is BIG ENDIAN (rare)\n");
  }
  
  // Swap bytes
  int16_t swapped = (value >> 8) | (value << 8);
  printf("\nSwapped: 0x%04X\n", swapped);
  printf("Memory: ");
  print_bytes(&swapped, 2);
  
  return 0;
}
```

**Output on x86:**
```
Value: 0x1234
Memory: 34 12           â† Little endian!
CPU is LITTLE ENDIAN (x86/ARM)

Swapped: 0x3412
Memory: 12 34           â† Big endian (after swap)
```

---

### Exercise 3: Measure Format Sizes

Create `format_sizes.c`:
```c
#include <stdio.h>
#include <stdint.h>

int main() {
  printf("Audio Format Memory Usage (1 second stereo at 48kHz):\n\n");
  
  printf("Format     Bytes/Sample   Total Size\n");
  printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
  
  int samples = 48000 * 2;  // 1 sec stereo
  
  printf("U8         %d            %6d bytes (%4.1f KB)\n",
         1, samples * 1, samples * 1 / 1024.0);
  printf("S16_LE     %d            %6d bytes (%4.1f KB)\n",
         2, samples * 2, samples * 2 / 1024.0);
  printf("S24_3LE    %d            %6d bytes (%4.1f KB)\n",
         3, samples * 3, samples * 3 / 1024.0);
  printf("S32_LE     %d            %6d bytes (%4.1f KB)\n",
         4, samples * 4, samples * 4 / 1024.0);
  printf("FLOAT      %d            %6d bytes (%4.1f KB)\n",
         4, samples * 4, samples * 4 / 1024.0);
  
  return 0;
}
```

**Output:**
```
U8         1             96000 bytes (93.8 KB)
S16_LE     2            192000 bytes (187.5 KB)
S24_3LE    3            288000 bytes (281.2 KB)
S32_LE     4            384000 bytes (375.0 KB)
FLOAT      4            384000 bytes (375.0 KB)
```

---

### Exercise 4: Test Format Support

Create `test_all_formats.c`:
```c
#include <alsa/asoundlib.h>
#include <stdio.h>

typedef struct {
  snd_pcm_format_t format;
  const char *name;
} FormatTest;

int main() {
  FormatTest formats[] = {
    {SND_PCM_FORMAT_U8, "U8"},
    {SND_PCM_FORMAT_S16_LE, "S16_LE"},
    {SND_PCM_FORMAT_S16_BE, "S16_BE"},
    {SND_PCM_FORMAT_S24_LE, "S24_LE"},
    {SND_PCM_FORMAT_S24_3LE, "S24_3LE"},
    {SND_PCM_FORMAT_S32_LE, "S32_LE"},
    {SND_PCM_FORMAT_FLOAT_LE, "FLOAT_LE"},
  };
  
  printf("Testing ALSA format support:\n\n");
  
  for (int i = 0; i < 7; i++) {
    snd_pcm_t *handle;
    snd_pcm_open(&handle, "default", SND_PCM_STREAM_PLAYBACK, 0);
    
    int err = snd_pcm_set_params(handle, formats[i].format,
                                 SND_PCM_ACCESS_RW_INTERLEAVED,
                                 2, 48000, 1, 50000);
    
    printf("%-12s: %s\n", formats[i].name,
           err < 0 ? "âŒ Not supported" : "âœ… Supported");
    
    snd_pcm_close(handle);
  }
  
  return 0;
}
```

---

## ðŸŽ“ Comprehension Check

**Before moving to L2.6, answer these:**

1. **Awareness:** What's the difference between U8 and S16?

2. **Comprehension:** Why is 16-bit "CD quality" but 24-bit is "studio quality"?

3. **Application:** Convert this S16 sample to float: `int16_t s = 16384;`

4. **Analysis:** Your game uses S16_LE. Sound card only supports S16_BE. What happens?

5. **Synthesis:** Design audio format for a phone game (limited memory).

6. **Evaluation:** Would FLOAT be better than S16 for your game? Why/why not?

---

## ðŸ”— Connection to Next Lesson

**L2.6: Latency Calculation**
- You know formats affect buffer size (U8 = half size of S16)
- Next: How to calculate ACTUAL latency?
- Why `game_update_hz * FRAMES_OF_AUDIO_LATENCY`?
- How does latency relate to FPS?

---

## ðŸ“ Reflection Questions (Write in UNITS-TRACKER.md)

1. **Aha Moment:** When did format trade-offs make sense?

2. **Conversion Practice:** Which conversion was trickiest?

3. **Web Dev Connection:** Is this like image format choice (PNG vs JPEG)?

4. **Design Choice:** Why S16_LE for Handmade Hero?

---

**When ready, update UNITS-TRACKER.md and move to L2.6!** âœ…
