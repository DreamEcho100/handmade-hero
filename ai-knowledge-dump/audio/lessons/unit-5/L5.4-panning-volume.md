# L5.4: Panning & Volume - Stereo Sound Control

**Unit 5: Advanced Audio Patterns**  
**Estimated Time:** 60-75 minutes  
**Competence Target:** Level 4 (Analysis - understand power laws)

---

## Learning Objectives

By the end of this lesson, you will:

1. **Implement** stereo panning from left to right
2. **Explain** why center panning uses 0.707, not 0.5
3. **Apply** constant-power panning law for smooth balance
4. **Debug** volume ramping to prevent clicks
5. **Create** circular panning animation
6. **Understand** the difference between linear and equal-power panning

---

## The Mystery: Why Not Just Split 50/50?

### Naive Center Panning (WRONG)

```c
// Center: play at half volume in each speaker
int16_t left = sample * 0.5f;
int16_t right = sample * 0.5f;
```

**Problem:** This sounds **quieter** than full left or full right!

**Proof:**
- Full left: `left=1.0, right=0.0` ‚Üí Total energy = 1.0¬≤  = 1.0
- Center:    `left=0.5, right=0.5` ‚Üí Total energy = 0.5¬≤ + 0.5¬≤ = 0.5
- Full right: `left=0.0, right=1.0` ‚Üí Total energy = 1.0¬≤  = 1.0

**Result:** Center is **half as loud** as left/right! üîä‚ùå

---

### Correct Center Panning (Constant-Power)

```c
// Center: use sqrt(0.5) ‚âà 0.707
int16_t left = sample * 0.707f;
int16_t right = sample * 0.707f;
```

**Why 0.707?**
- Total energy = 0.707¬≤ + 0.707¬≤ = 0.5 + 0.5 = 1.0 ‚úÖ

**This is called "constant-power panning law"** ‚Äî perceived loudness stays constant.

---

## Concept 1: Linear Panning (Simple but Wrong)

### Formula

```c
float pan = 0.5f;  // 0.0 = left, 0.5 = center, 1.0 = right

float left_gain = 1.0f - pan;
float right_gain = pan;
```

**Example values:**
| Pan | Left Gain | Right Gain | Total Energy |
|-----|-----------|------------|--------------|
| 0.0 | 1.0       | 0.0        | 1.0          |
| 0.25 | 0.75     | 0.25       | 0.625        |
| 0.5 | 0.5       | 0.5        | 0.5          |
| 0.75 | 0.25     | 0.75       | 0.625        |
| 1.0 | 0.0       | 1.0        | 1.0          |

**Problem:** Center is quieter! (Energy drops to 0.5)

**When to use:** Simple UI sliders, non-critical applications

---

## Concept 2: Constant-Power Panning (Correct)

### Formula

```c
#include <math.h>

float pan = 0.5f;  // 0.0 to 1.0
float angle = pan * (PI / 2.0f);  // Map to 0 to 90 degrees

float left_gain = cosf(angle);   // cos(0¬∞) = 1.0, cos(90¬∞) = 0.0
float right_gain = sinf(angle);  // sin(0¬∞) = 0.0, sin(90¬∞) = 1.0
```

**Example values:**
| Pan | Angle (deg) | Left Gain | Right Gain | Total Energy |
|-----|-------------|-----------|------------|--------------|
| 0.0 | 0¬∞          | 1.0       | 0.0        | 1.0          |
| 0.25 | 22.5¬∞      | 0.924     | 0.383      | 1.0          |
| 0.5 | 45¬∞         | 0.707     | 0.707      | 1.0          |
| 0.75 | 67.5¬∞      | 0.383     | 0.924      | 1.0          |
| 1.0 | 90¬∞         | 0.0       | 1.0        | 1.0          |

**Why it works:**
```
cos¬≤(Œ∏) + sin¬≤(Œ∏) = 1  (Pythagorean identity)
```

**Web Dev Analogy:**
- Linear panning = `opacity: 0.5` (looks dimmer)
- Constant-power = adjusting RGB brightness to maintain perceived luminance

---

## Exercise 1: Implement Both Panning Methods

**Add to your audio code:**

```c
static float pan_position = 0.0f;  // 0.0 = left, 1.0 = right
static int use_constant_power = 1; // Toggle between methods

void GameOutputSound(GameSoundOutput *sound_buffer) {
  static int32_t running_sample_index = 0;
  int32_t sps = sound_buffer->samples_per_second;
  
  // Slowly pan from left to right (full sweep in 4 seconds)
  pan_position += (1.0f / sps) * (sound_buffer->sample_count / 4.0f);
  if (pan_position > 1.0f) {
    pan_position = 0.0f;
    use_constant_power = !use_constant_power;  // Toggle method
    printf("Switched to %s panning\n", 
           use_constant_power ? "CONSTANT-POWER" : "LINEAR");
  }
  
  float left_gain, right_gain;
  
  if (use_constant_power) {
    // Constant-power panning
    float angle = pan_position * (PI / 2.0f);
    left_gain = cosf(angle);
    right_gain = sinf(angle);
  } else {
    // Linear panning
    left_gain = 1.0f - pan_position;
    right_gain = pan_position;
  }
  
  for (int32_t i = 0; i < sound_buffer->sample_count; i++) {
    float t = (float)(running_sample_index + i) / sps;
    float sine_value = sinf(2.0f * PI * 440.0f * t);  // 440 Hz (A4)
    
    int16_t base_sample = (int16_t)(sine_value * 3000);
    
    sound_buffer->samples[i * 2 + 0] = (int16_t)(base_sample * left_gain);
    sound_buffer->samples[i * 2 + 1] = (int16_t)(base_sample * right_gain);
  }
  
  running_sample_index += sound_buffer->sample_count;
}
```

**Run and listen:**
- First 4 seconds: Constant-power (smooth loudness)
- Next 4 seconds: Linear (center is quieter)
- Repeat

**Goal:** Hear the difference!

---

## Concept 3: Volume Ramping

### The Click Problem

**Naive volume change:**
```c
static float volume = 0.0f;

void GameOutputSound(...) {
  // User presses key to increase volume
  if (key_pressed) {
    volume = 1.0f;  // ‚Üê Instant jump!
  }
  
  for (...) {
    int16_t sample = (int16_t)(sine_value * 3000 * volume);
  }
}
```

**Problem:**
```
Frame 1: volume = 0.0 ‚Üí samples = 0
Frame 2: volume = 1.0 ‚Üí samples = 3000  ‚Üê Discontinuity!
```

**Result:** CLICK!

---

### Solution: Ramp Over Multiple Frames

```c
static float current_volume = 0.0f;
static float target_volume = 0.0f;

void GameOutputSound(GameSoundOutput *sound_buffer) {
  // User input
  if (key_pressed) {
    target_volume = 1.0f;
  }
  if (key_released) {
    target_volume = 0.0f;
  }
  
  // Ramp speed: reach target in 50ms (3 frames @ 60 FPS)
  float ramp_speed = 1.0f / (0.05f * sound_buffer->samples_per_second);
  
  for (int32_t i = 0; i < sound_buffer->sample_count; i++) {
    // Gradually approach target
    if (current_volume < target_volume) {
      current_volume += ramp_speed;
      if (current_volume > target_volume) {
        current_volume = target_volume;
      }
    } else if (current_volume > target_volume) {
      current_volume -= ramp_speed;
      if (current_volume < target_volume) {
        current_volume = target_volume;
      }
    }
    
    // Use current_volume (smoothly changing)
    float sine_value = sinf(...);
    int16_t sample = (int16_t)(sine_value * 3000 * current_volume);
    
    sound_buffer->samples[i * 2 + 0] = sample;
    sound_buffer->samples[i * 2 + 1] = sample;
  }
}
```

**Result:** Smooth fade-in/fade-out, no clicks!

---

## Exercise 2: Keyboard-Controlled Volume

**Add this code:**

```c
static float master_volume = 0.5f;
static float target_volume = 0.5f;

void GameUpdateAndRender(...) {
  // In your input handling:
  if (key_down['=']) {  // Plus key
    target_volume = fminf(1.0f, target_volume + 0.1f);
  }
  if (key_down['-']) {  // Minus key
    target_volume = fmaxf(0.0f, target_volume - 0.1f);
  }
}

void GameOutputSound(GameSoundOutput *sound_buffer) {
  float ramp_per_sample = (target_volume - master_volume) / sound_buffer->sample_count;
  
  for (int32_t i = 0; i < sound_buffer->sample_count; i++) {
    master_volume += ramp_per_sample;
    
    // Generate tone
    float sine_value = sinf(...);
    int16_t sample = (int16_t)(sine_value * 3000 * master_volume);
    
    sound_buffer->samples[i * 2 + 0] = sample;
    sound_buffer->samples[i * 2 + 1] = sample;
  }
}
```

**Test:**
- Press `+` ‚Üí Volume increases smoothly
- Press `-` ‚Üí Volume decreases smoothly
- No clicks!

---

## Exercise 3: Circular Panning Animation

**Goal:** Make a tone spin around your head (left ‚Üí front ‚Üí right ‚Üí back).

**Code:**
```c
static float pan_angle = 0.0f;  // 0 to 2œÄ radians

void GameOutputSound(GameSoundOutput *sound_buffer) {
  static int32_t running_sample_index = 0;
  int32_t sps = sound_buffer->samples_per_second;
  
  // One rotation per 2 seconds
  float rotation_speed = (2.0f * PI) / 2.0f;  // radians per second
  float angle_increment = rotation_speed / sps;
  
  for (int32_t i = 0; i < sound_buffer->sample_count; i++) {
    // Update pan angle
    pan_angle += angle_increment;
    if (pan_angle > 2.0f * PI) {
      pan_angle -= 2.0f * PI;
    }
    
    // Convert circular position to stereo gains
    // Front (0¬∞):   left=0.707, right=0.707
    // Right (90¬∞):  left=0.0, right=1.0
    // Back (180¬∞):  left=0.707, right=0.707 (inverted phase)
    // Left (270¬∞):  left=1.0, right=0.0
    
    float left_gain = 0.707f * (1.0f + cosf(pan_angle));
    float right_gain = 0.707f * (1.0f + sinf(pan_angle));
    
    // Generate tone
    float t = (float)(running_sample_index + i) / sps;
    float sine_value = sinf(2.0f * PI * 440.0f * t);
    
    int16_t base_sample = (int16_t)(sine_value * 3000);
    
    sound_buffer->samples[i * 2 + 0] = (int16_t)(base_sample * left_gain);
    sound_buffer->samples[i * 2 + 1] = (int16_t)(base_sample * right_gain);
  }
  
  running_sample_index += sound_buffer->sample_count;
}
```

**Expected result:**
- Tone appears to rotate around your head
- Smooth transition (no clicks)

**Limitation:** This is 2D panning (left/right only). True 3D audio requires HRTF (Unit 9).

---

## Concept 4: Clipping Prevention

### The Problem

```c
// Two tones at full volume
float tone1 = sinf(...);  // Range: -1.0 to +1.0
float tone2 = sinf(...);  // Range: -1.0 to +1.0
float mixed = tone1 + tone2;  // Range: -2.0 to +2.0 ‚Üê CLIPPING!

int16_t sample = (int16_t)(mixed * 3000);  // Wraps around!
```

**Result:** Distorted audio

---

### Solution 1: Pre-Scale

```c
float tone1 = sinf(...);
float tone2 = sinf(...);
float mixed = (tone1 + tone2) * 0.5f;  // Divide by number of sources

int16_t sample = (int16_t)(mixed * 3000);  // Safe
```

---

### Solution 2: Soft Clipping (Limiter)

```c
float Limiter(float input) {
  // Soft clip using tanh() (smooth curve)
  return tanhf(input);  // Always stays in -1.0 to +1.0
}

float tone1 = sinf(...);
float tone2 = sinf(...);
float mixed = tone1 + tone2;
float limited = Limiter(mixed);

int16_t sample = (int16_t)(limited * 3000);
```

**Comparison:**
- Hard clip: `if (x > 1.0f) x = 1.0f` ‚Üí Sharp edge (distortion)
- Soft clip: `tanh(x)` ‚Üí Smooth curve (natural compression)

---

## Self-Check Quiz

### Question 1
**Why is center panning `0.707` instead of `0.5`?**

A) 0.5 is too loud  
B) 0.707 maintains constant perceived loudness  
C) 0.5 causes clipping  
D) It's arbitrary  

<details>
<summary>Answer</summary>

**B) 0.707 maintains constant perceived loudness**

```
Energy = left¬≤ + right¬≤
0.707¬≤ + 0.707¬≤ = 0.5 + 0.5 = 1.0 (same as full left/right)
0.5¬≤ + 0.5¬≤ = 0.25 + 0.25 = 0.5 (half the energy!)
```
</details>

---

### Question 2
**What is `0.707` the square root of?**

A) 0.5  
B) 1.0  
C) 2.0  
D) œÄ  

<details>
<summary>Answer</summary>

**A) 0.5**

```
sqrt(0.5) ‚âà 0.7071
```

This is why it's also written as `sqrtf(0.5f)` in code.
</details>

---

### Question 3
**What causes clicks when changing volume?**

A) Volume too high  
B) Instant jumps creating discontinuities  
C) Sample rate too low  
D) Buffer underrun  

<details>
<summary>Answer</summary>

**B) Instant jumps creating discontinuities**

```
Frame 1: volume = 0.0 ‚Üí sample = 0
Frame 2: volume = 1.0 ‚Üí sample = 3000  ‚Üê Jump! (click)
```

**Fix:** Ramp volume over multiple samples.
</details>

---

### Question 4
**In constant-power panning, what formula gives the left gain?**

A) `1.0 - pan`  
B) `cos(pan * PI / 2)`  
C) `sin(pan * PI / 2)`  
D) `pan * 0.707`  

<details>
<summary>Answer</summary>

**B) `cos(pan * PI / 2)`**

```c
float angle = pan * (PI / 2.0f);  // 0 to 90 degrees
float left_gain = cosf(angle);    // cos(0¬∞)=1.0, cos(90¬∞)=0.0
float right_gain = sinf(angle);   // sin(0¬∞)=0.0, sin(90¬∞)=1.0
```
</details>

---

### Question 5
**If two sine waves add to `2.0`, what happens when converting to int16_t?**

A) Result is 2  
B) Clipping to 32767  
C) Depends on volume scaling  
D) Automatic normalization  

<details>
<summary>Answer</summary>

**C) Depends on volume scaling**

```c
float mixed = 2.0f;  // Out of range
int16_t sample = (int16_t)(mixed * 3000);  // 6000 ‚Üí OK
int16_t sample = (int16_t)(mixed * 20000); // 40000 ‚Üí Wraps to -25536 (CLIP!)
```

Always scale BEFORE converting to int16_t.
</details>

---

## Key Takeaways

### Panning Methods

| Method | Formula | Pros | Cons |
|--------|---------|------|------|
| **Linear** | `L=1-p, R=p` | Simple | Center is quieter |
| **Constant-Power** | `L=cos(Œ∏), R=sin(Œ∏)` | Perceptually uniform | Needs trig |

**Always use constant-power for games/music!**

---

### Volume Ramping Pattern

```c
// Per-sample ramping
float delta = (target - current) / sample_count;
for (int i = 0; i < sample_count; i++) {
  current += delta;
  sample = (int16_t)(waveform * current);
}
```

**Ramp time:** 20-100ms (prevents clicks, feels instant)

---

### Clipping Prevention

1. **Pre-scale:** Divide by number of sources
2. **Soft-clip:** Use `tanhf()` or similar
3. **Monitor:** Add clipping detection (from L5.3)

---

## Connection to Other Lessons

**Prerequisites:**
- L5.3: Sine Wave Math (generating audio)
- L2.5: Sample Formats (int16_t range)

**Enables:**
- L9.1: Mixer Architecture (multi-source volume control)
- L9.3: Event System (trigger volume/pan changes)
- L8.2: SIMD Optimization (vectorize gain multiplication)

---

## Next Lesson Preview

**L5.5: Memory Management**
- Casey's `PlatformMemoryBlock` pattern
- Why avoid `malloc()` in audio callback
- Arena allocators
- Cache-friendly data layout

**Teaser:**
```c
// BAD: malloc in audio loop
int16_t *buffer = malloc(sample_count * 4);  // Slow!

// GOOD: pre-allocate
int16_t buffer[4800];  // Stack, instant
```

You'll learn Casey's philosophy: "Don't ask the OS for memory at runtime."

---

**Estimated Completion Time:** 60-75 minutes  
**Difficulty:** ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ (Medium)  
**Competence Level Achieved:** 4/6 (Analysis)

---

**Progress:** Unit 5 is 80% complete! (4/5 lessons done)

