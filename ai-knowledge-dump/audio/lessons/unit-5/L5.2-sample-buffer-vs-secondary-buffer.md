# L5.2: Sample Buffer vs Secondary Buffer Architecture

**Unit 5: Advanced Audio Patterns**  
**Estimated Time:** 60-75 minutes  
**Competence Target:** Level 4 (Analysis - understand tradeoffs)

---

## Learning Objectives

By the end of this lesson, you will:

1. **Distinguish** between "sample buffer" (staging) and "secondary buffer" (kernel)
2. **Explain** why Casey's DirectSound pattern uses two buffers
3. **Measure** the memory copy overhead in your audio pipeline
4. **Analyze** when zero-copy architectures are possible
5. **Understand** buffer ownership patterns in systems programming
6. **Compare** your ALSA implementation to DirectSound's original design

---

## The Mystery: Why Two Buffers?

### Your Code Has This Pattern

**In `audio.c` (lines 35-49):**
```c
typedef struct LinuxSoundOutput {
  snd_pcm_t *handle;
  int32_t samples_per_second;
  int32_t bytes_per_sample;
  uint32_t secondary_buffer_size;  // ← "Secondary" buffer
  // ...
} LinuxSoundOutput;
```

**In `backend.c` (lines 775-780):**
```c
GameSoundOutput game_sound_output = {
  .samples_per_second = sound_output.samples_per_second,
  .sample_count = sample_count,
  .samples = sample_buffer,  // ← "Sample" buffer (staging)
};
```

**Then you copy between them (backend.c:857-861):**
```c
LinuxFillSoundBuffer(&sound_output, game_sound_output.samples,
                     0, sample_count);
// ↓ This writes to ALSA's kernel buffer (secondary)
```

**Web Dev Confusion:**
- In Node.js streams, you write directly: `stream.write(chunk)`
- Why not `SndPcmWritei(samples)` directly from game code?

---

## Concept 1: Buffer Roles

### 1. Sample Buffer (Staging / Userspace)

**Location:** Your program's heap memory  
**Owner:** Game code (platform-agnostic)  
**Lifetime:** One frame (16.6ms @ 60 FPS)  
**Size:** Exactly one frame's worth of audio  

**In your code (`backend.c:775`):**
```c
int16_t sample_buffer[4800];  // 800 samples/frame * 2 channels * sizeof(int16_t)
```

**Purpose:**
- Game fills this with audio data
- Temporary workspace
- No ALSA types contaminate game code

**Web Dev Analogy:**
```javascript
// Staging buffer
const requestBody = JSON.stringify(data); 
// (data → string conversion happens in userspace)

// Then send
fetch(url, { body: requestBody });
// (now kernel handles network)
```

---

### 2. Secondary Buffer (Kernel / Ring Buffer)

**Location:** ALSA kernel driver memory  
**Owner:** Operating system  
**Lifetime:** Persistent (entire program run)  
**Size:** Multiple frames (latency buffer)  

**In your code (`audio.c:269-285`):**
```c
int32_t latency_sample_count = game_update_hz * 2;  // 2 frames = 33ms
```

**Purpose:**
- Prevents underruns (buffer runs dry)
- Kernel reads from this to feed hardware
- Ring buffer (wraps around)

**Analogy:**
```javascript
// Secondary buffer = socket send buffer
// OS manages this, you just write to it
socket.write(chunk);  // ← Goes to kernel buffer first, then network card
```

---

## Concept 2: Why DirectSound Used Two Buffers

### Casey's Windows Pattern (from Handmade Hero Day 9-10)

**DirectSound API:**
```c
// Create secondary buffer (kernel)
IDirectSoundBuffer_Create(dsound, &buffer_desc, &secondary_buffer);

// Lock a region to write
IDirectSoundBuffer_Lock(secondary_buffer, offset, bytes, &region1, &region2);

// Write directly to locked memory
memcpy(region1, game_samples, bytes);

// Unlock (kernel now owns it)
IDirectSoundBuffer_Unlock(secondary_buffer);
```

**Why not write directly from game code?**
1. **Kernel buffer is ring-shaped** — game code would need wrap-around logic
2. **Lock/unlock is expensive** — system call overhead
3. **Game code shouldn't know about platform** — `IDirectSoundBuffer` is Windows-only

---

### Your ALSA Port

**ALSA equivalent:**
```c
// No "lock" — just write
snd_pcm_sframes_t frames_written = SndPcmWritei(
  handle,
  samples,     // ← From sample buffer
  frame_count  // ← How much to copy
);
```

**Key difference:**
- ALSA `snd_pcm_writei` **copies** from your buffer to kernel buffer
- DirectSound `Lock` gave you **direct pointer** to kernel buffer
- Both patterns still use two buffers (staging + kernel)

---

## Concept 3: Memory Ownership Patterns

### Who Owns What?

| Buffer Type | Owner | Allocator | Deallocator |
|------------|-------|-----------|-------------|
| Sample Buffer | Game code | `backend.c` stack | Automatic (frame ends) |
| Secondary Buffer | ALSA kernel | `snd_pcm_hw_params` | `snd_pcm_close` |

**In your code:**

**Sample buffer (backend.c:775):**
```c
int16_t sample_buffer[4800];  // Stack-allocated, dies after frame
```

**Secondary buffer (audio.c:300-310):**
```c
// Kernel allocates during this call
int32_t error = SndPcmHwParams(handle, hardware_parameters);
// Buffer lives until SndPcmClose(handle)
```

**Web Dev Analogy:**
```javascript
function handleRequest(req, res) {
  const body = req.body;  // ← Temporary (like sample_buffer)
  
  // Write to response stream
  res.write(body);  // ← Goes to kernel's TCP buffer (like secondary_buffer)
}
// `body` dies here, but TCP buffer persists
```

---

## Exercise 1: Measure Copy Overhead

**Goal:** See if the `SndPcmWritei` copy is expensive.

**Add to `backend.c` (after line 830):**
```c
// Before write
struct timespec copy_start, copy_end;
clock_gettime(CLOCK_MONOTONIC, &copy_start);

LinuxFillSoundBuffer(&sound_output, game_sound_output.samples,
                     0, sample_count);

clock_gettime(CLOCK_MONOTONIC, &copy_end);

// Calculate overhead
int64_t copy_ns = (copy_end.tv_sec - copy_start.tv_sec) * 1000000000LL +
                  (copy_end.tv_nsec - copy_start.tv_nsec);

if (copy_ns > 100000) {  // > 100 microseconds
  printf("COPY WARNING: %lld ns (%.2f%% of frame)\n",
         copy_ns, (copy_ns / 16666666.0) * 100);
}
```

**Expected result:**
- Normal: 5-20 microseconds (< 0.1% of 16ms frame)
- Bad: > 100 microseconds (means buffer is huge or CPU is slow)

**Interpretation:**
- If copy is cheap (< 0.5% of frame), two-buffer pattern is fine
- If expensive, consider mmap() zero-copy (advanced)

---

## Exercise 2: Break the Abstraction

**Goal:** See what happens if game code writes directly to kernel buffer.

**Modify `backend.c` (around line 780):**
```c
// BEFORE (correct):
game_sound_output.samples = sample_buffer;

// AFTER (broken):
// game_sound_output.samples = NULL;  // Force game to crash

// Then in handmade.c (game code):
int16_t *out = sound_buffer->samples;
*out = 0;  // SEGFAULT if samples == NULL
```

**Why this experiment?**
- Proves game code **must not** access kernel buffer directly
- Sample buffer is the **contract boundary**

---

## Exercise 3: Visualize Buffer Sizes

**Add to `audio.c` (after line 310):**
```c
printf("=== BUFFER ARCHITECTURE ===\n");
printf("Sample buffer (staging):   %zu bytes (%.1f ms)\n",
       sizeof(int16_t) * sample_count * 2,
       (sample_count / (float)samples_per_second) * 1000);

printf("Secondary buffer (kernel): %u bytes (%.1f ms)\n",
       secondary_buffer_size,
       (secondary_buffer_size / (float)(bytes_per_sample * samples_per_second)) * 1000);

printf("Ratio: 1:%.1f\n",
       (float)secondary_buffer_size / (sizeof(int16_t) * sample_count * 2));
```

**Expected output:**
```
=== BUFFER ARCHITECTURE ===
Sample buffer (staging):   1920 bytes (16.7 ms)
Secondary buffer (kernel): 7680 bytes (66.7 ms)
Ratio: 1:4
```

**Analysis:**
- If ratio is 1:1 → No safety margin (underruns likely)
- If ratio is 1:4 → Healthy (4 frames of latency)
- If ratio is 1:10+ → Latency too high (> 166ms)

---

## Concept 4: When Zero-Copy Is Possible

### ALSA mmap() Mode

**Alternative to `snd_pcm_writei`:**
```c
// Get direct access to kernel ring buffer
const snd_pcm_channel_area_t *areas;
snd_pcm_mmap_begin(handle, &areas, &offset, &frames);

// Write directly to kernel memory
int16_t *kernel_buffer = (int16_t *)areas[0].addr + offset;
memcpy(kernel_buffer, game_samples, frames * 4);  // Still copying!

// Commit
snd_pcm_mmap_commit(handle, offset, frames);
```

**Problem:**
- Game code would need to handle ring buffer wrap-around
- Breaks platform abstraction
- Only saves one memcpy (not worth complexity)

**When zero-copy helps:**
- Real-time audio (< 5ms latency)
- Professional DAW software
- Not for games (latency budget is 33ms, copy is < 0.1ms)

---

## Web Dev Analogy: Request → Response Pipeline

### Express.js Example

```javascript
app.post('/upload', (req, res) => {
  // Sample buffer = req.body (parsed, in Node's heap)
  const data = req.body;
  
  // Process (like game filling audio)
  const processed = transform(data);
  
  // Secondary buffer = res.write() → TCP kernel buffer
  res.write(processed);  // ← Kernel handles network
});
```

**Two-buffer pattern:**
1. `req.body` — Userspace staging (Express controls)
2. TCP send buffer — Kernel (OS controls)

**Why not write directly to TCP buffer?**
- Same reason as audio: abstraction, ring buffer complexity, ownership

---

## Self-Check Quiz

### Question 1
**What is the purpose of the "sample buffer" (staging buffer)?**

A) Prevent audio underruns  
B) Store multiple frames for latency  
C) Isolate game code from platform-specific types  
D) Improve audio quality  

<details>
<summary>Answer</summary>

**C) Isolate game code from platform-specific types**

The sample buffer is the **contract boundary**. Game code writes `int16_t` samples without knowing about ALSA/DirectSound/PulseAudio.
</details>

---

### Question 2
**In your code, how many frames can the secondary buffer hold?**

A) 1 frame (16.6ms)  
B) 2 frames (33ms)  
C) 4 frames (66ms)  
D) 10 frames (166ms)  

<details>
<summary>Answer</summary>

**C) 4 frames (66ms)**

From `audio.c:269`:
```c
int32_t latency_sample_count = game_update_hz * 2;  // 2 frames
```
But ALSA often doubles this internally → 4 frames total.

Check with Exercise 3 output!
</details>

---

### Question 3
**If `SndPcmWritei` takes 50 microseconds, what % of a 16ms frame is that?**

A) 0.03%  
B) 0.3%  
C) 3%  
D) 30%  

<details>
<summary>Answer</summary>

**B) 0.3%**

Calculation:
```
50 microseconds = 0.05 ms
16 ms frame
(0.05 / 16) * 100 = 0.3125%
```

This is negligible overhead.
</details>

---

### Question 4
**Why doesn't DirectSound use `memcpy` like ALSA?**

A) DirectSound is slower  
B) DirectSound gives direct pointer to kernel buffer (Lock/Unlock)  
C) Windows doesn't support copying  
D) DirectSound doesn't use ring buffers  

<details>
<summary>Answer</summary>

**B) DirectSound gives direct pointer to kernel buffer**

```c
IDirectSoundBuffer_Lock(secondary_buffer, ...);  // Get pointer
memcpy(locked_region, samples, bytes);           // Still copies!
IDirectSoundBuffer_Unlock(secondary_buffer);
```

Both patterns copy, but DirectSound exposes the kernel buffer pointer.
</details>

---

### Question 5
**What happens if the sample buffer is stack-allocated inside a loop?**

A) Nothing — same as global  
B) Audio will crackle  
C) Memory leak  
D) Buffer is reallocated every frame (inefficient)  

<details>
<summary>Answer</summary>

**A) Nothing — same as global**

From `backend.c:775`:
```c
int16_t sample_buffer[4800];  // Stack allocation
```

Stack allocation is **fast** (just adjusting stack pointer). No malloc overhead. This is fine because:
- Buffer is reused every frame
- Size is fixed
- No fragmentation

If it were `malloc()` every frame → memory leak risk.
</details>

---

## Key Takeaways

### The Two-Buffer Pattern

| Aspect | Sample Buffer | Secondary Buffer |
|--------|--------------|------------------|
| **Owner** | Game code | Kernel (ALSA) |
| **Location** | Stack/heap | Kernel memory |
| **Size** | 1 frame | 2-4 frames |
| **Purpose** | Staging | Latency safety |
| **Lifetime** | Per-frame | Entire program |

---

### When to Use This Pattern

**Use two buffers when:**
- ✅ Platform abstraction matters (game runs on Windows + Linux)
- ✅ Kernel buffer is ring-shaped (complex wrap-around)
- ✅ Copy overhead is < 1% of frame time

**Use zero-copy when:**
- ❌ Real-time audio (< 5ms latency)
- ❌ Profiler shows copy is bottleneck (> 5% of frame)
- ❌ Single platform (no portability needed)

**For Handmade Hero games:** Two-buffer pattern is correct.

---

## Connection to Other Lessons

**Prerequisites:**
- L2.4: Ring Buffers (understand why secondary buffer is circular)
- L5.1: Platform API Design (why abstraction matters)

**Enables:**
- L5.3: Sine Wave Math (you'll fill sample_buffer with waves)
- L5.5: Memory Management (arena allocators vs stack buffers)
- L6.2: PulseAudio Port (same two-buffer pattern, different API)

---

## Debugging Checklist

**If audio is broken, check:**
1. **Sample buffer size:** Should be exactly 1 frame worth
   ```c
   int16_t sample_buffer[sample_count * 2];  // channels
   ```

2. **Secondary buffer size:** Should be 2-4 frames
   ```c
   latency_sample_count = game_update_hz * 2;
   ```

3. **Copy happens every frame:**
   ```c
   LinuxFillSoundBuffer(&sound_output, game_sound_output.samples, ...);
   ```

4. **No nullptr:** `game_sound_output.samples` must point to `sample_buffer`

**Add assertions:**
```c
assert(game_sound_output.samples != NULL);
assert(sample_count == 800);  // 48000 Hz / 60 FPS
```

---

## Next Lesson Preview

**L5.3: Sine Wave Math**
- How to fill `sample_buffer` with audio data
- Pure tone generation: `sin(2π * freq * time)`
- Phase continuity (why `running_sample_index` matters)
- Your first audio synthesis!

**Teaser code:**
```c
for (int32_t i = 0; i < sample_count; i++) {
  float t = (float)running_sample_index / samples_per_second;
  float value = sinf(2 * PI * 256.0f * t);  // 256 Hz tone
  sample_buffer[i * 2 + 0] = (int16_t)(value * 3000);  // Left
  sample_buffer[i * 2 + 1] = (int16_t)(value * 3000);  // Right
  running_sample_index++;
}
```

You'll understand every line of that by the end of L5.3!

---

**Estimated Completion Time:** 60-75 minutes  
**Difficulty:** ⭐⭐⭐☆☆ (Medium)  
**Competence Level Achieved:** 4/6 (Analysis)

---

**Progress:** Unit 5 is 40% complete! (2/5 lessons done)

