# L5.5: Memory Management - Casey's Audio Memory Philosophy

**Unit 5: Advanced Audio Patterns**  
**Estimated Time:** 75-90 minutes  
**Competence Target:** Level 5 (Synthesis - design memory systems)

---

## Learning Objectives

By the end of this lesson, you will:

1. **Explain** why `malloc()` in the audio callback is dangerous
2. **Implement** Casey's pre-allocated buffer pattern
3. **Understand** arena allocators (linear allocators)
4. **Analyze** cache-friendly data layouts for audio
5. **Compare** stack vs heap allocation for audio buffers
6. **Design** memory ownership patterns that prevent leaks

---

## The Mystery: Why No malloc() in Audio Code?

### Your Current Code (Safe)

**In `backend.c` (line 775):**
```c
void LinuxMainLoop(...) {
  int16_t sample_buffer[4800];  // Stack allocation ‚Üê GOOD!
  
  while (running) {
    // Fill buffer
    GameOutputSound(...);
    
    // Write to ALSA
    LinuxFillSoundBuffer(...);
  }
}
```

**Key observation:** `sample_buffer` is **NOT** allocated with `malloc()`.

---

### Tempting (but WRONG) Approach

```c
void GameOutputSound(GameSoundOutput *sound_buffer) {
  // DON'T DO THIS:
  int16_t *temp = (int16_t *)malloc(sound_buffer->sample_count * 4);
  
  // Fill temp...
  
  free(temp);
}
```

**Why this is dangerous:**

1. **Non-Deterministic Time**
   - `malloc()` may take 1¬µs or 1000¬µs (unpredictable)
   - Can search free lists, merge blocks, call `sbrk()`
   - **Audio deadline:** Must finish in 16ms @ 60 FPS

2. **Fragmentation**
   - Repeated alloc/free creates fragmentation
   - Eventually `malloc()` gets slower
   - Heap becomes swiss cheese

3. **Page Faults**
   - `malloc()` may trigger `mmap()` syscall
   - Kernel can swap pages to disk
   - **1000x slower** than RAM access

4. **Unnecessary**
   - Buffer size is **known at compile time**
   - Why ask the OS for memory you already know you need?

---

## Concept 1: Stack Allocation (Preferred)

### How It Works

**Stack allocation:**
```c
void MyFunction() {
  int16_t buffer[4800];  // ‚Üê Instant! Just moves stack pointer
  
  // Use buffer...
  
}  // ‚Üê Automatic cleanup (stack pointer moves back)
```

**Assembly (roughly):**
```asm
; Allocate 9600 bytes (4800 * 2)
sub rsp, 9600

; Use buffer at [rsp]
mov rdi, rsp
call FillBuffer

; Deallocate (automatic at function end)
add rsp, 9600
ret
```

**Cost:** ~1 CPU cycle (sub/add instruction)

---

### Stack Size Limits

**Problem:** Stack is finite (usually 8 MB on Linux).

```c
void BadFunction() {
  int16_t huge_buffer[1000000];  // 2 MB ‚Äî might overflow stack!
}
```

**Check your buffer size:**
```c
int16_t sample_buffer[4800];  // 9600 bytes = 9.6 KB ‚Üê Safe!
```

**Rule of thumb:** Stack allocations < 1 MB are safe.

---

## Exercise 1: Measure Allocation Speed

**Goal:** See how slow `malloc()` is in audio loop.

**Add to `backend.c`:**
```c
#include <time.h>

void LinuxMainLoop(...) {
  struct timespec start, end;
  
  // Test 1: Stack allocation
  clock_gettime(CLOCK_MONOTONIC, &start);
  for (int i = 0; i < 1000; i++) {
    int16_t stack_buffer[4800];
    stack_buffer[0] = i;  // Prevent optimization
  }
  clock_gettime(CLOCK_MONOTONIC, &end);
  
  int64_t stack_ns = (end.tv_sec - start.tv_sec) * 1000000000LL +
                     (end.tv_nsec - start.tv_nsec);
  
  // Test 2: Heap allocation
  clock_gettime(CLOCK_MONOTONIC, &start);
  for (int i = 0; i < 1000; i++) {
    int16_t *heap_buffer = malloc(4800 * sizeof(int16_t));
    heap_buffer[0] = i;
    free(heap_buffer);
  }
  clock_gettime(CLOCK_MONOTONIC, &end);
  
  int64_t heap_ns = (end.tv_sec - start.tv_sec) * 1000000000LL +
                    (end.tv_nsec - start.tv_nsec);
  
  printf("=== ALLOCATION BENCHMARK (1000 iterations) ===\n");
  printf("Stack: %lld ns (%.1f ns/iteration)\n", stack_ns, stack_ns / 1000.0);
  printf("Heap:  %lld ns (%.1f ns/iteration)\n", heap_ns, heap_ns / 1000.0);
  printf("Heap is %.1fx slower\n", (double)heap_ns / stack_ns);
}
```

**Expected output:**
```
=== ALLOCATION BENCHMARK (1000 iterations) ===
Stack: 15000 ns (15.0 ns/iteration)
Heap:  850000 ns (850.0 ns/iteration)
Heap is 56.7x slower
```

**Analysis:**
- Stack: ~15 nanoseconds (negligible)
- Heap: ~850 nanoseconds (adds up in tight loops)
- **Heap is 50-100x slower!**

---

## Concept 2: Casey's PlatformMemoryBlock Pattern

### The Philosophy

**From Handmade Hero Day 25-26:**

> "Ask for all the memory you'll ever need at startup, then manage it yourself."

**Benefits:**
1. **Predictable:** No runtime surprises
2. **Fast:** No syscalls during frame
3. **Simple:** No fragmentation
4. **Debuggable:** You control layout

---

### Implementation

**In `base.h` (or similar):**
```c
typedef struct PlatformMemoryBlock {
  uint8_t *base;        // Start of memory
  uint64_t size;        // Total size
  uint64_t used;        // How much is used
  uint32_t flags;       // Permissions, etc.
} PlatformMemoryBlock;

#define MEGABYTES(n) ((n) * 1024ULL * 1024ULL)
#define GIGABYTES(n) ((n) * 1024ULL * 1024ULL * 1024ULL)
```

**At program startup:**
```c
int main() {
  // Allocate 64 MB once
  PlatformMemoryBlock game_memory = {};
  game_memory.size = MEGABYTES(64);
  game_memory.base = (uint8_t *)malloc(game_memory.size);
  game_memory.used = 0;
  
  if (!game_memory.base) {
    fprintf(stderr, "Failed to allocate game memory!\n");
    return 1;
  }
  
  // Now game code can use game_memory.base without malloc()
  GameInit(&game_memory);
  
  // Main loop never calls malloc()
  while (running) {
    GameUpdate(&game_memory);
  }
  
  // Cleanup once at end
  free(game_memory.base);
  return 0;
}
```

**In game code:**
```c
void GameInit(PlatformMemoryBlock *memory) {
  GameState *state = (GameState *)memory->base;
  memory->used += sizeof(GameState);
  
  // Audio buffer at offset
  state->audio_buffer = (int16_t *)(memory->base + memory->used);
  memory->used += 4800 * sizeof(int16_t);
  
  // More allocations...
}
```

**Result:** Zero `malloc()` calls after startup!

---

## Concept 3: Arena Allocators (Linear Allocators)

### What Is an Arena?

**Mental model:** Like a stack, but you control it.

```c
typedef struct MemoryArena {
  uint8_t *base;
  uint64_t size;
  uint64_t used;
} MemoryArena;

void *ArenaPush(MemoryArena *arena, uint64_t bytes) {
  assert(arena->used + bytes <= arena->size);
  
  void *result = arena->base + arena->used;
  arena->used += bytes;
  
  return result;
}
```

**Usage:**
```c
MemoryArena audio_arena = {};
audio_arena.base = malloc(MEGABYTES(1));
audio_arena.size = MEGABYTES(1);
audio_arena.used = 0;

// Allocate from arena (fast!)
int16_t *buffer1 = (int16_t *)ArenaPush(&audio_arena, 4800 * sizeof(int16_t));
int16_t *buffer2 = (int16_t *)ArenaPush(&audio_arena, 4800 * sizeof(int16_t));

// No individual free() ‚Äî just reset arena at frame end
void ArenaReset(MemoryArena *arena) {
  arena->used = 0;  // ‚Üê Instant! All memory "freed"
}
```

**Web Dev Analogy:**
```javascript
// malloc/free = individual object allocation
let obj1 = { data: new Array(1000) };
delete obj1;  // GC eventually runs

// Arena = buffer pool
const pool = new ArrayBuffer(1000000);
let view1 = new Uint8Array(pool, 0, 1000);
let view2 = new Uint8Array(pool, 1000, 1000);
// Reset by just setting offset = 0
```

---

## Exercise 2: Implement Simple Arena

**Add to your codebase:**

```c
// In base.h or audio.h:
typedef struct MemoryArena {
  uint8_t *base;
  uint64_t size;
  uint64_t used;
} MemoryArena;

void *ArenaPush(MemoryArena *arena, uint64_t bytes) {
  if (arena->used + bytes > arena->size) {
    fprintf(stderr, "Arena overflow! Used=%llu, Requested=%llu, Size=%llu\n",
            arena->used, bytes, arena->size);
    assert(!"Arena out of memory");
  }
  
  void *result = arena->base + arena->used;
  arena->used += bytes;
  
  return result;
}

void ArenaReset(MemoryArena *arena) {
  arena->used = 0;
}
```

**Use in audio code:**
```c
int main() {
  MemoryArena audio_arena = {};
  audio_arena.size = MEGABYTES(1);
  audio_arena.base = (uint8_t *)malloc(audio_arena.size);
  
  while (running) {
    // Allocate temporary buffers from arena
    int16_t *temp_buffer = ArenaPush(&audio_arena, 4800 * sizeof(int16_t));
    
    // Use temp_buffer...
    
    // At frame end, reset arena (free everything)
    ArenaReset(&audio_arena);
  }
  
  free(audio_arena.base);
}
```

**Test:** Run for 1 hour ‚Äî `arena.used` should never exceed initial allocation.

---

## Concept 4: Cache-Friendly Data Layout

### The Problem: Structure of Arrays (SoA) vs Array of Structures (AoS)

**Array of Structures (Bad for audio):**
```c
typedef struct AudioChannel {
  int16_t left;
  int16_t right;
  float pan;
  float volume;
} AudioChannel;

AudioChannel channels[100];  // 100 stereo channels

// Process left samples:
for (int i = 0; i < 100; i++) {
  ProcessSample(channels[i].left);  // Cache miss every iteration!
}
```

**Memory layout:**
```
[L0 R0 Pan0 Vol0][L1 R1 Pan1 Vol1][L2 R2 Pan2 Vol2]...
 ^cache line loads all 4 fields, but we only need L0
```

**Cache efficiency:** ~25% (wasted 3/4 of cache line)

---

**Structure of Arrays (Good for audio):**
```c
typedef struct AudioChannels {
  int16_t left[100];
  int16_t right[100];
  float pan[100];
  float volume[100];
} AudioChannels;

// Process left samples:
for (int i = 0; i < 100; i++) {
  ProcessSample(channels.left[i]);  // Sequential access, cache-friendly!
}
```

**Memory layout:**
```
[L0 L1 L2 L3 ...][R0 R1 R2 R3 ...][Pan0 Pan1 ...][Vol0 Vol1 ...]
 ^cache line loads 32 samples at once
```

**Cache efficiency:** ~100%

---

## Exercise 3: Measure Cache Impact

**Setup:**
```c
#define CHANNEL_COUNT 1000

// AoS (bad)
typedef struct AudioChannelAoS {
  int16_t left;
  int16_t right;
  float pan;
  float volume;
} AudioChannelAoS;

AudioChannelAoS channels_aos[CHANNEL_COUNT];

// SoA (good)
typedef struct AudioChannelsSoA {
  int16_t left[CHANNEL_COUNT];
  int16_t right[CHANNEL_COUNT];
  float pan[CHANNEL_COUNT];
  float volume[CHANNEL_COUNT];
} AudioChannelsSoA;

AudioChannelsSoA channels_soa;
```

**Benchmark:**
```c
// Test AoS
clock_gettime(CLOCK_MONOTONIC, &start);
for (int iter = 0; iter < 10000; iter++) {
  for (int i = 0; i < CHANNEL_COUNT; i++) {
    channels_aos[i].left = (int16_t)(i * 2);
  }
}
clock_gettime(CLOCK_MONOTONIC, &end);
int64_t aos_ns = ...;

// Test SoA
clock_gettime(CLOCK_MONOTONIC, &start);
for (int iter = 0; iter < 10000; iter++) {
  for (int i = 0; i < CHANNEL_COUNT; i++) {
    channels_soa.left[i] = (int16_t)(i * 2);
  }
}
clock_gettime(CLOCK_MONOTONIC, &end);
int64_t soa_ns = ...;

printf("AoS: %lld ns\nSoA: %lld ns\nSpeedup: %.2fx\n",
       aos_ns, soa_ns, (double)aos_ns / soa_ns);
```

**Expected result:**
```
AoS: 120000000 ns
SoA:  45000000 ns
Speedup: 2.67x
```

**SoA is 2-3x faster** due to better cache utilization!

---

## Concept 5: Memory Ownership Patterns

### Who Owns the Buffer?

**Your current pattern (from `backend.c`):**

```c
void LinuxMainLoop(...) {
  int16_t sample_buffer[4800];  // ‚Üê Platform owns this
  
  GameSoundOutput game_sound_output = {
    .samples = sample_buffer,   // ‚Üê Game borrows pointer
  };
  
  GameOutputSound(&game_sound_output);  // Game fills it
  
  LinuxFillSoundBuffer(...);            // Platform consumes it
  
  // sample_buffer dies here (stack cleanup)
}
```

**Ownership rules:**
1. **Platform allocates** (backend.c)
2. **Game borrows** (doesn't own, can't free)
3. **Platform deallocates** (automatic, end of frame)

**Why this works:**
- Clear lifetime (one frame)
- No double-free bugs
- No memory leaks

---

### Anti-Pattern: Transferring Ownership

**DON'T DO THIS:**
```c
int16_t *GameAllocateBuffer() {
  return (int16_t *)malloc(4800 * sizeof(int16_t));  // Who frees this?
}

void LinuxMainLoop(...) {
  int16_t *buffer = GameAllocateBuffer();
  // ... use buffer ...
  // BUG: Forgot to free! Memory leak!
}
```

**Problem:** Unclear who is responsible for `free()`.

---

## Self-Check Quiz

### Question 1
**Why avoid `malloc()` in the audio callback?**

A) It's too slow  
B) Non-deterministic time  
C) Can cause page faults  
D) All of the above  

<details>
<summary>Answer</summary>

**D) All of the above**

- Slow: 50-100x slower than stack allocation
- Non-deterministic: Can take 1¬µs or 1000¬µs
- Page faults: May trigger disk I/O (1000x slower than RAM)
</details>

---

### Question 2
**What is the cost of stack allocation?**

A) 1 CPU cycle (stack pointer adjustment)  
B) 100 CPU cycles (bounds checking)  
C) 1000 CPU cycles (kernel call)  
D) Depends on size  

<details>
<summary>Answer</summary>

**A) 1 CPU cycle**

```asm
sub rsp, 9600  ; ‚Üê One instruction
```

Stack allocation is just arithmetic on the stack pointer.
</details>

---

### Question 3
**In an arena allocator, how do you free all allocations?**

A) Call `free()` on each pointer  
B) Reset `arena.used = 0`  
C) Call `ArenaDestroy()`  
D) Use garbage collection  

<details>
<summary>Answer</summary>

**B) Reset `arena.used = 0`**

```c
void ArenaReset(MemoryArena *arena) {
  arena->used = 0;  // ‚Üê Instant! All memory "freed"
}
```

This is why arenas are fast ‚Äî no individual deallocation.
</details>

---

### Question 4
**Which layout is cache-friendly for processing 1000 left channel samples?**

A) `struct { int16_t left, right; } channels[1000];`  
B) `struct { int16_t left[1000]; int16_t right[1000]; }`  
C) Both are equal  
D) Depends on compiler  

<details>
<summary>Answer</summary>

**B) Structure of Arrays (SoA)**

Sequential access to `left[0], left[1], left[2]...` maximizes cache hits.

AoS jumps between `left` and `right` fields, wasting cache lines.
</details>

---

### Question 5
**In your audio code, who owns `sample_buffer`?**

A) Game code  
B) Platform code (backend.c)  
C) ALSA kernel  
D) Shared ownership  

<details>
<summary>Answer</summary>

**B) Platform code (backend.c)**

```c
int16_t sample_buffer[4800];  // ‚Üê Platform allocates
game_sound_output.samples = sample_buffer;  // ‚Üê Game borrows
```

Clear ownership = no memory bugs.
</details>

---

## Key Takeaways

### Casey's Memory Rules for Audio

1. **Allocate once at startup** ‚Äî Never during frame
2. **Use stack or arena** ‚Äî Not malloc/free
3. **Structure of Arrays** ‚Äî For cache efficiency
4. **Clear ownership** ‚Äî Who allocates, who frees
5. **Pre-calculate sizes** ‚Äî No dynamic allocations

---

### Allocation Speed Hierarchy

| Method | Cost | Use Case |
|--------|------|----------|
| **Stack** | 1 cycle | Known size, short lifetime |
| **Arena** | 5 cycles | Temporary per-frame data |
| **malloc/free** | 50-1000 cycles | Startup only |
| **mmap** | 10,000+ cycles | Large blocks (GBs) |

**For audio:** Stick to stack and arena!

---

### Memory Layout for Performance

```c
// Good (SoA):
struct {
  int16_t left_samples[4800];
  int16_t right_samples[4800];
} audio_buffer;

// Bad (AoS):
struct {
  int16_t left;
  int16_t right;
} audio_buffer[2400];
```

**SoA is 2-3x faster** in tight loops!

---

## Connection to Other Lessons

**Prerequisites:**
- L5.2: Sample Buffer Architecture (where buffers live)
- L2.1: Kernel vs Userspace (why syscalls are slow)

**Enables:**
- L8.3: Lock-Free Buffers (advanced arena patterns)
- L9.1: Mixer Architecture (multi-buffer management)
- L8.2: SIMD Optimization (cache-aligned data)

---

## Final Exercise: Audit Your Memory

**Check your codebase for:**

1. **Any `malloc()` in audio path?**
   ```bash
   grep -n "malloc" backend.c audio.c handmade.c
   ```
   If found ‚Üí Replace with stack or arena

2. **Any AoS patterns?**
   ```c
   struct { int16_t left; int16_t right; } data[1000];
   ```
   If found ‚Üí Convert to SoA

3. **Unclear ownership?**
   ```c
   int16_t *buffer = SomeFunction();  // Who frees this?
   ```
   If found ‚Üí Add comments or refactor

**Goal:** Zero `malloc()` calls in audio loop!

---

## Completion: Unit 5 Done! üéâ

**You've learned:**
- ‚úÖ Platform API design
- ‚úÖ Two-buffer architecture
- ‚úÖ Sine wave generation
- ‚úÖ Panning & volume control
- ‚úÖ Casey's memory philosophy

**Competence level:** 5/6 (Synthesis)  
You can now **design and implement** audio systems from scratch!

---

## Next Unit Preview

**Unit 6: Porting & Alternative Backends**
- Compare ALSA, PulseAudio, Web Audio
- Port to different platforms
- Analyze architectural tradeoffs
- Real debugging war stories

**You'll port your ALSA code to Web Audio API** ‚Äî running in a browser!

---

**Estimated Completion Time:** 75-90 minutes  
**Difficulty:** ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ (Advanced)  
**Competence Level Achieved:** 5/6 (Synthesis)

---

**Progress:** Unit 5 is 100% COMPLETE! Moving to Unit 6...

