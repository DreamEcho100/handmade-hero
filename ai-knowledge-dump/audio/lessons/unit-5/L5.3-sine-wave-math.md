# L5.3: Sine Wave Math - Pure Tone Generation

**Unit 5: Advanced Audio Patterns**  
**Estimated Time:** 75-90 minutes  
**Competence Target:** Level 4 (Analysis - debug phase discontinuities)

---

## Learning Objectives

By the end of this lesson, you will:

1. **Derive** the sine wave formula from first principles
2. **Implement** pure tone generation in your audio callback
3. **Explain** why `running_sample_index` must persist across frames
4. **Debug** audio clicks caused by phase discontinuities
5. **Understand** the relationship between frequency, sample rate, and time
6. **Compare** integer vs floating-point audio math

---

## The Mystery: Why Does This Code Work?

### Your Code (from handmade.c or similar)

```c
static int32_t running_sample_index = 0;

void GameOutputSound(GameSoundOutput *sound_buffer) {
  int16_t *samples = sound_buffer->samples;
  int32_t samples_per_second = sound_buffer->samples_per_second;
  
  for (int32_t sample_index = 0; 
       sample_index < sound_buffer->sample_count; 
       sample_index++) {
    
    float t = (float)running_sample_index / samples_per_second;
    float sine_value = sinf(2.0f * PI * 256.0f * t);  // 256 Hz tone
    
    int16_t sample_value = (int16_t)(sine_value * 3000);
    
    *samples++ = sample_value;  // Left channel
    *samples++ = sample_value;  // Right channel
    
    running_sample_index++;
  }
}
```

**Questions you should be asking:**
1. Why `2.0f * PI`?
2. Why divide by `samples_per_second`?
3. Why is `running_sample_index` static?
4. What happens if I reset it to 0 every frame?

---

## Concept 1: The Sine Wave Formula

### From Physics to Code

**Physics definition of a sine wave:**
```
y(t) = A × sin(2π × f × t)
```

Where:
- `y(t)` = amplitude at time `t`
- `A` = maximum amplitude (volume)
- `f` = frequency (Hz, cycles per second)
- `t` = time (seconds)
- `2π` = one complete rotation in radians (360°)

**Why `2π`?**
- `sin()` expects radians, not degrees
- One cycle = 360° = 2π radians
- `2π × f × t` = "how many radians we've rotated at time t"

---

### Mapping to Audio

**Convert to discrete samples:**

```c
// Time for sample N:
float t = (float)N / samples_per_second;

// Example: N = 480, sample_rate = 48000 Hz
// t = 480 / 48000 = 0.01 seconds = 10 milliseconds

// Frequency: 256 Hz (middle C is 261.63 Hz)
float f = 256.0f;

// Angle (radians):
float angle = 2.0f * PI * f * t;
//          = 2 * 3.14159 * 256 * 0.01
//          = 16.08 radians
//          ≈ 2.56 rotations

// Amplitude:
float y = sinf(angle);
```

**Visual representation:**
```
Time (ms):    0    10    20    30    40 ...
Sample:       0   480   960  1440  1920 ...
Angle (rad):  0  16.08 32.17 48.25 64.34 ...
sin(angle):   0   -0.9   0.8  -0.5   0.2 ...
```

---

## Concept 2: Running Sample Index

### The Critical Variable

**Why this variable exists:**
```c
static int32_t running_sample_index = 0;  // Persists across frames!
```

**What happens if you reset it every frame:**
```c
// BROKEN CODE:
void GameOutputSound(GameSoundOutput *sound_buffer) {
  int32_t running_sample_index = 0;  // ← Resets to 0 every frame!
  
  for (...) {
    float t = running_sample_index / samples_per_second;
    // t will ALWAYS be 0-16ms, restarting every frame
    // This causes phase discontinuities → CLICKS!
  }
}
```

**Problem:**
```
Frame 1: samples 0-799    → time 0.000 to 0.0166 sec → sine starts at 0°
Frame 2: samples 0-799    → time 0.000 to 0.0166 sec → sine JUMPS back to 0°
                                                         ^^^^
                                                         CLICK!
```

**Correct behavior (static variable):**
```
Frame 1: samples 0-799     → time 0.000 to 0.0166 sec → sine 0° to 23°
Frame 2: samples 800-1599  → time 0.0166 to 0.033 sec → sine 23° to 46°
                                                          ^^^^
                                                          Continuous!
```

---

### Web Dev Analogy

**Wrong (resets every request):**
```javascript
app.get('/counter', (req, res) => {
  let count = 0;  // Resets to 0 every request!
  count++;
  res.send({ count });  // Always returns 1
});
```

**Correct (persists across requests):**
```javascript
let count = 0;  // Module-level variable

app.get('/counter', (req, res) => {
  count++;
  res.send({ count });  // Returns 1, 2, 3, ...
});
```

**Audio equivalent:**
- `running_sample_index` = session counter
- Each frame = HTTP request
- Sine wave phase = state that must persist

---

## Exercise 1: Break the Phase Continuity

**Goal:** Hear what phase discontinuity sounds like.

**Modify your game code:**
```c
void GameOutputSound(GameSoundOutput *sound_buffer) {
  // DELIBERATELY BROKEN:
  int32_t running_sample_index = 0;  // Remove 'static'
  
  for (int32_t i = 0; i < sound_buffer->sample_count; i++) {
    float t = (float)(running_sample_index + i) / sound_buffer->samples_per_second;
    float value = sinf(2.0f * PI * 256.0f * t);
    
    int16_t sample = (int16_t)(value * 3000);
    sound_buffer->samples[i * 2 + 0] = sample;
    sound_buffer->samples[i * 2 + 1] = sample;
  }
  // running_sample_index NOT incremented!
}
```

**Run and listen:**
- You should hear a 256 Hz tone with **loud clicks** every 16ms (60 FPS)

**Fix it:**
```c
static int32_t running_sample_index = 0;  // Add back 'static'

// At end of function:
running_sample_index += sound_buffer->sample_count;
```

**Result:** Clicks disappear!

---

## Exercise 2: Visualize Phase

**Add debug output (every 60 frames = 1 second):**

```c
static int32_t running_sample_index = 0;
static int32_t debug_frame_count = 0;

void GameOutputSound(GameSoundOutput *sound_buffer) {
  debug_frame_count++;
  
  if (debug_frame_count % 60 == 0) {
    float time_seconds = (float)running_sample_index / sound_buffer->samples_per_second;
    float phase_rotations = (256.0f * time_seconds);  // 256 Hz
    
    printf("Time: %.2fs | Sample: %d | Rotations: %.1f\n",
           time_seconds, running_sample_index, phase_rotations);
  }
  
  // ... rest of sine generation ...
  
  running_sample_index += sound_buffer->sample_count;
}
```

**Expected output:**
```
Time: 1.00s | Sample: 48000 | Rotations: 256.0
Time: 2.00s | Sample: 96000 | Rotations: 512.0
Time: 3.00s | Sample: 144000 | Rotations: 768.0
```

**Analysis:**
- At 256 Hz, the sine wave completes 256 rotations per second
- `running_sample_index` counts total samples since program start
- Never resets (unless program restarts)

---

## Concept 3: Amplitude Scaling

### Float to Int16 Conversion

**Sine wave output:**
```c
float sine_value = sinf(angle);  // Range: -1.0 to +1.0
```

**Audio hardware expects:**
```c
int16_t sample;  // Range: -32768 to +32767
```

**Scaling factor:**
```c
int16_t sample = (int16_t)(sine_value * volume);
```

Where `volume` can be:
- `32767` — Full volume (LOUD, may clip)
- `16000` — Half volume (safe)
- `3000` — Quiet (good for testing)

---

### Clipping Detection

**Add to your audio code:**
```c
float sine_value = sinf(2.0f * PI * tone_hz * t);
float scaled = sine_value * 30000.0f;  // Intentionally too loud

if (scaled > 32767.0f || scaled < -32768.0f) {
  printf("CLIP! scaled=%.1f\n", scaled);
  scaled = (scaled > 0) ? 32767.0f : -32768.0f;  // Hard limit
}

int16_t sample = (int16_t)scaled;
```

**Expected output (if volume too high):**
```
CLIP! scaled=33000.0
CLIP! scaled=33500.0
...
```

**Result:** Audio sounds distorted (square wave-like).

**Fix:** Lower the volume factor.

---

## Exercise 3: Multi-Frequency Tone

**Goal:** Play two frequencies at once (chord).

**Code:**
```c
static int32_t running_sample_index = 0;

void GameOutputSound(GameSoundOutput *sound_buffer) {
  int32_t sps = sound_buffer->samples_per_second;
  
  for (int32_t i = 0; i < sound_buffer->sample_count; i++) {
    float t = (float)(running_sample_index + i) / sps;
    
    // Two tones: 256 Hz + 320 Hz (major third interval)
    float tone1 = sinf(2.0f * PI * 256.0f * t);
    float tone2 = sinf(2.0f * PI * 320.0f * t);
    
    float mixed = (tone1 + tone2) / 2.0f;  // Average to prevent clipping
    
    int16_t sample = (int16_t)(mixed * 3000);
    
    sound_buffer->samples[i * 2 + 0] = sample;  // Left
    sound_buffer->samples[i * 2 + 1] = sample;  // Right
  }
  
  running_sample_index += sound_buffer->sample_count;
}
```

**Listen:**
- You should hear a harmonious chord (not a single tone)

**Experiment:**
- Try `440 Hz + 880 Hz` (octave)
- Try `440 Hz + 441 Hz` (beating effect)

---

## Concept 4: Integer vs Float Math

### Your Current Approach (Float)

```c
float t = (float)running_sample_index / samples_per_second;
float value = sinf(2.0f * PI * frequency * t);
```

**Pros:**
- Easy to understand
- Works for any frequency

**Cons:**
- Float precision loss after ~16 million samples (5.8 minutes @ 48 kHz)
- `sinf()` is slow (10-20 CPU cycles)

---

### Casey's Approach (Integer Table Lookup)

**Pre-compute sine table:**
```c
#define SINE_TABLE_SIZE 256
static int16_t sine_table[SINE_TABLE_SIZE];

// Initialize once:
void InitSineTable() {
  for (int i = 0; i < SINE_TABLE_SIZE; i++) {
    float angle = (float)i / SINE_TABLE_SIZE * 2.0f * PI;
    sine_table[i] = (int16_t)(sinf(angle) * 3000);
  }
}
```

**Use in audio loop:**
```c
static uint32_t phase = 0;  // 32-bit phase accumulator

void GameOutputSound(GameSoundOutput *sound_buffer) {
  uint32_t phase_increment = (uint32_t)((256.0f / 48000.0f) * 4294967296.0f);
  //                                      ^freq  ^sample_rate  ^2^32
  
  for (int32_t i = 0; i < sound_buffer->sample_count; i++) {
    uint8_t table_index = (phase >> 24);  // Top 8 bits
    int16_t sample = sine_table[table_index];
    
    sound_buffer->samples[i * 2 + 0] = sample;
    sound_buffer->samples[i * 2 + 1] = sample;
    
    phase += phase_increment;  // Wraps automatically at 2^32
  }
}
```

**Pros:**
- No `sinf()` call (just array lookup)
- No precision loss (integer wraps perfectly)
- 10x faster

**Cons:**
- Harder to understand
- Fixed table size (lower quality)

**For learning:** Stick with float until Unit 8 (Performance).

---

## Exercise 4: Frequency Sweep

**Goal:** Play a tone that goes from 200 Hz to 800 Hz over 3 seconds.

**Code:**
```c
static int32_t running_sample_index = 0;
static float current_frequency = 200.0f;

void GameOutputSound(GameSoundOutput *sound_buffer) {
  int32_t sps = sound_buffer->samples_per_second;
  float dt = 1.0f / 60.0f;  // Frame time (16.6 ms @ 60 FPS)
  
  // Increase frequency by 200 Hz per second
  current_frequency += 200.0f * dt;
  if (current_frequency > 800.0f) {
    current_frequency = 200.0f;  // Reset
  }
  
  for (int32_t i = 0; i < sound_buffer->sample_count; i++) {
    float t = (float)(running_sample_index + i) / sps;
    float value = sinf(2.0f * PI * current_frequency * t);
    
    int16_t sample = (int16_t)(value * 3000);
    sound_buffer->samples[i * 2 + 0] = sample;
    sound_buffer->samples[i * 2 + 1] = sample;
  }
  
  running_sample_index += sound_buffer->sample_count;
}
```

**Expected result:**
- Tone sweeps upward, then resets
- **BUT:** You'll hear clicks when frequency changes!

**Why clicks?**
- Frequency changes abruptly → phase discontinuity
- Need "phase accumulator" pattern (advanced, not covered here)

---

## Self-Check Quiz

### Question 1
**What does `2.0f * PI * frequency * t` represent?**

A) The volume of the sine wave  
B) The angle (in radians) at time `t`  
C) The sample rate  
D) The number of channels  

<details>
<summary>Answer</summary>

**B) The angle (in radians) at time `t`**

```c
float angle = 2.0f * PI * frequency * t;
float amplitude = sinf(angle);  // ← sin() takes angle in radians
```

This is the "how far around the circle have we rotated" value.
</details>

---

### Question 2
**At 48000 Hz sample rate, how many samples represent 1 second?**

A) 480  
B) 4800  
C) 48000  
D) 480000  

<details>
<summary>Answer</summary>

**C) 48000**

"48000 Hz" means 48000 samples per second. That's the definition of sample rate.

```c
float t = (float)sample_number / 48000.0f;  // Convert sample to seconds
```
</details>

---

### Question 3
**Why must `running_sample_index` be static?**

A) To save memory  
B) To make the code faster  
C) To preserve phase across frames (prevent clicks)  
D) To prevent buffer overruns  

<details>
<summary>Answer</summary>

**C) To preserve phase across frames**

If you reset it every frame, the sine wave jumps back to the start → discontinuity → click!

```c
static int32_t running_sample_index = 0;  // Persists across function calls
```
</details>

---

### Question 4
**If `sine_value` is `-0.5` and volume is `10000`, what is the output sample?**

A) -5000  
B) -0.5  
C) -50  
D) -500  

<details>
<summary>Answer</summary>

**A) -5000**

```c
int16_t sample = (int16_t)(sine_value * volume);
                        = (int16_t)(-0.5 * 10000);
                        = (int16_t)(-5000.0);
                        = -5000
```
</details>

---

### Question 5
**What causes audio clipping?**

A) `running_sample_index` overflow  
B) Sample value exceeds -32768 to +32767 range  
C) Frequency too high  
D) Buffer underrun  

<details>
<summary>Answer</summary>

**B) Sample value exceeds -32768 to +32767 range**

```c
float scaled = sine_value * 40000.0f;  // Too loud!
int16_t sample = (int16_t)scaled;      // Wraps around (clipping)
```

**Prevention:**
```c
if (scaled > 32767.0f) scaled = 32767.0f;
if (scaled < -32768.0f) scaled = -32768.0f;
```
</details>

---

## Key Takeaways

### The Sine Wave Formula (Audio Edition)

```c
// 1. Calculate time for this sample
float t = (float)sample_number / samples_per_second;

// 2. Calculate angle (radians)
float angle = 2.0f * PI * frequency * t;

// 3. Calculate amplitude (-1.0 to +1.0)
float amplitude = sinf(angle);

// 4. Scale to int16_t range
int16_t sample = (int16_t)(amplitude * volume);
```

---

### Critical Variables

| Variable | Type | Purpose | Lifetime |
|----------|------|---------|----------|
| `running_sample_index` | `static int32_t` | Phase continuity | Program duration |
| `t` | `float` | Time in seconds | Per-sample |
| `angle` | `float` | Radians (0 to 2π repeats) | Per-sample |
| `amplitude` | `float` | Sine output (-1 to +1) | Per-sample |

---

### Common Mistakes

1. **Forgetting `static`** → Clicks every frame
2. **Not incrementing `running_sample_index`** → Frozen tone
3. **Volume too high** → Clipping distortion
4. **Using degrees instead of radians** → Wrong formula
5. **Resetting phase on frequency change** → Clicks

---

## Connection to Other Lessons

**Prerequisites:**
- L5.2: Sample Buffer Architecture (where samples go)
- L2.5: Sample Formats (why int16_t)

**Enables:**
- L5.4: Panning & Volume (stereo manipulation)
- L9.2: WAV Loading (real audio vs synthesized)
- L8.2: SIMD Optimization (vectorize sine generation)

---

## Next Lesson Preview

**L5.4: Panning & Volume**
- Stereo balance (left/right channel mixing)
- Constant-power panning law
- Volume ramping (prevent clicks)
- Circular panning animation

**Teaser:**
```c
// Full left: left=1.0, right=0.0
// Center: left=0.707, right=0.707 (not 0.5!)
// Full right: left=0.0, right=1.0
```

You'll learn why center is 0.707, not 0.5!

---

**Estimated Completion Time:** 75-90 minutes  
**Difficulty:** ⭐⭐⭐☆☆ (Medium)  
**Competence Level Achieved:** 4/6 (Analysis)

---

**Progress:** Unit 5 is 60% complete! (3/5 lessons done)

