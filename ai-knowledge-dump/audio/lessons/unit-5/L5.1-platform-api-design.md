# L5.1: Platform API Design - Casey's Abstraction Philosophy

**Unit:** 5 - Advanced Audio Patterns & Cross-Platform Abstractions  
**Duration:** 75-90 minutes  
**Prerequisites:** L1.4 (Macro Pattern), Unit 4 complete  
**Connects to:** Unit 6 (Porting), L5.5 (Memory Management)

---

## Learning Objectives

1. Understand platform layer vs game code separation
2. Identify the platform API boundary in your code
3. Explain why game code never sees ALSA types
4. Design portable audio interfaces
5. Apply Casey's abstraction principles

---

## Casey's Philosophy: Platform Layer

**Core principle:** Game code should be **platform-agnostic**.

```
Game Code (platform-independent)
    ↕ 
Platform API (stable interface)
    ↕
Platform Implementation (Linux/Windows/macOS specific)
```

### The Contract

**Game sees:**
```c
typedef struct {
  int samples_per_second;
  int tone_hz;
  int tone_volume;
  // ... no ALSA types!
} GameSoundOutput;
```

**Platform implements:**
```c
void linux_fill_sound_buffer(GameSoundOutput *sound_output) {
  // ALSA magic happens here
  // Game code never knows!
}
```

---

## Your API Boundary

### Game-Facing Interface (`game.h`)

```c
typedef struct {
  int samples_per_second;      // 48000 Hz
  int tone_hz;                 // Frequency to play
  int tone_volume;             // 0-15000
  int pan_position;            // -100 to +100
  int game_update_hz;          // 30, 60, 120 FPS
  int latency_sample_count;    // Buffer size in samples
  
  bool is_initialized;         // Did audio setup succeed?
} GameSoundOutput;
```

**Notice what's NOT here:**
- ❌ `snd_pcm_t *handle`
- ❌ `ALSA_*` types
- ❌ `dlopen` handles
- ❌ Platform-specific anything

### Platform Implementation (`audio.h`, `audio.c`)

```c
// Platform-specific state (hidden from game)
typedef struct {
  snd_pcm_t *handle;           // ALSA handle
  void *alsa_library;          // dlopen handle
  PlatformMemoryBlock sample_buffer;
  // ...
} LinuxSoundOutput;

// Platform function (called by backend, not game)
void linux_fill_sound_buffer(GameSoundOutput *sound_output);
```

---

## Exercise 1: Trace the Boundary

**Goal:** Follow a sound parameter from game to ALSA

### Step 1: Game Updates Frequency

```c
// In game.c (game code):
void game_update_and_render(...) {
  sound_output->tone_hz = 440;  // Set to A440
}
```

### Step 2: Platform Reads Frequency

```c
// In audio.c (platform code):
void linux_fill_sound_buffer(GameSoundOutput *sound_output) {
  int frequency = sound_output->tone_hz;  // Read game's request
  
  // Generate samples at that frequency
  for (int i = 0; i < sample_count; i++) {
    float sine_value = sinf(2.0f * M_PI * frequency * t);
    // ...
  }
}
```

### Step 3: Platform Writes to ALSA

```c
// Still in audio.c:
SndPcmWritei(handle, samples, frames_to_write);  // ALSA-specific!
```

**The boundary:**
```
game.c: tone_hz = 440
   ↓ (via GameSoundOutput pointer)
audio.c: read tone_hz, generate samples
   ↓ (via ALSA calls)
kernel: play audio
```

---

## Why This Matters: Porting Example

### Scenario: Port to PulseAudio

**With bad design** (game knows about ALSA):
```c
// ❌ BAD: Game code with ALSA types
void game_update_and_render(snd_pcm_t *alsa_handle, ...) {
  snd_pcm_writei(alsa_handle, samples, count);  // OOPS!
}
```

**Problem:** Now you have to rewrite game code for PulseAudio!

**With good design** (your code):
```c
// ✅ GOOD: Game code platform-agnostic
void game_update_and_render(GameSoundOutput *sound) {
  sound->tone_hz = 440;  // Works on ANY platform!
}
```

**To port:** Only replace `audio.c` + `audio.h`:
- `audio_alsa.c` → `audio_pulse.c`
- Game code unchanged!

---

## Exercise 2: Design a Windows Port

**Goal:** Plan DirectSound implementation using same API

### Current (Linux):

```c
// audio_alsa.c
void linux_fill_sound_buffer(GameSoundOutput *sound) {
  // ALSA: snd_pcm_writei()
}
```

### Future (Windows):

```c
// audio_dsound.c
void win32_fill_sound_buffer(GameSoundOutput *sound) {
  // DirectSound: IDirectSoundBuffer->Write()
}
```

### What Stays the Same?

```c
// game.c (UNCHANGED)
sound_output->tone_hz = 440;
sound_output->tone_volume = 3000;
```

### What Changes?

| Component | Linux (ALSA) | Windows (DirectSound) |
|-----------|--------------|----------------------|
| **Library loading** | `dlopen("libasound.so.2")` | `LoadLibrary("dsound.dll")` |
| **Symbol loading** | `dlsym(lib, "snd_pcm_open")` | `GetProcAddress(dll, "DirectSoundCreate")` |
| **Device open** | `snd_pcm_open()` | `DirectSoundCreate()` |
| **Buffer write** | `snd_pcm_writei()` | `Lock() + memcpy() + Unlock()` |
| **Latency query** | `snd_pcm_delay()` | `GetCurrentPosition()` |

**But `GameSoundOutput` interface?** → **Identical!**

---

## Anti-Pattern: Leaky Abstractions

### Bad Example 1: Exposing Internal State

```c
// ❌ DON'T DO THIS:
typedef struct {
  int samples_per_second;
  snd_pcm_t *alsa_handle;  // ← LEAK! Game shouldn't see this
} GameSoundOutput;
```

**Why bad?** Windows port would need different struct.

### Bad Example 2: Platform-Specific Flags

```c
// ❌ DON'T DO THIS:
typedef struct {
  int samples_per_second;
  bool use_alsa_dmix;      // ← LEAK! Linux-specific
  int alsa_buffer_periods;  // ← LEAK!
} GameSoundOutput;
```

**Why bad?** macOS port has no concept of "dmix".

### Good Example: Your Code

```c
// ✅ YOUR CODE:
typedef struct {
  int samples_per_second;     // ← Universal concept
  int latency_sample_count;   // ← Universal (buffers everywhere)
  bool is_initialized;        // ← Universal (did setup work?)
} GameSoundOutput;
```

**Why good?** Every platform has these concepts!

---

## Exercise 3: Refactor a Leaky API

**Scenario:** Someone added ALSA stuff to `GameSoundOutput`:

```c
// ❌ LEAKY VERSION:
typedef struct {
  int samples_per_second;
  snd_pcm_t *handle;           // LEAK!
  int alsa_buffer_frames;      // LEAK!
  bool use_pulseaudio_plugin;  // LEAK!
} GameSoundOutput;
```

**Your task:** Refactor to be platform-agnostic.

**Solution:**

```c
// ✅ CLEAN VERSION:
typedef struct {
  int samples_per_second;
  int latency_sample_count;    // Generic: "how much buffer"
  void *platform_handle;       // Opaque pointer (if needed)
} GameSoundOutput;
```

**Move platform stuff to `LinuxSoundOutput`:**
```c
typedef struct {
  snd_pcm_t *handle;           // Linux-specific
  void *alsa_library;
  // ... other platform details
} LinuxSoundOutput;
```

---

## The Platform File Structure

**Your current organization:**

```
project/src/
├── game.h            ← Platform-independent interface
├── game.c            ← Platform-independent logic
├── platform/
│   ├── x11/
│   │   ├── audio.h   ← Linux types (snd_pcm_t, etc)
│   │   ├── audio.c   ← ALSA implementation
│   │   ├── backend.c ← X11 main loop
│   │   └── ...
│   ├── win32/        ← Future: Windows port
│   │   ├── audio.h
│   │   ├── audio.c   ← DirectSound implementation
│   │   └── ...
│   └── macos/        ← Future: macOS port
│       ├── audio.h
│       ├── audio.c   ← CoreAudio implementation
│       └── ...
```

**Key insight:** Only files in `platform/x11/` know about ALSA!

---

## Casey's Abstraction Checklist

Before adding something to `GameSoundOutput`, ask:

- [ ] Does every platform have this concept?
- [ ] Can I explain it without platform names (ALSA/DirectSound/etc)?
- [ ] Would a web browser audio port understand this?
- [ ] Is it a **what** (concept) not a **how** (implementation)?

**Examples:**

| Addition | Universal? | Add it? |
|----------|-----------|---------|
| `int tone_hz` | ✅ Yes (all platforms have frequency) | ✅ YES |
| `int latency_ms` | ✅ Yes (all have buffers) | ✅ YES |
| `snd_pcm_format_t format` | ❌ No (ALSA-specific type) | ❌ NO |
| `bool use_dmix` | ❌ No (Linux plugin) | ❌ NO |
| `void *platform_state` | ⚠️ Maybe (opaque handle) | ⚠️ CONSIDER |

---

## Key Takeaways

1. **Game code is platform-agnostic** (no ALSA types in game.h)
2. **Platform implements standard interface** (linux_fill_sound_buffer)
3. **GameSoundOutput only has universal concepts** (frequency, volume, latency)
4. **Platform-specific types live in audio.h** (not game.h)
5. **Porting = replace audio.c only** (game.c unchanged)

---

## Self-Check Quiz

1. **Q:** Where is the platform API boundary?  
   **A:** `GameSoundOutput` struct in `game.h`

2. **Q:** Should `snd_pcm_t *handle` be in `GameSoundOutput`?  
   **A:** No — it's ALSA-specific, belongs in `LinuxSoundOutput`

3. **Q:** What changes when porting to Windows?  
   **A:** Only `audio.c` and `audio.h` (platform layer)

4. **Q:** What stays the same when porting?  
   **A:** `game.c`, `game.h`, `GameSoundOutput` interface

5. **Q:** Why is `latency_sample_count` a good API member?  
   **A:** It's a universal concept (all platforms buffer audio)

---

## Next Lesson

**L5.2: Sample Buffer vs Secondary Buffer** — Understand the two-buffer architecture and memory ownership.

---

**Time to complete:** 75-90 minutes  
**Code modified:** None (pure design study)  
**Competence level achieved:** Level 5 (Can design portable APIs)
