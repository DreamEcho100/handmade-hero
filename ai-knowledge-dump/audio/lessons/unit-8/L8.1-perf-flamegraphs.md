# L8.1: perf & Flamegraphs - Finding Audio Bottlenecks

**Unit 8: Performance Profiling & Optimization**  
**Estimated Time:** 75-90 minutes  
**Competence Target:** Level 5 (Synthesis - can profile systematically)

---

## Learning Objectives

By the end of this lesson, you will:

1. **Use** Linux `perf` tool to record performance data
2. **Generate** flamegraphs to visualize hotspots
3. **Identify** audio callback bottlenecks
4. **Measure** CPU cache miss rates
5. **Optimize** based on profiling data
6. **Understand** sampling vs instrumentation profiling

---

## The Mystery: Which Code is Slow?

### Your Timing Data

```c
Total audio callback: 800 Î¼s
  - ??? fills most of it
```

**Problem:** You don't know WHERE those 800 microseconds go!

---

## Concept 1: Sampling Profiler (perf)

### How perf Works

**Sampling profiler:**
```
Every 1ms (1000 Hz), kernel interrupts your program:
  - Which function is running?
  - What's the call stack?
  - Record to perf.data file

After 60 seconds @ 1000 Hz = 60,000 samples
```

**Analysis:** "Function X appeared in 30,000 samples = 50% of CPU time"

---

### Install perf

```bash
# Ubuntu/Debian
sudo apt install linux-tools-common linux-tools-generic linux-tools-`uname -r`

# Test
perf --version
```

---

## Exercise 1: Your First Flamegraph

### Step 1: Record Performance Data

```bash
# Run game with perf (requires sudo for kernel access)
sudo perf record -F 999 -g ./game

# -F 999: Sample at 999 Hz (not 1000 to avoid aliasing)
# -g: Record call graphs (stack traces)

# Let it run for 30-60 seconds, then Ctrl+C

# Output: perf.data file created
ls -lh perf.data
# -rw------- 1 root root 15M Jan 14 12:34 perf.data
```

---

### Step 2: View Text Report

```bash
sudo perf report
```

**Output (interactive TUI):**
```
Samples: 45K of event 'cycles:u', Event count (approx.): 38000000000
Overhead  Command  Shared Object       Symbol
  45.23%  game     game                [.] sinf
  12.34%  game     libasound.so.2      [.] snd_pcm_writei
   8.76%  game     game                [.] GameOutputSound
   3.21%  game     libc.so.6           [.] __memcpy_avx_unaligned
   ...
```

**Interpretation:** Your `sinf()` call takes 45% of CPU time!

---

### Step 3: Generate Flamegraph

**Install FlameGraph tools:**
```bash
git clone https://github.com/brendangregg/FlameGraph.git
```

**Generate SVG:**
```bash
sudo perf script | FlameGraph/stackcollapse-perf.pl | FlameGraph/flamegraph.pl > flame.svg

# Open in browser
firefox flame.svg
```

**Flamegraph:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚             main                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚        LinuxMainLoop                          â”‚ â”‚
â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚ â”‚
â”‚  â”‚ â”‚       GameOutputSound                      â”‚â”‚ â”‚
â”‚  â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚â”‚ â”‚
â”‚  â”‚ â”‚ â”‚   sinf â† 45% of time!                  â”‚â”‚â”‚ â”‚
â”‚  â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚â”‚ â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Width = CPU time**, **Color = random (for visualization)**

---

## Exercise 2: Optimize Based on Profiling

### Hotspot Found: sinf()

**Your current code:**
```c
void GameOutputSound(...) {
  for (int i = 0; i < sample_count; i++) {
    float t = (float)running_sample_index / samples_per_second;
    float value = sinf(2.0f * M_PI * 440.0f * t);  // â† 45% CPU!
  }
}
```

---

### Optimization 1: Pre-calculate Constants

```c
void GameOutputSound(...) {
  static const float phase_increment = 2.0f * M_PI * 440.0f / samples_per_second;
  static float phase = 0.0f;
  
  for (int i = 0; i < sample_count; i++) {
    float value = sinf(phase);  // Still calls sinf, but less math
    phase += phase_increment;
    if (phase >= 2.0f * M_PI) phase -= 2.0f * M_PI;
  }
}
```

**Re-profile:**
```bash
sudo perf record -F 999 -g ./game
# sinf now 40% (was 45%) - minor improvement
```

---

### Optimization 2: Lookup Table

```c
#define SIN_TABLE_SIZE 1024
static float sin_table[SIN_TABLE_SIZE];

void InitSineTable() {
  for (int i = 0; i < SIN_TABLE_SIZE; i++) {
    sin_table[i] = sinf(2.0f * M_PI * i / SIN_TABLE_SIZE);
  }
}

void GameOutputSound(...) {
  static float phase = 0.0f;
  const float phase_increment = 440.0f / samples_per_second;
  
  for (int i = 0; i < sample_count; i++) {
    int index = (int)(phase * SIN_TABLE_SIZE) % SIN_TABLE_SIZE;
    float value = sin_table[index];  // Table lookup!
    
    phase += phase_increment;
    if (phase >= 1.0f) phase -= 1.0f;
  }
}
```

**Re-profile:**
```bash
sudo perf record -F 999 -g ./game
# sinf now 0%! GameOutputSound dropped from 8% to 2%!
```

**5x speedup!** ğŸš€

---

## Concept 2: Cache Performance Analysis

### Measure Cache Misses

```bash
# Record cache events
sudo perf stat -e cache-references,cache-misses ./game

# Run for 30 seconds, then Ctrl+C

# Output:
#  45,234,567  cache-references
#   2,123,456  cache-misses  (4.69% of all cache refs)
#
# Performance counter stats for './game':
# 4.69% cache miss rate
```

---

### Good vs Bad Cache Miss Rates

| Rate | Quality | Likely Cause |
|------|---------|--------------|
| **< 1%** | Excellent | Cache-friendly code |
| **1-5%** | Good | Typical for most code |
| **5-10%** | Acceptable | Some pointer chasing |
| **> 10%** | Poor | Random access, large arrays |

---

### Improve Cache Performance

**Problem code (10% miss rate):**
```c
// Array of Structures (AoS)
struct AudioChannel {
  float left;
  float right;
  float pan;
  float volume;
} channels[100];

for (int i = 0; i < 100; i++) {
  ProcessChannel(&channels[i].left);  // Cache miss every iteration
}
```

**Optimized (2% miss rate):**
```c
// Structure of Arrays (SoA)
struct {
  float left[100];
  float right[100];
  float pan[100];
  float volume[100];
} channels;

for (int i = 0; i < 100; i++) {
  ProcessChannel(&channels.left[i]);  // Sequential = cache-friendly
}
```

---

## Concept 3: Annotated Source Code

### View Hotspots Line-by-Line

```bash
sudo perf annotate
```

**Output:**
```
Percentâ”‚    Source code & Disassembly of game
â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  0.00 â”‚  push   %rbp
  0.00 â”‚  mov    %rsp,%rbp
 45.23 â”‚  call   sinf@plt     â† 45% HERE!
  8.76 â”‚  movss  %xmm0,(%rax)
  0.00 â”‚  pop    %rbp
  0.00 â”‚  ret
```

---

## Exercise 3: Profile Audio Thread Only

### Problem: Profiling Entire Process

```bash
perf record ./game
# Records ALL threads (render, audio, input)
```

---

### Solution: Filter by Thread

```bash
# Step 1: Find audio thread ID
ps -eLf | grep game
# UID   PID  PPID  LWP  ... CMD
# user  1234 ...   1234 ... ./game  â† Main thread
# user  1234 ...   1235 ... ./game  â† Worker thread
# user  1234 ...   1236 ... ./game  â† Audio thread?

# Step 2: Record only that thread
sudo perf record -F 999 -g --tid 1236

# Or programmatically: name your thread
pthread_setname_np(pthread_self(), "AudioThread");

# Then:
perf record -F 999 -g --call-graph dwarf
# Filter in report: type "/" and search "AudioThread"
```

---

## Concept 4: Off-CPU Analysis

### Why Audio Thread Blocks

```bash
# Record scheduler events
sudo perf record -e sched:sched_switch -g ./game

# Analyze
sudo perf script
```

**Look for:**
```
game  1234 [000] 12345.678: sched:sched_switch
  prev_comm=game prev_pid=1234 prev_state=S
  next_comm=swapper next_pid=0
  
  Audio thread went to sleep (prev_state=S)
  â†’ Waiting on I/O? Mutex?
```

---

## Self-Check Quiz

### Question 1
**What does `perf record -F 999` do?**

A) Records for 999 seconds  
B) Samples at 999 Hz  
C) Uses 999 MB memory  
D) Profiles 999 processes  

<details>
<summary>Answer</summary>

**B) Samples at 999 Hz**

`-F` sets sampling frequency. Kernel interrupts program 999 times per second to record call stack.
</details>

---

### Question 2
**In a flamegraph, what does width represent?**

A) Call depth  
B) CPU time spent in function  
C) Memory usage  
D) Number of calls  

<details>
<summary>Answer</summary>

**B) CPU time spent in function**

Wider boxes = more samples = more time. Height = call stack depth.
</details>

---

### Question 3
**What's a good cache miss rate?**

A) < 1%  
B) 10-20%  
C) 50%  
D) Doesn't matter  

<details>
<summary>Answer</summary>

**A) < 1%**

Below 1% is excellent. Above 10% indicates cache-unfriendly access patterns.
</details>

---

## Key Takeaways

### perf Commands

```bash
# Record
perf record -F 999 -g ./game

# View report
perf report

# Detailed analysis
perf annotate

# Cache stats
perf stat -e cache-references,cache-misses ./game

# Flamegraph
perf script | stackcollapse-perf.pl | flamegraph.pl > flame.svg
```

---

### Optimization Workflow

1. **Profile** â†’ Find hotspot
2. **Hypothesize** â†’ Why is it slow?
3. **Optimize** â†’ Make targeted change
4. **Re-profile** â†’ Verify improvement
5. **Repeat**

**Don't optimize without profiling!**

---

## Connection to Other Lessons

**Prerequisites:**
- L7.1: Scheduling (RT makes profiling easier)
- L5.3: Sine Wave Math (optimization target)

**Enables:**
- L8.2: SIMD (vectorize hotspots found by profiling)
- L8.3: Lock-Free Buffers (optimize synchronization)

---

## Next Lesson Preview

**L8.2: SIMD for Audio Processing**
- Vectorize sine wave generation (4 samples at once)
- SSE2/AVX intrinsics
- Measure speedup with perf

---

**Estimated Completion Time:** 75-90 minutes  
**Difficulty:** â­â­â­â­â˜† (Advanced)  
**Competence Level Achieved:** 5/6 (Synthesis)

**Progress:** Unit 8 is 33% complete! (1/3 lessons done)

