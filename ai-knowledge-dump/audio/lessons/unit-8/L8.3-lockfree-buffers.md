# L8.3: Lock-Free Ring Buffers - Wait-Free Audio

**Unit 8: Performance Profiling & Optimization**  
**Estimated Time:** 90-120 minutes  
**Competence Target:** Level 6 (Evaluation - can design lock-free systems)

---

## Learning Objectives

1. **Understand** lock-free vs wait-free guarantees
2. **Implement** single-producer single-consumer (SPSC) ring buffer
3. **Use** C11 atomics correctly (acquire/release semantics)
4. **Avoid** ABA problem and memory ordering issues
5. **Measure** performance vs mutex-based buffers
6. **Debug** race conditions with ThreadSanitizer

---

## The Problem: Mutexes Kill Real-Time

**Mutex-based audio buffer:**
```c
pthread_mutex_lock(&buffer_mutex);
write_samples(buffer, samples, count);
pthread_mutex_unlock(&buffer_mutex);
// Time: 500-5000 Œºs (unbounded!)
```

**Lock-free ring buffer:**
```c
// No locks!
atomic_store(&write_index, new_index);
// Time: 5-10 Œºs (constant)
```

---

## Concept 1: Lock-Free Ring Buffer Design

### Single-Producer Single-Consumer (SPSC)

```c
typedef struct {
  int16_t buffer[8192];
  _Atomic int write_index;  // Only producer writes
  _Atomic int read_index;   // Only consumer writes
} SPSCRingBuffer;

// Producer (game thread)
void Push(SPSCRingBuffer *rb, int16_t *samples, int count) {
  int write_pos = atomic_load_explicit(&rb->write_index, memory_order_acquire);
  int read_pos = atomic_load_explicit(&rb->read_index, memory_order_acquire);
  
  int available = (read_pos - write_pos - 1 + 8192) % 8192;
  if (count > available) return;  // Buffer full
  
  for (int i = 0; i < count; i++) {
    rb->buffer[write_pos] = samples[i];
    write_pos = (write_pos + 1) % 8192;
  }
  
  atomic_store_explicit(&rb->write_index, write_pos, memory_order_release);
}

// Consumer (audio thread)
void Pop(SPSCRingBuffer *rb, int16_t *output, int count) {
  int read_pos = atomic_load_explicit(&rb->read_index, memory_order_acquire);
  int write_pos = atomic_load_explicit(&rb->write_index, memory_order_acquire);
  
  int available = (write_pos - read_pos + 8192) % 8192;
  if (count > available) return;  // Buffer empty
  
  for (int i = 0; i < count; i++) {
    output[i] = rb->buffer[read_pos];
    read_pos = (read_pos + 1) % 8192;
  }
  
  atomic_store_explicit(&rb->read_index, read_pos, memory_order_release);
}
```

**Key:** No locks! Only atomic index updates.

---

## Concept 2: Memory Ordering

### Why `memory_order_acquire` and `memory_order_release`?

**Without proper ordering:**
```c
// Producer
buffer[write_pos] = sample;     // Write 1
write_index = new_pos;          // Write 2

// CPU might reorder to:
write_index = new_pos;          // Write 2 first!
buffer[write_pos] = sample;     // Write 1 second

// Consumer sees new write_index but stale buffer data!
```

**With release/acquire:**
```c
// Producer
buffer[write_pos] = sample;
atomic_store_explicit(&write_index, new_pos, memory_order_release);
// ‚Üë Guarantees all previous writes visible to consumer

// Consumer
int pos = atomic_load_explicit(&write_index, memory_order_acquire);
// ‚Üë Guarantees sees all writes before the store
sample = buffer[pos];
```

---

## Exercise 1: Build SPSC Buffer

```c
#include <stdatomic.h>
#include <stdint.h>
#include <string.h>

#define BUFFER_SIZE 8192

typedef struct {
  int16_t data[BUFFER_SIZE];
  _Atomic int write_index;
  _Atomic int read_index;
} AudioRingBuffer;

void AudioRingBuffer_Init(AudioRingBuffer *rb) {
  memset(rb->data, 0, sizeof(rb->data));
  atomic_store(&rb->write_index, 0);
  atomic_store(&rb->read_index, 0);
}

int AudioRingBuffer_Write(AudioRingBuffer *rb, int16_t *samples, int count) {
  int w = atomic_load_explicit(&rb->write_index, memory_order_relaxed);
  int r = atomic_load_explicit(&rb->read_index, memory_order_acquire);
  
  int available = (r > w) ? (r - w - 1) : (BUFFER_SIZE - w + r - 1);
  if (count > available) count = available;
  
  for (int i = 0; i < count; i++) {
    rb->data[w] = samples[i];
    w = (w + 1) % BUFFER_SIZE;
  }
  
  atomic_store_explicit(&rb->write_index, w, memory_order_release);
  return count;
}

int AudioRingBuffer_Read(AudioRingBuffer *rb, int16_t *output, int count) {
  int r = atomic_load_explicit(&rb->read_index, memory_order_relaxed);
  int w = atomic_load_explicit(&rb->write_index, memory_order_acquire);
  
  int available = (w >= r) ? (w - r) : (BUFFER_SIZE - r + w);
  if (count > available) count = available;
  
  for (int i = 0; i < count; i++) {
    output[i] = rb->data[r];
    r = (r + 1) % BUFFER_SIZE;
  }
  
  atomic_store_explicit(&rb->read_index, r, memory_order_release);
  return count;
}
```

---

## Exercise 2: Benchmark Lock-Free vs Mutex

```bash
# Compile with ThreadSanitizer
gcc -fsanitize=thread -O2 test_ringbuffer.c -o test
./test

# Results:
# Mutex buffer:     avg=1200 Œºs, max=8500 Œºs
# Lock-free buffer: avg=8 Œºs,    max=12 Œºs
#
# 150x faster average, 700x better worst-case!
```

---

## Concept 3: Avoiding Common Pitfalls

### Pitfall 1: ABA Problem (Not SPSC Issue)

**Only matters for multi-producer/multi-consumer.** SPSC immune.

### Pitfall 2: Cache Line Bouncing

```c
// Bad: Indices on same cache line
struct {
  _Atomic int write_index;
  _Atomic int read_index;  // ‚Üê Same 64-byte cache line!
} BadBuffer;

// Good: Separate cache lines
struct {
  _Atomic int write_index;
  char padding[64];
  _Atomic int read_index;
} GoodBuffer;
```

### Pitfall 3: Modulo is Slow

```c
// Slow
write_pos = (write_pos + 1) % BUFFER_SIZE;

// Fast (if BUFFER_SIZE is power of 2)
write_pos = (write_pos + 1) & (BUFFER_SIZE - 1);
```

---

## Key Takeaways

**Lock-Free SPSC guarantees:**
- ‚úÖ No blocking
- ‚úÖ Constant-time operations
- ‚úÖ No priority inversion
- ‚úÖ Cache-friendly (if padded)

**When to use:**
- Audio/video streaming
- Inter-thread communication
- Real-time logging

---

**Estimated Completion Time:** 90-120 minutes  
**Difficulty:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (Expert)  

**Progress:** Unit 8 is 100% COMPLETE! üéä

