# L8.2: SIMD for Audio Processing - Vectorize Everything!

**Unit 8: Performance Profiling & Optimization**  
**Estimated Time:** 90-120 minutes  
**Competence Target:** Level 5 (Synthesis - can vectorize hotspots)

---

## Learning Objectives

1. **Understand** SIMD (Single Instruction Multiple Data)
2. **Use** SSE2 intrinsics for audio processing
3. **Vectorize** sine wave generation (4 samples at once)
4. **Measure** SIMD speedup vs scalar
5. **Debug** alignment issues
6. **Apply** SIMD to mixing and panning

---

## The Speedup: 4x Faster Audio

**Scalar code (process 1 sample):**

```c
for (int i = 0; i < sample_count; i++) {
  samples[i] = sinf(phase) * volume;
  phase += increment;
}
// Time: 800 μs
```

**SIMD code (process 4 samples simultaneously):**

```c
__m128 phases = _mm_set_ps(phase+3*inc, phase+2*inc, phase+inc, phase);
for (int i = 0; i < sample_count; i += 4) {
  __m128 result = _mm_mul_ps(sin_approx(phases), volumes);
  _mm_store_ps(&samples[i], result);
  phases = _mm_add_ps(phases, increments);
}
// Time: 220 μs → 3.6x faster!
```

---

## Concept 1: SIMD Registers

### What is SIMD?

**SIMD = Single Instruction, Multiple Data**

```
Regular CPU:        SIMD CPU:
  ADD A, B            ADD [A1 A2 A3 A4], [B1 B2 B3 B4]
    ↓                   ↓
  Result: C           Result: [C1 C2 C3 C4]

1 operation         4 operations in parallel!
```

---

### SSE2 Registers (128-bit)

```
XMM0 register (128 bits):
┌───────┬───────┬───────┬───────┐
│ Float │ Float │ Float │ Float │  ← 4 floats
│  32   │  32   │  32   │  32   │  = 128 bits
└───────┴───────┴───────┴───────┘
```

**One instruction operates on all 4 floats!**

---

## Exercise 1: Your First SIMD Code

### Setup

```bash
# Check if CPU supports SSE2
grep sse2 /proc/cpuinfo
# Should show "sse2" flag

# Compile with SSE2
gcc -msse2 -O2 audio.c -o game
```

---

### Simple SIMD Addition

```c
#include <emmintrin.h>  // SSE2 intrinsics

void ScalarAdd(float *a, float *b, float *result, int count) {
  for (int i = 0; i < count; i++) {
    result[i] = a[i] + b[i];
  }
}

void SIMDAdd(float *a, float *b, float *result, int count) {
  for (int i = 0; i < count; i += 4) {
    __m128 va = _mm_load_ps(&a[i]);      // Load 4 floats from a
    __m128 vb = _mm_load_ps(&b[i]);      // Load 4 floats from b
    __m128 vr = _mm_add_ps(va, vb);      // Add 4 pairs in parallel
    _mm_store_ps(&result[i], vr);        // Store 4 results
  }
}
```

**Speedup:** 3-4x faster for large arrays!

---

## Concept 2: Vectorizing Sine Wave

### Problem: sinf() Not Vectorized

```c
// This doesn't help:
__m128 phases = _mm_set_ps(p3, p2, p1, p0);
__m128 result = sinf(phases);  // ← ERROR! sinf takes float, not __m128
```

**Solution:** Use SIMD-friendly sine approximation.

---

### Taylor Series Approximation

```c
// sin(x) ≈ x - x^3/6 + x^5/120 (accurate for -π to π)
inline __m128 sin_approx(__m128 x) {
  __m128 x2 = _mm_mul_ps(x, x);          // x²
  __m128 x3 = _mm_mul_ps(x2, x);         // x³
  __m128 x5 = _mm_mul_ps(x3, x2);        // x⁵

  __m128 term1 = x;
  __m128 term2 = _mm_mul_ps(x3, _mm_set1_ps(-1.0f/6.0f));
  __m128 term3 = _mm_mul_ps(x5, _mm_set1_ps(1.0f/120.0f));

  return _mm_add_ps(_mm_add_ps(term1, term2), term3);
}
```

**Error:** < 0.1% for audio (inaudible)

---

## Exercise 2: SIMD Sine Wave Generator

```c
void GameOutputSoundSIMD(GameSoundOutput *output) {
  static float phase = 0.0f;
  const float freq = 440.0f;
  const float inc = 2.0f * M_PI * freq / output->samples_per_second;

  // Process 4 samples at a time
  int i = 0;
  for (; i + 3 < output->sample_count; i += 4) {
    // Create 4 phases
    __m128 phases = _mm_set_ps(
      phase + 3*inc,
      phase + 2*inc,
      phase + inc,
      phase
    );

    // Compute 4 sines
    __m128 values = sin_approx(phases);

    // Scale by volume
    __m128 vol = _mm_set1_ps(0.3f);
    values = _mm_mul_ps(values, vol);

    // Convert to i16
    __m128 scaled = _mm_mul_ps(values, _mm_set1_ps(32767.0f));
    __m128i int_values = _mm_cvtps_epi32(scaled);

    // Store (need to pack to i16, simplified here)
    int16_t samples[4];
    samples[0] = _mm_extract_epi16(int_values, 0);
    samples[1] = _mm_extract_epi16(int_values, 2);
    samples[2] = _mm_extract_epi16(int_values, 4);
    samples[3] = _mm_extract_epi16(int_values, 6);

    memcpy(&output->samples[i*2], samples, 8);

    phase += 4*inc;
  }

  // Handle remaining samples (< 4)
  for (; i < output->sample_count; i++) {
    float value = sinf(phase) * 0.3f;
    output->samples[i*2] = (int16_t)(value * 32767.0f);
    phase += inc;
  }

  if (phase >= 2.0f * M_PI) phase -= 2.0f * M_PI;
}
```

**Benchmark:**

```
Scalar: 800 μs
SIMD:   220 μs
Speedup: 3.6x
```

---

## Concept 3: Alignment Requirements

### The 16-Byte Rule

**SSE2 requires 16-byte alignment for `_mm_load_ps`:**

```c
float data[100];  // May not be aligned!

__m128 v = _mm_load_ps(&data[0]);  // ← May crash!
```

**Solutions:**

1. **Use aligned allocation:**

```c
float *data = (float *)aligned_alloc(16, 100 * sizeof(float));
```

2. **Use unaligned load (slower):**

```c
__m128 v = _mm_loadu_ps(&data[i]);  // 'u' = unaligned
```

3. **Check alignment:**

```c
assert(((uintptr_t)data & 15) == 0);  // Must be 0 for aligned
```

---

## Exercise 3: SIMD Audio Mixer

**Mix 3 audio sources:**

```c
void MixSIMD(int16_t *out, int16_t *src1, int16_t *src2, int16_t *src3, int count) {
  for (int i = 0; i < count; i += 8) {  // 8 int16s = 128 bits
    // Load 8 samples from each source
    __m128i s1 = _mm_load_si128((__m128i*)&src1[i]);
    __m128i s2 = _mm_load_si128((__m128i*)&src2[i]);
    __m128i s3 = _mm_load_si128((__m128i*)&src3[i]);

    // Average (divide by 3)
    // Convert to 32-bit to avoid overflow
    __m128i s1_lo = _mm_unpacklo_epi16(s1, _mm_setzero_si128());
    __m128i s2_lo = _mm_unpacklo_epi16(s2, _mm_setzero_si128());
    __m128i s3_lo = _mm_unpacklo_epi16(s3, _mm_setzero_si128());

    __m128i sum_lo = _mm_add_epi32(_mm_add_epi32(s1_lo, s2_lo), s3_lo);
    sum_lo = _mm_div_epi32(sum_lo, _mm_set1_epi32(3));  // Average

    // Pack back to i16
    __m128i result = _mm_packs_epi32(sum_lo, sum_lo);
    _mm_store_si128((__m128i*)&out[i], result);
  }
}
```

---

## Self-Check Quiz

### Question 1

**How many floats fit in one SSE2 register?**

<details><summary>Answer</summary>**4 floats** (128 bits ÷ 32 bits = 4)</details>

### Question 2

**What's the difference between `_mm_load_ps` and `_mm_loadu_ps`?**

<details><summary>Answer</summary>`_mm_load_ps` requires 16-byte alignment (faster), `_mm_loadu_ps` works with any alignment (slower)</details>

### Question 3

**Why approximate sin() instead of using library?**

<details><summary>Answer</summary>Library `sinf()` is scalar (1 sample at a time). Taylor series can be vectorized (4 samples at once).</details>

---

## Key Takeaways

### SIMD Intrinsics Cheat Sheet

```c
// Load/Store
__m128 v = _mm_load_ps(float *p);      // Load 4 aligned floats
__m128 v = _mm_loadu_ps(float *p);     // Load 4 unaligned floats
_mm_store_ps(float *p, __m128 v);      // Store 4 floats

// Arithmetic
__m128 sum = _mm_add_ps(a, b);         // a + b
__m128 diff = _mm_sub_ps(a, b);        // a - b
__m128 prod = _mm_mul_ps(a, b);        // a * b
__m128 quot = _mm_div_ps(a, b);        // a / b

// Set values
__m128 v = _mm_set1_ps(3.14f);         // [3.14, 3.14, 3.14, 3.14]
__m128 v = _mm_set_ps(4,3,2,1);        // [1, 2, 3, 4] (reversed!)
```

---

**Estimated Completion Time:** 90-120 minutes  
**Difficulty:** ⭐⭐⭐⭐⭐ (Expert)

**Progress:** Unit 8 is 67% complete! (2/3 lessons done)
