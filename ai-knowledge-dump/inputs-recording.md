# Input Recording Documentation

## Visual Timeline of Recording/Playback

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        COMPLETE TIMELINE EXAMPLE                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  TIME ──────────────────────────────────────────────────────────────────►   │
│                                                                             │
│  Frame:  0    10    20    30    40    50    60    70    80    90   100     │
│          │     │     │     │     │     │     │     │     │     │     │     │
│          ▼     ▼     ▼     ▼     ▼     ▼     ▼     ▼     ▼     ▼     ▼     │
│                                                                             │
│  ════════════════════════════════════════════════════════════════════════   │
│  PHASE 1: NORMAL GAMEPLAY                                                   │
│  ════════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  Player:  ●────────────────────►                                            │
│           (moving right)                                                    │
│                                                                             │
│  State:   IDLE                                                              │
│                                                                             │
│  ════════════════════════════════════════════════════════════════════════   │
│  PHASE 2: USER PRESSES 'L' AT FRAME 30                                      │
│  ════════════════════════════════════════════════════════════════════════   │
│                                                                             │
│                      [L]                                                    │
│                       │                                                     │
│                       ▼                                                     │
│  Action:        SAVE GAME STATE TO FILE                                     │
│                 ┌─────────────────────────────────────────┐                 │
│                 │ File: recording_1.hmi                   │                 │
│                 │ ┌─────────────────────────────────────┐ │                 │
│                 │ │ GAME STATE (player at position 30) │ │                 │
│                 │ └─────────────────────────────────────┘ │                 │
│                 └─────────────────────────────────────────┘                 │
│                                                                             │
│  State:   IDLE ──► RECORDING                                                │
│                                                                             │
│  ════════════════════════════════════════════════════════════════════════   │
│  PHASE 3: RECORDING (Frames 30-60)                                          │
│  ════════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  Player:                    ●────────────────────►                          │
│                             (user plays: right, jump, attack)               │
│                                                                             │
│  File grows:                                                                │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ GAME STATE │ Input30 │ Input31 │ Input32 │ ... │ Input59 │ Input60 │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  State:   RECORDING                                                         │
│                                                                             │
│  ════════════════════════════════════════════════════════════════════════   │
│  PHASE 4: USER PRESSES 'L' AT FRAME 60                                      │
│  ════════════════════════════════════════════════════════════════════════   │
│                                                                             │
│                                              [L]                            │
│                                               │                             │
│                                               ▼                             │
│  Actions:  1. STOP RECORDING (close file)                                   │
│            2. RESTORE GAME STATE FROM FILE                                  │
│            3. START PLAYBACK                                                │
│                                                                             │
│  Player:                                     ●                              │
│                                              │                              │
│                                              ▼                              │
│                      ●  (teleported back to position 30!)                   │
│                                                                             │
│  State:   RECORDING ──► PLAYBACK                                            │
│                                                                             │
│  ════════════════════════════════════════════════════════════════════════   │
│  PHASE 5: PLAYBACK LOOP (Frames 60-90, then 90-120, etc.)                   │
│  ════════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  Frame 60-90: Replay recorded inputs                                        │
│  Player:                    ●────────────────────►                          │
│                             (same movements as frames 30-60)                │
│                                                                             │
│  Frame 90: EOF reached!                                                     │
│            ┌──────────────────────────────────────────────────────┐        │
│            │ 1. Restore game state (player back to position 30)  │        │
│            │ 2. Seek file to first inputs                         │        │
│            │ 3. Continue playback                                 │        │
│            └──────────────────────────────────────────────────────┘        │
│                                                                             │
│  Frame 90-120: Replay again!                                                │
│  Player:                    ●────────────────────►                          │
│                             (same movements again)                          │
│                                                                             │
│  Frame 120: EOF reached! Loop again...                                      │
│                                                                             │
│  ════════════════════════════════════════════════════════════════════════   │
│  PHASE 6: LIVE CODE EDITING (while loop plays)                              │
│  ════════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  While the game loops:                                                      │
│                                                                             │
` change player speed from 4.0 to 8.0                        │`

│  1. Edit game.c
│  2. Save file                                                               │
│  3. Compiler rebuilds game.so                                               │
│  4. Hot reload detects change, loads new code                               │
│  5. Next loop iteration uses NEW code!                                      │
│                                                                             │
│  Player:                    ●════════════════════════════►                  │
│                             (now moves FASTER with same inputs!)            │
│                                                                             │
│  ════════════════════════════════════════════════════════════════════════   │
│  PHASE 7: USER PRESSES 'L' TO STOP                                          │
│  ════════════════════════════════════════════════════════════════════════   │
│                                                                             │
│                                                              [L]            │
│                                                               │             │
│                                                               ▼             │
│  Action:  STOP PLAYBACK                                                     │
│                                                                             │
│  State:   PLAYBACK ──► IDLE                                                 │
│                                                                             │
│  Game continues normally from wherever it was in the loop.                  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Memory Layout Deep Dive

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        MEMORY LAYOUT                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  GAME MEMORY (allocated at startup, never freed)                            │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  Address: 0x0000020000000000 (2 TB mark in debug builds)                    │
│           │                                                                 │
│           ▼                                                                 │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                                                                     │   │
│  │  PERMANENT STORAGE (64 MB)                                          │   │
│  │  ┌─────────────────────────────────────────────────────────────┐   │   │
│  │  │  GameState struct:                                          │   │   │
│  │  │  ├── player_x: 150                                          │   │   │
│  │  │  ├── player_y: 200                                          │   │   │
│  │  │  ├── health: 100                                            │   │   │
│  │  │  ├── score: 5000                                            │   │   │
│  │  │  ├── tone_hz: 512                                           │   │   │
│  │  │  ├── t_sine: 0.785                                          │   │   │
│  │  │  └── ... other game state ...                               │   │   │
│  │  └─────────────────────────────────────────────────────────────┘   │   │
│  │                                                                     │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │                                                                     │   │
│  │  TRANSIENT STORAGE (1 GB)                                           │   │
│  │  ┌─────────────────────────────────────────────────────────────┐   │   │
│  │  │  Loaded assets, scratch memory, temporary data              │   │   │
│  │  │  (This gets saved/restored too!)                            │   │   │
│  │  └─────────────────────────────────────────────────────────────┘   │   │
│  │                                                                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  Total: 64 MB + 1 GB = 1,073,741,824 + 67,108,864 = 1,140,850,688 bytes    │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  RECORDING FILE (on disk)                                                   │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  File: recording_1.hmi                                                      │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                                                                     │   │
│  │  Bytes 0 - 1,140,850,687:                                          │   │
│  │  ┌─────────────────────────────────────────────────────────────┐   │   │
│  │  │  GAME STATE SNAPSHOT                                        │   │   │
│  │  │  (exact copy of game memory at recording start)             │   │   │
│  │  │                                                             │   │   │
│  │  │  player_x: 150                                              │   │   │
│  │  │  player_y: 200                                              │   │   │
│  │  │  health: 100                                                │   │   │
│  │  │  ...                                                        │   │   │
│  │  └─────────────────────────────────────────────────────────────┘   │   │
│  │                                                                     │   │
│  │  Bytes 1,140,850,688 - 1,140,850,687 + sizeof(GameInput):          │   │
│  │  ┌─────────────────────────────────────────────────────────────┐   │   │
│  │  │  INPUT FRAME 0                                              │   │   │
│  │  │  controllers[0].move_right.ended_down = true                │   │   │
│  │  │  controllers[0].stick_avg_x = 0.75                          │   │   │
│  │  │  ...                                                        │   │   │
│  │  └─────────────────────────────────────────────────────────────┘   │   │
│  │                                                                     │   │
│  │  Next sizeof(GameInput) bytes:                                     │   │
│  │  ┌─────────────────────────────────────────────────────────────┐   │   │
│  │  │  INPUT FRAME 1                                              │   │   │
│  │  │  controllers[0].action_down.ended_down = true (jump!)       │   │   │
│  │  │  ...                                                        │   │   │
│  │  └─────────────────────────────────────────────────────────────┘   │   │
│  │                                                                     │   │
│  │  ... more inputs frames ...                                         │   │
│  │                                                                     │   │
│  │  Last sizeof(GameInput) bytes:                                     │   │
│  │  ┌─────────────────────────────────────────────────────────────┐   │   │
│  │  │  INPUT FRAME N                                              │   │   │
│  │  │  (last frame before user pressed L again)                   │   │   │
│  │  └─────────────────────────────────────────────────────────────┘   │   │
│  │                                                                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  File size = 1,140,850,688 + (N × sizeof(GameInput)) bytes                 │
│                                                                             │
│  Example: 30 frames at 30 FPS = 1 second of recording                       │
│           sizeof(GameInput) ≈ 500 bytes (rough estimate)                    │
│           File size ≈ 1.06 GB + 15 KB = ~1.06 GB                           │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## File I/O Byte-by-Byte

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        FILE I/O BYTE-BY-BYTE                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  STEP 1: OPEN FILE FOR WRITING                                              │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  Code: int fd = open("recording_1.hmi", O_WRONLY | O_CREAT | O_TRUNC, 0644) │
│                                                                             │
│  What happens:                                                              │
│                                                                             │
│  1. Kernel looks up "recording_1.hmi" in filesystem                         │
│  2. If exists: truncate to 0 bytes (O_TRUNC)                                │
│  3. If not exists: create new file (O_CREAT)                                │
│  4. Allocate file descriptor in process table                               │
│  5. Return fd (e.g., 3)                                                     │
│                                                                             │
│  Process FD Table:          Kernel File Table:                              │
│  ┌────┬─────────┐           ┌─────────────────────────────────┐            │
│  │ 0  │ stdin   │           │ recording_1.hmi                 │            │
│  │ 1  │ stdout  │           │ ├── position: 0                 │            │
│  │ 2  │ stderr  │           │ ├── size: 0                     │            │
│  │ 3  │ ────────┼──────────►│ └── mode: write-only            │            │
│  └────┴─────────┘           └─────────────────────────────────┘            │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│  STEP 2: WRITE GAME STATE                                                   │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  Code: write(fd, game_memory_base, total_size)                              │
│        // total_size = 1,140,850,688 bytes (~1.06 GB)                       │
│                                                                             │
│  What happens (simplified):                                                 │
│                                                                             │
│  Memory:                                                                    │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ game_memory_base                                                    │   │
│  │ ▼                                                                   │   │
│  │ [B0][B1][B2][B3][B4][B5]...[B1140850687]                            │   │
│  │  │   │   │   │   │   │         │                                    │   │
│  └──┼───┼───┼───┼───┼───┼─────────┼────────────────────────────────────┘   │
│     │   │   │   │   │   │         │                                        │
│     ▼   ▼   ▼   ▼   ▼   ▼         ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Kernel Buffer (copied from user space)                              │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│     │                                                                       │
│     ▼                                                                       │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Disk: recording_1.hmi                                               │   │
│  │ [B0][B1][B2][B3][B4][B5]...[B1140850687]                            │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  After write:                                                               │
│  - File size: 1,140,850,688 bytes                                          │
│  - File position: 1,140,850,688 (at end)                                   │
│  - Returns: 1,140,850,688 (bytes written)                                  │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│  STEP 3: WRITE INPUT FRAMES (each frame)                                    │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  Code: write(fd, inputs, sizeof(GameInput))                                  │
│        // sizeof(GameInput) ≈ 500 bytes                                     │
│                                                                             │
│  Frame 0:                                                                   │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ File before:                                                        │   │
│  │ [GAME STATE (1.06 GB)]                                              │   │
│  │                       ▲                                              │   │
│  │                       └── position                                   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ File after:                                                         │   │
│  │ [GAME STATE (1.06 GB)][INPUT 0 (500 B)]                             │   │
│  │                                        ▲                             │   │
│  │                                        └── position                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  Frame 1:                                                                   │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ [GAME STATE][INPUT 0][INPUT 1]                                      │   │
│  │                               ▲                                      │   │
│  │                               └── position                           │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  Frame N:                                                                   │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ [GAME STATE][INPUT 0][INPUT 1]...[INPUT N]                          │   │
│  │                                           ▲                          │   │
│  │                                           └── position (EOF)         │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│  STEP 4: CLOSE FILE                                                         │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  Code: close(fd)                                                            │
│                                                                             │
│  What happens:                                                              │
│  1. Flush any buffered data to disk                                         │
│  2. Release file descriptor                                                 │
│  3. fd is now invalid (can be reused by kernel)                            │
│                                                                             │
│  Process FD Table:                                                          │
│  ┌────┬─────────┐                                                          │
│  │ 0  │ stdin   │                                                          │
│  │ 1  │ stdout  │                                                          │
│  │ 2  │ stderr  │                                                          │
│  │ 3  │ (free)  │  ◄── No longer points to file                            │
│  └────┴─────────┘                                                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Playback File I/O

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        PLAYBACK FILE I/O                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  STEP 1: OPEN FILE FOR READING                                              │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  Code: int fd = open("recording_1.hmi", O_RDONLY)                           │
│                                                                             │
│  File state:                                                                │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ [GAME STATE][INPUT 0][INPUT 1][INPUT 2]...[INPUT N]                 │   │
│  │ ▲                                                                    │   │
│  │ └── position = 0                                                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│  STEP 2: READ GAME STATE (restore)                                          │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  Code: read(fd, game_memory_base, total_size)                               │
│                                                                             │
│  What happens:                                                              │
│                                                                             │
│  File:                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ [GAME STATE (1.06 GB)][INPUT 0][INPUT 1]...[INPUT N]                │   │
│  │ ├────────────────────┤                                               │   │
│  │ │ Read these bytes   │                                               │   │
│  │ └────────────────────┘                                               │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                         │                                                   │
│                         ▼                                                   │
│  Game Memory:                                                               │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ BEFORE: [CURRENT STATE - player at X=500, health=50]                │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                         │                                                   │
│                         ▼ OVERWRITTEN!                                      │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ AFTER:  [SAVED STATE - player at X=150, health=100]                 │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  File position after read:                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ [GAME STATE][INPUT 0][INPUT 1][INPUT 2]...[INPUT N]                 │   │
│  │             ▲                                                        │   │
│  │             └── position (ready to read inputs)                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│  STEP 3: READ INPUT FRAMES (each frame)                                     │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  Code: bytes_read = read(fd, inputs, sizeof(GameInput))                      │
│                                                                             │
│  Frame 0:                                                                   │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ [GAME STATE][INPUT 0][INPUT 1][INPUT 2]...[INPUT N]                 │   │
│  │             ├───────┤                                                │   │
│  │             │ Read  │                                                │   │
│  │             └───────┘                                                │   │
│  │                      ▲                                               │   │
│  │                      └── new position                                │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│  bytes_read = sizeof(GameInput) ✓                                          │
│                                                                             │
│  Frame 1:                                                                   │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ [GAME STATE][INPUT 0][INPUT 1][INPUT 2]...[INPUT N]                 │   │
│  │                      ├───────┤                                       │   │
│  │                      │ Read  │                                       │   │
│  │                      └───────┘                                       │   │
│  │                               ▲                                      │   │
│  │                               └── new position                       │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│  bytes_read = sizeof(GameInput) ✓                                          │
│                                                                             │
│  ... continues until ...                                                    │
│                                                                             │
│  Frame N (last frame):                                                      │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ [GAME STATE][INPUT 0][INPUT 1][INPUT 2]...[INPUT N]                 │   │
│  │                                           ├───────┤                  │   │
│  │                                           │ Read  │                  │   │
│  │                                           └───────┘                  │   │
│  │                                                    ▲                 │   │
│  │                                                    └── position=EOF  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│  bytes_read = sizeof(GameInput) ✓                                          │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│  STEP 4: EOF DETECTED (next read attempt)                                   │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  Code: bytes_read = read(fd, inputs, sizeof(GameInput))                      │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ [GAME STATE][INPUT 0][INPUT 1][INPUT 2]...[INPUT N]│                │   │
│  │                                                    ▲│               │   │
│  │                                                    └┼── EOF         │   │
│  │                                                     │               │   │
│  │                                          Nothing to read!           │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│  bytes_read = 0  ◄── This is how we detect end of recording!               │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│  STEP 5: LOOP (when EOF detected)                                           │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  When bytes_read == 0:                                                      │
│                                                                             │
│  1. Close file:  close(fd)                                                  │
│                                                                             │
│  2. Reopen file: fd = open("recording_1.hmi", O_RDONLY)                     │
│     ┌─────────────────────────────────────────────────────────────────┐    │
│     │ [GAME STATE][INPUT 0][INPUT 1]...[INPUT N]                      │    │
│     │ ▲                                                                │    │
│     │ └── position = 0 (back to start!)                                │    │
│     └─────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  3. Read game state: read(fd, game_memory_base, total_size)                 │
│     - Game memory restored to saved state                                   │
│     - Player teleports back to starting position                            │
│     ┌─────────────────────────────────────────────────────────────────┐    │
│     │ [GAME STATE][INPUT 0][INPUT 1]...[INPUT N]                      │    │
│     │             ▲                                                    │    │
│     │             └── position (ready for inputs again)                │    │
│     └─────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  4. Read first inputs: read(fd, inputs, sizeof(GameInput))                    │
│     - Now playing from beginning again!                                     │
│                                                                             │
│  This creates the INFINITE LOOP for live code editing!                      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Complete Code Summary

### Data Flow Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        COMPLETE DATA FLOW                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                         MAIN LOOP                                   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  1. PREPARE INPUT FRAME                                             │   │
│  │     prepare_input_frame(old_input, new_input)                       │   │
│  │     - Copy ended_down states                                        │   │
│  │     - Reset half_transition_counts                                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  2. GET INPUT                                                       │   │
│  │                                                                     │   │
│  │     ┌──────────────────┐     ┌──────────────────┐                  │   │
│  │     │ PLAYBACK MODE?   │────►│ YES: Read from   │                  │   │
│  │     │                  │     │ file             │                  │   │
│  │     └────────┬─────────┘     │                  │                  │   │
│  │              │ NO            │ playback_get_    │                  │   │
│  │              ▼               │ inputs(state,     │                  │   │
│  │     ┌──────────────────┐     │ new_input)       │                  │   │
│  │     │ Poll hardware:   │     └──────────────────┘                  │   │
│  │     │ - Keyboard       │              │                            │   │
│  │     │ - Joystick       │              │                            │   │
│  │     │ - Mouse          │              │                            │   │
│  │     └────────┬─────────┘              │                            │   │
│  │              │                        │                            │   │
│  │              ▼                        │                            │   │
│  │     ┌──────────────────┐              │                            │   │
│  │     │ RECORDING MODE?  │              │                            │   │
│  │     │                  │              │                            │   │
│  │     └────────┬─────────┘              │                            │   │
│  │              │ YES                    │                            │   │
│  │              ▼                        │                            │   │
│  │     ┌──────────────────┐              │                            │   │
│  │     │ Write to file:   │              │                            │   │
│  │     │ recording_record │              │                            │   │
│  │     │ _input(state,    │              │                            │   │
│  │     │ new_input)       │              │                            │   │
│  │     └──────────────────┘              │                            │   │
│  │              │                        │                            │   │
│  │              └────────────────────────┘                            │   │
│  │                         │                                          │   │
│  └─────────────────────────┼──────────────────────────────────────────┘   │
│                            ▼                                               │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  3. GAME UPDATE                                                     │   │
│  │     game.update_and_render(&memory, new_input, &backbuffer)         │   │
│  │                                                                     │   │
│  │     - Uses new_input (either real or recorded)                      │   │
│  │     - Updates game state in memory                                  │   │
│  │     - Renders to backbuffer                                         │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                            │                                               │
│                            ▼                                               │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  4. AUDIO                                                           │   │
│  │     game.get_audio_samples(&memory, &audio_buffer)                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                            │                                               │
│                            ▼                                               │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  5. DISPLAY                                                         │   │
│  │     opengl_display_buffer(&backbuffer)                              │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                            │                                               │
│                            ▼                                               │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  6. SWAP INPUTS                                                     │   │
│  │     temp = new_input                                                │   │
│  │     new_input = old_input                                           │   │
│  │     old_input = temp                                                │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                            │                                               │
│                            ▼                                               │
│                      NEXT FRAME                                            │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Key Insights

### Why This Works

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        KEY INSIGHTS                                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. DETERMINISM                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  If you give the game:                                                      │
│    - Same starting state                                                    │
│    - Same sequence of inputs                                                │
│                                                                             │
│  You get:                                                                   │
│    - Same exact behavior every time!                                        │
│                                                                             │
│  This is why recording/playback works:                                      │
│    State₀ + Input₀ → State₁                                                 │
│    State₁ + Input₁ → State₂                                                 │
│    State₂ + Input₂ → State₃                                                 │
│    ...                                                                      │
│                                                                             │
│  Same inputs + same starting state = same results                           │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│  2. MEMORY AS A SNAPSHOT                                                    │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  Game state is JUST BYTES in memory.                                        │
│                                                                             │
│  To save:  Copy bytes from memory → file                                    │
│  To load:  Copy bytes from file → memory                                    │
│                                                                             │
│  No serialization needed! No parsing! Just raw bytes.                       │
│                                                                             │
│  ┌────────────────────┐         ┌────────────────────┐                     │
│  │ Memory             │ ──────► │ File               │                     │
│  │ [raw bytes]        │  write  │ [same raw bytes]   │                     │
│  └────────────────────┘         └────────────────────┘                     │
│                                                                             │
│  ┌────────────────────┐         ┌────────────────────┐                     │
│  │ Memory             │ ◄────── │ File               │                     │
│  │ [restored bytes]   │  read   │ [saved bytes]      │                     │
│  └────────────────────┘         └────────────────────┘                     │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│  3. FILE POSITION IS AUTOMATIC                                              │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  Every read/write advances the file position automatically.                 │
│                                                                             │
│  write(fd, data, 100)  →  position += 100                                   │
│  read(fd, buf, 100)    →  position += 100                                   │
│                                                                             │
│  We don't need to manually track where we are in the file!                  │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│  4. EOF DETECTION                                                           │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  read() returns 0 when there's nothing left to read.                        │
│                                                                             │
│  This is NOT an error - it's how we know we've reached the end.             │
│                                                                             │
│  bytes_read = read(fd, buf, 100);                                           │
│  if (bytes_read == 0) {                                                     │
│      // End of file - time to loop!                                         │
│  }                                                                          │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│  5. WHY SLOTS?                                                              │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  Slots let you have multiple recordings:                                    │
│                                                                             │
│  Slot 1: "recording_1.hmi" - Test jumping                                   │
│  Slot 2: "recording_2.hmi" - Test combat                                    │
│  Slot 3: "recording_3.hmi" - Test edge case                                 │
│                                                                             │
│  You could bind different keys to different slots:                          │
│    F1 → Slot 1                                                              │
│    F2 → Slot 2                                                              │
│    F3 → Slot 3                                                              │
│                                                                             │
│  For now, we just use slot 1 with the L key.                                │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│  6. LIVE CODE EDITING                                                       │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  The magic happens because:                                                 │
│                                                                             │
│  1. Game code is in a shared library (.so / .dll)                           │
│  2. Hot reload replaces the code while running                              │
│  3. Playback loop keeps running with NEW code                               │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Loop iteration 1: game.so v1 (player speed = 4)                     │   │
│  │ Loop iteration 2: game.so v1 (player speed = 4)                     │   │
│  │ Loop iteration 3: game.so v1 (player speed = 4)                     │   │
│  │                                                                     │   │
│  │ --- You edit code, change speed to 8, save ---                      │   │
│  │ --- Hot reload detects change, loads new .so ---                    │   │
│  │                                                                     │   │
│  │ Loop iteration 4: game.so v2 (player speed = 8) ◄── NEW CODE!       │   │
│  │ Loop iteration 5: game.so v2 (player speed = 8)                     │   │
│  │ Loop iteration 6: game.so v2 (player speed = 8)                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  Same inputs, different code = different behavior!                          │
│  You can SEE your changes immediately without restarting.                   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Day 25: Memory-Mapped Replay Buffers

### The Performance Problem (Day 24)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    DAY 24 PERFORMANCE ISSUE                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  RECORDING START:                                                           │
│  ─────────────────                                                          │
│                                                                             │
│  User presses L → write(fd, game_memory, 1GB) → DISK                        │
│                                                                             │
│  ┌──────────────┐                           ┌──────────────┐               │
│  │ Game Memory  │ ════════════════════════► │  Disk File   │               │
│  │   (1+ GB)    │      write() syscall      │  (1+ GB)     │               │
│  └──────────────┘      2-5 SECONDS! ❌      └──────────────┘               │
│                                                                             │
│  User experience: GAME FREEZES for seconds!                                 │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  PLAYBACK LOOP:                                                             │
│  ──────────────                                                             │
│                                                                             │
│  End of inputs → read(fd, game_memory, 1GB) → RESTORE                       │
│                                                                             │
│  ┌──────────────┐                           ┌──────────────┐               │
│  │ Game Memory  │ ◄════════════════════════ │  Disk File   │               │
│  │   (1+ GB)    │      read() syscall       │  (1+ GB)     │               │
│  └──────────────┘      2-5 SECONDS! ❌      └──────────────┘               │
│                                                                             │
│  User experience: GAME FREEZES every loop iteration!                        │
│                                                                             │
│  For a 5-second recording looping continuously:                             │
│    - 5 seconds of gameplay                                                  │
│    - 3 seconds of freeze                                                    │
│    - 5 seconds of gameplay                                                  │
│    - 3 seconds of freeze...                                                 │
│                                                                             │
│  This makes live code editing PAINFUL! 😫                                   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### The Solution: Memory-Mapped Files (Day 25)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    DAY 25 SOLUTION: MMAP                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  CONCEPT:                                                                   │
│  ────────                                                                   │
│                                                                             │
│  Instead of reading/writing files, we create a MEMORY REGION that           │
│  the OS automatically syncs to a file in the background.                    │
│                                                                             │
│  For our use case, we don't even care about the file sync -                 │
│  we just need fast RAM-to-RAM copies!                                       │
│                                                                             │
│  ┌──────────────┐     ┌──────────────┐     ┌──────────────┐               │
│  │ Game Memory  │     │ Replay Buffer│     │  Disk File   │               │
│  │   (1+ GB)    │     │   (mmap'd)   │     │  (1+ GB)     │               │
│  └──────────────┘     └──────────────┘     └──────────────┘               │
│         │                    │                    │                        │
│         │    memcpy()        │    OS handles      │                        │
│         │ ═══════════►       │    sync lazily     │                        │
│         │  ~100ms! ✅        │    in background   │                        │
│         │                    │                    │                        │
│         │    memcpy()        │                    │                        │
│         │ ◄═══════════       │                    │                        │
│         │  ~100ms! ✅        │                    │                        │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  PERFORMANCE COMPARISON:                                                    │
│  ───────────────────────                                                    │
│                                                                             │
│  Operation          │ Day 24 (File I/O) │ Day 25 (mmap)  │ Speedup         │
│  ───────────────────┼───────────────────┼────────────────┼─────────────    │
│  Save 1GB state     │ 2-5 seconds       │ 50-100ms       │ 20-50x faster   │
│  Restore 1GB state  │ 2-5 seconds       │ 50-100ms       │ 20-50x faster   │
│  Loop iteration     │ PAINFUL           │ SMOOTH         │ ∞ better UX     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### Windows vs Linux Memory Mapping

```
┌─────────────────────────────────────────────────────────────────────────────┐
│              WINDOWS vs LINUX MEMORY MAPPING                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  WINDOWS (Casey's code):                                                    │
│  ───────────────────────                                                    │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Step 1: CreateFileA(filename, GENERIC_READ|GENERIC_WRITE, ...)      │   │
│  │         └─→ Returns: HANDLE to file                                 │   │
│  │                                                                     │   │
│  │ Step 2: CreateFileMapping(file_handle, NULL, PAGE_READWRITE,        │   │
│  │                           size_high, size_low, NULL)                │   │
│  │         └─→ Returns: HANDLE to mapping object                       │   │
│  │         └─→ NOTE: Size is specified HERE                            │   │
│  │                                                                     │   │
│  │ Step 3: MapViewOfFile(mapping_handle, FILE_MAP_ALL_ACCESS,          │   │
│  │                       0, 0, size)                                   │   │
│  │         └─→ Returns: void* pointer to mapped memory                 │   │
│  │                                                                     │   │
│  │ Usage:  CopyMemory(mapped_ptr, game_memory, size);  // Save         │   │
│  │         CopyMemory(game_memory, mapped_ptr, size);  // Restore      │   │
│  │                                                                     │   │
│  │ Cleanup: UnmapViewOfFile(mapped_ptr);                               │   │
│  │          CloseHandle(mapping_handle);                               │   │
│  │          CloseHandle(file_handle);                                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  LINUX (Our implementation):                                                │
│  ────────────────────────────                                               │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Step 1: open(filename, O_RDWR | O_CREAT | O_TRUNC, 0644)            │   │
│  │         └─→ Returns: int file descriptor                           │   │
│  │                                                                     │   │
│  │ Step 2: ftruncate(fd, size)                                         │   │
│  │         └─→ CRITICAL: Set file size BEFORE mmap!                    │   │
│  │         └─→ Windows CreateFileMapping does this implicitly          │   │
│  │         └─→ Linux requires explicit sizing                          │   │
│  │                                                                     │   │
│  │ Step 3: mmap(NULL, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0)   │   │
│  │         └─→ Returns: void* pointer to mapped memory                 │   │
│  │         └─→ NULL = let OS choose address                            │   │
│  │         └─→ MAP_SHARED = changes written to file                    │   │
│  │                                                                     │   │
│  │ Usage:  de100_mem_copy(mapped_ptr, game_memory, size);  // Save     │   │
│  │         de100_mem_copy(game_memory, mapped_ptr, size);  // Restore  │   │
│  │                                                                     │   │
│  │ Cleanup: munmap(mapped_ptr, size);                                  │   │
│  │          close(fd);                                                 │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  KEY DIFFERENCE:                                                            │
│  ───────────────                                                            │
│                                                                             │
│  Windows: CreateFileMapping specifies size → file grows automatically       │
│  Linux:   mmap maps EXISTING file content → must ftruncate() first!         │
│                                                                             │
│  ❌ COMMON LINUX MISTAKE:                                                   │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ int fd = open("file.bin", O_RDWR | O_CREAT, 0644);                  │   │
│  │ void *ptr = mmap(NULL, 1GB, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);│  │
│  │ // FAILS or gives you 0 bytes! File is empty!                       │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ✅ CORRECT LINUX APPROACH:                                                 │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ int fd = open("file.bin", O_RDWR | O_CREAT | O_TRUNC, 0644);        │   │
│  │ ftruncate(fd, 1GB);  // ← CRITICAL: Set size first!                 │   │
│  │ void *ptr = mmap(NULL, 1GB, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);│  │
│  │ // Now ptr points to 1GB of usable memory                           │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### Architecture Overview

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    REPLAY BUFFER ARCHITECTURE                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  STRUCTURE (defined in game/memory.h):                                      │
│  ─────────────────────────────────────                                      │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ ReplayBuffer                                                        │   │
│  │ ┌─────────────────────────────────────────────────────────────────┐ │   │
│  │ │ file_handle: 4               // File descriptor (Linux)        │ │   │
│  │ │ memory_map: (handle)         // Mapping handle (Windows only)  │ │   │
│  │ │ memory_block: 0x7f1234560000 // mmap'd region pointer          │ │   │
│  │ │ filename: "/path/loop_edit_0_state.hmi"                         │ │   │
│  │ │ is_valid: true               // Ready for use?                 │ │   │
│  │ └─────────────────────────────────────────────────────────────────┘ │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  STORAGE IN GameMemoryState (game/memory.h):                                │
│  ───────────────────────────────────────────                                │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ GameMemoryState                                                     │   │
│  │ ┌─────────────────────────────────────────────────────────────────┐ │   │
│  │ │ total_size: 1,140,850,688 (permanent + transient)               │ │   │
│  │ │ game_memory: 0x20000000000 (pointer to game state)              │ │   │
│  │ │                                                                 │ │   │
│  │ │ recording_fd: 3 (file descriptor for input file)               │ │   │
│  │ │ input_recording_index: 1 (which slot, 0 = not recording)       │ │   │
│  │ │                                                                 │ │   │
│  │ │ playback_fd: -1 (not playing)                                  │ │   │
│  │ │ input_playing_index: 0 (not playing)                           │ │   │
│  │ │                                                                 │ │   │
│  │ │ replay_buffers[MAX_REPLAY_BUFFERS]:  ◄─── Day 25 addition      │ │   │
│  │ │ ┌─────────────────────────────────────────────────────────────┐│ │   │
│  │ │ │ [0] ReplayBuffer { fd=4, ptr=0x7f..., valid=true }          ││ │   │
│  │ │ │ [1] ReplayBuffer { fd=5, ptr=0x7f..., valid=true } ◄─DEFAULT││ │   │
│  │ │ │ [2] ReplayBuffer { fd=6, ptr=0x7f..., valid=true }          ││ │   │
│  │ │ │ [3] ReplayBuffer { fd=7, ptr=0x7f..., valid=true }          ││ │   │
│  │ │ └─────────────────────────────────────────────────────────────┘│ │   │
│  │ └─────────────────────────────────────────────────────────────────┘ │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  FILE LAYOUT (Day 25 - Separate Files):                                     │
│  ──────────────────────────────────────                                     │
│                                                                             │
│  Day 24 (single file):                                                      │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ loop_edit_1.hmi                                                     │   │
│  │ [GAME STATE (1GB)][INPUT 0][INPUT 1][INPUT 2]...[INPUT N]           │   │
│  │ ├────────────────┤├─────────────────────────────────────────┤       │   │
│  │ │ Written once   ││ Appended each frame                     │       │   │
│  │ │ (slow!)        ││ (fast, small)                           │       │   │
│  │ └────────────────┘└─────────────────────────────────────────┘       │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  Day 25 (separate files):                                                   │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ loop_edit_1_state.hmi (memory-mapped)                               │   │
│  │ [GAME STATE (1GB)]                                                  │   │
│  │ ├────────────────┤                                                  │   │
│  │ │ mmap'd region  │ ◄── de100_mem_copy to/from this (FAST!)          │   │
│  │ └────────────────┘                                                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ loop_edit_1_input.hmi (regular file)                                │   │
│  │ [INPUT 0][INPUT 1][INPUT 2]...[INPUT N]                             │   │
│  │ ├─────────────────────────────────────────┤                         │   │
│  │ │ Regular file I/O (small, fast enough)   │                         │   │
│  │ └─────────────────────────────────────────┘                         │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### API Reference

#### replay-buffer.h

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    REPLAY BUFFER API                                        │
│                    Location: project/engine/platforms/_common/replay-buffer.h│
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  INITIALIZATION:                                                            │
│  ───────────────                                                            │
│                                                                             │
│  bool replay_buffers_init(const char *exe_directory,                        │
│                           GameMemoryState *state);                          │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Purpose: Create and mmap all replay buffer files at startup         │   │
│  │                                                                     │   │
│  │ Parameters:                                                         │   │
│  │   exe_directory - Where to create replay files                      │   │
│  │   state         - GameMemoryState with total_size set               │   │
│  │                                                                     │   │
│  │ When to call: After game memory allocated, before main loop         │   │
│  │                                                                     │   │
│  │ Returns: true if at least one buffer initialized                    │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  SHUTDOWN:                                                                  │
│  ─────────                                                                  │
│                                                                             │
│  void replay_buffers_shutdown(GameMemoryState *state);                      │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Purpose: Unmap and close all replay buffer files                    │   │
│  │                                                                     │   │
│  │ When to call: During engine shutdown                                │   │
│  │                                                                     │   │
│  │ Note: Files remain on disk. Safe to call multiple times.            │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  GET BUFFER:                                                                │
│  ───────────                                                                │
│                                                                             │
│  ReplayBuffer *replay_buffer_get(GameMemoryState *state,                    │
│                                  i32 slot_index);                         │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Purpose: Get pointer to a specific replay buffer slot               │   │
│  │                                                                     │   │
│  │ Returns: Pointer to ReplayBuffer, or NULL if invalid index          │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  SAVE STATE:                                                                │
│  ───────────                                                                │
│                                                                             │
│  bool replay_buffer_save_state(GameMemoryState *state,                      │
│                                i32 slot_index);                           │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Purpose: Snapshot game memory to replay buffer (FAST!)              │   │
│  │                                                                     │   │
│  │ What it does:                                                       │   │
│  │   memcpy(buffer->memory_block, state->game_memory, total_size)      │   │
│  │                                                                     │   │
│  │ Performance: ~50-100ms for 1GB (vs 2-5 seconds with file I/O)       │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  RESTORE STATE:                                                             │
│  ──────────────                                                             │
│                                                                             │
│  bool replay_buffer_restore_state(GameMemoryState *state,                   │
│                                   i32 slot_index);                        │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Purpose: Restore game memory from replay buffer (FAST!)             │   │
│  │                                                                     │   │
│  │ What it does:                                                       │   │
│  │   memcpy(state->game_memory, buffer->memory_block, total_size)      │   │
│  │                                                                     │   │
│  │ When to call: At start of playback, and on each loop iteration      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### input-recording.h

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    INPUT RECORDING API                                      │
│                    Location: project/engine/platforms/_common/input-recording.h│
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  RESULT CODE (Day 25 Addition):                                             │
│  ──────────────────────────────                                             │
│                                                                             │
│  typedef enum {                                                             │
│    INPUT_RECORDING_TOGGLE_STARTED_RECORDING,                                │
│    INPUT_RECORDING_TOGGLE_SWITCHED_TO_PLAYBACK,                             │
│    INPUT_RECORDING_TOGGLE_STOPPED_PLAYBACK,  ◄── Day 25: Can exit playback! │
│  } INPUT_RECORDING_TOGGLE_RESULT_CODE;                                      │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  TOGGLE FUNCTION:                                                           │
│  ────────────────                                                           │
│                                                                             │
│  INPUT_RECORDING_TOGGLE_RESULT_CODE                                         │
│  input_recording_toggle(const char *exe_directory,                          │
│                         GameMemoryState *state);                            │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Purpose: Cycle through recording states                             │   │
│  │                                                                     │   │
│  │ State Machine:                                                      │   │
│  │   IDLE → RECORDING → PLAYBACK → IDLE                                │   │
│  │                                                                     │   │
│  │ Returns: Result code indicating what transition occurred            │   │
│  │                                                                     │   │
│  │ Game can use result to decide whether to reset inputs:              │   │
│  │   if (result == INPUT_RECORDING_TOGGLE_STOPPED_PLAYBACK) {          │   │
│  │       // Reset controller states to prevent "stuck keys"           │   │
│  │   }                                                                 │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  STATE QUERY FUNCTIONS:                                                     │
│  ──────────────────────                                                     │
│                                                                             │
│  bool input_recording_is_recording(GameMemoryState *state);                 │
│  bool input_recording_is_playing(GameMemoryState *state);                   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  FRAME FUNCTIONS:                                                           │
│  ────────────────                                                           │
│                                                                             │
│  void input_recording_record_frame(GameMemoryState *state,                  │
│                                    const GameInput *input);                 │
│                                                                             │
│  void input_recording_playback_frame(GameMemoryState *state,                │
│                                      GameInput *input);                     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### State Machine (Day 25)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    STATE MACHINE                                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                       ┌─────────────┐                                       │
│                       │             │                                       │
│           ┌──────────►│    IDLE     │◄──────────────┐                       │
│           │           │             │               │                       │
│           │           └──────┬──────┘               │                       │
│           │                  │                      │                       │
│           │           Press L│                      │                       │
│           │                  ▼                      │                       │
│           │           ┌─────────────┐               │                       │
│           │           │             │               │                       │
│           │           │  RECORDING  │               │                       │
│           │           │             │               │                       │
│           │           │ • Save state│               │                       │
│           │           │   to mmap   │               │                       │
│           │           │   (~100ms)  │               │                       │
│           │           │             │               │                       │
│           │           │ • Write     │               │                       │
│           │           │   inputs to │               │                       │
│           │           │   file      │               │                       │
│           │           │             │               │                       │
│           │           └──────┬──────┘               │                       │
│           │                  │                      │                       │
│           │           Press L│                      │                       │
│           │                  ▼                      │                       │
│           │           ┌─────────────┐               │                       │
│           │           │             │               │                       │
│           │   ┌──────►│  PLAYBACK   │───────────────┘                       │
│           │   │       │             │     Press L                           │
│           │   │       │ • Restore   │     (Day 25: Can exit!)               │
│           │   │       │   state from│                                       │
│           │   │       │   mmap      │                                       │
│           │   │       │   (~100ms)  │                                       │
│           │   │       │             │                                       │
│           │   │       │ • Read      │                                       │
│           │   │       │   inputs    │                                       │
│           │   │       │   from file │                                       │
│           │   │       │             │                                       │
│           │   │       └─────────────┘                                       │
│           │   │              │                                              │
│           │   │              │ EOF reached                                  │
│           │   │              │                                              │
│           │   └──────────────┘                                              │
│           │     Loop: restore state (~100ms)                                │
│           │            seek to start                                        │
│           │            continue playback                                    │
│           │                                                                 │
│           │                                                                 │
│           │   Day 24: Could NOT exit playback with L                        │
│           │   Day 25: CAN exit playback with L ✓                            │
│           │                                                                 │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### Integration Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    INTEGRATION FLOW                                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ENGINE STARTUP (engine.c):                                                 │
│  ──────────────────────────                                                 │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 1. Allocate game memory                                             │   │
│  │    allocations->game_state = de100_memory_alloc(base, total_size);  │   │
│  │                                                                     │   │
│  │ 2. Set up GameMemoryState                                           │   │
│  │    platform->memory_state.total_size = total_size;                  │   │
│  │    platform->memory_state.game_memory = allocations->game_state.base;│  │
│  │                                                                     │   │
│  │ 3. Initialize replay buffers (Day 25)                               │   │
│  │    replay_buffers_init(exe_directory, &platform->memory_state);     │   │
│  │                                                                     │   │
│  │ 4. Initialize recording state                                       │   │
│  │    platform->memory_state.recording_fd = -1;                        │   │
│  │    platform->memory_state.playback_fd = -1;                         │   │
│  │    platform->memory_state.input_recording_index = 0;                │   │
│  │    platform->memory_state.input_playing_index = 0;                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  MAIN LOOP (backend.c):                                                     │
│  ──────────────────────                                                     │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ while (is_game_running) {                                           │   │
│  │                                                                     │   │
│  │     // 1. Prepare input frame                                       │   │
│  │     prepare_input_frame(old_input, new_input);                      │   │
│  │                                                                     │   │
│  │     // 2. Poll real inputs (keyboard, joystick, mouse)              │   │
│  │     poll_keyboard(new_input);                                       │   │
│  │     poll_joystick(new_input);                                       │   │
│  │     poll_mouse(new_input);                                          │   │
│  │                                                                     │   │
│  │     // 3. Recording: save real inputs to file                       │   │
│  │     if (input_recording_is_recording(&memory_state)) {              │   │
│  │         input_recording_record_frame(&memory_state, new_input);     │   │
│  │     }                                                               │   │
│  │                                                                     │   │
│  │     // 4. Playback: OVERWRITE inputs from file                      │   │
│  │     if (input_recording_is_playing(&memory_state)) {                │   │
│  │         input_recording_playback_frame(&memory_state, new_input);   │   │
│  │     }                                                               │   │
│  │                                                                     │   │
│  │     // 5. Game update (uses new_input, doesn't know about recording)│   │
│  │     game_update_and_render(&memory, new_input, &backbuffer);        │   │
│  │                                                                     │   │
│  │     // 6. Swap input buffers                                        │   │
│  │     swap(old_input, new_input);                                     │   │
│  │ }                                                                   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  KEYBOARD HANDLER (keyboard.c):                                             │
│  ──────────────────────────────                                             │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ case XK_L:                                                          │   │
│  │ case XK_l: {                                                        │   │
│  │     INPUT_RECORDING_TOGGLE_RESULT_CODE result =                     │   │
│  │         input_recording_toggle(exe_directory, &memory_state);       │   │
│  │                                                                     │   │
│  │     // Game decides whether to reset inputs on playback stop        │   │
│  │     if (result == INPUT_RECORDING_TOGGLE_STOPPED_PLAYBACK) {        │   │
│  │         // Reset all controller states to prevent "stuck keys"      │   │
│  │         for (u32 c = 0; c < MAX_CONTROLLER_COUNT; c++) {         │   │
│  │             GameControllerInput *ctrl = &inputs->controllers[c];    │   │
│  │             for (u32 b = 0; b < ArraySize(ctrl->buttons); b++) { │   │
│  │                 ctrl->buttons[b].ended_down = false;                │   │
│  │                 ctrl->buttons[b].half_transition_count = 0;         │   │
│  │             }                                                       │   │
│  │             ctrl->stick_avg_x = 0.0f;                               │   │
│  │             ctrl->stick_avg_y = 0.0f;                               │   │
│  │         }                                                           │   │
│  │         // Also reset old_inputs to prevent state bleeding          │   │
│  │         // (same loop for old_inputs)                               │   │
│  │     }                                                               │   │
│  │     break;                                                          │   │
│  │ }                                                                   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  ENGINE SHUTDOWN (engine.c):                                                │
│  ───────────────────────────                                                │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ // Stop any active recording/playback                               │   │
│  │ input_recording_end(&memory_state);                                 │   │
│  │ input_recording_playback_end(&memory_state);                        │   │
│  │                                                                     │   │
│  │ // Clean up replay buffers (Day 25)                                 │   │
│  │ replay_buffers_shutdown(&memory_state);                             │   │
│  │                                                                     │   │
│  │ // Free game memory                                                 │   │
│  │ de100_memory_free(&allocations->game_state);                        │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### Recording Flow (Day 25)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    RECORDING FLOW (Day 25)                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  USER PRESSES L (Start Recording):                                          │
│  ─────────────────────────────────                                          │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ input_recording_begin():                                            │   │
│  │                                                                     │   │
│  │ 1. Get replay buffer for slot                                       │   │
│  │    ReplayBuffer *buffer = replay_buffer_get(state, slot_index);     │   │
│  │                                                                     │   │
│  │ 2. Open input file for writing                                      │   │
│  │    fd = de100_file_open("loop_edit_1_input.hmi", WRITE|CREATE);     │   │
│  │                                                                     │   │
│  │ 3. FAST: Save state to mmap'd buffer (~100ms)                       │   │
│  │    replay_buffer_save_state(state, slot_index);                     │   │
│  │    └─→ de100_mem_copy(buffer->memory_block, game_memory, size);     │   │
│  │                                                                     │   │
│  │ 4. Set recording state                                              │   │
│  │    state->recording_fd = fd;                                        │   │
│  │    state->input_recording_index = slot_index;                       │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  EACH FRAME (While Recording):                                              │
│  ─────────────────────────────                                              │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ input_recording_record_frame():                                     │   │
│  │                                                                     │   │
│  │ 1. Write input to file (small, fast)                                │   │
│  │    de100_file_write_all(fd, input, sizeof(GameInput));              │   │
│  │    └─→ ~500 bytes per frame, negligible time                        │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### Playback Flow (Day 25)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    PLAYBACK FLOW (Day 25)                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  USER PRESSES L (Start Playback):                                           │
│  ────────────────────────────────                                           │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ input_recording_playback_begin():                                   │   │
│  │                                                                     │   │
│  │ 1. Get replay buffer for slot                                       │   │
│  │    ReplayBuffer *buffer = replay_buffer_get(state, slot_index);     │   │
│  │                                                                     │   │
│  │ 2. Open input file for reading                                      │   │
│  │    fd = de100_file_open("loop_edit_1_input.hmi", READ);             │   │
│  │                                                                     │   │
│  │ 3. FAST: Restore state from mmap'd buffer (~100ms)                  │   │
│  │    replay_buffer_restore_state(state, slot_index);                  │   │
│  │    └─→ de100_mem_copy(game_memory, buffer->memory_block, size);     │   │
│  │                                                                     │   │
│  │ 4. Set playback state                                               │   │
│  │    state->playback_fd = fd;                                         │   │
│  │    state->input_playing_index = slot_index;                         │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  EACH FRAME (While Playing):                                                │
│  ───────────────────────────                                                │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ input_recording_playback_frame():                                   │   │
│  │                                                                     │   │
│  │ 1. Read input from file                                             │   │
│  │    result = de100_file_read_all(fd, input, sizeof(GameInput));      │   │
│  │                                                                     │   │
│  │ 2. If EOF reached → LOOP!                                           │   │
│  │    if (!result.success || result.bytes_processed == 0) {            │   │
│  │                                                                     │   │
│  │        // Seek input file to beginning                              │   │
│  │        de100_file_seek(fd, 0, DE100_SEEK_SET);                      │   │
│  │                                                                     │   │
│  │        // FAST: Restore state from mmap (~100ms)                    │   │
│  │        replay_buffer_restore_state(state, slot_index);              │   │
│  │                                                                     │   │
│  │        // Read first input frame                                    │   │
│  │        de100_file_read_all(fd, input, sizeof(GameInput));           │   │
│  │    }                                                                │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  USER PRESSES L (Stop Playback - Day 25 Feature):                           │
│  ────────────────────────────────────────────────                           │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ input_recording_toggle() detects playback is active:                │   │
│  │                                                                     │   │
│  │ if (input_recording_is_playing(state)) {                            │   │
│  │     input_recording_playback_end(state);                            │   │
│  │     return INPUT_RECORDING_TOGGLE_STOPPED_PLAYBACK;                 │   │
│  │ }                                                                   │   │
│  │                                                                     │   │
│  │ Game receives result code and can reset inputs if desired.          │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### File Structure

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    FILE STRUCTURE                                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  project/                                                                   │
│  ├── engine/                                                                │
│  │   ├── game/                                                              │
│  │   │   └── memory.h              ◄── GameMemoryState, ReplayBuffer        │
│  │   │                                                                      │
│  │   └── platforms/                                                         │
│  │       └── _common/                                                       │
│  │           ├── input-recording.h ◄── Toggle result codes, API             │
│  │           ├── input-recording.c ◄── Uses replay buffers for state        │
│  │           ├── replay-buffer.h   ◄── Replay buffer API                    │
│  │           └── replay-buffer.c   ◄── mmap implementation                  │
│  │                                                                          │
│  └── games/handmade-hero/                                                          │
│      └── src/                                                               │
│          └── adapters/                                                      │
│              └── x11/                                                       │
│                  └── inputs/                                                │
│                      └── keyboard.c ◄── L key handler, input reset logic    │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  RUNTIME FILES (created in exe directory):                                  │
│  ──────────────────────────────────────────                                 │
│                                                                             │
│  /path/to/exe/                                                              │
│  ├── loop_edit_0_state.hmi   (1GB, mmap'd, slot 0)                          │
│  ├── loop_edit_1_state.hmi   (1GB, mmap'd, slot 1) ◄── Default slot         │
│  ├── loop_edit_2_state.hmi   (1GB, mmap'd, slot 2)                          │
│  ├── loop_edit_3_state.hmi   (1GB, mmap'd, slot 3)                          │
│  └── loop_edit_1_input.hmi   (~KB, regular file, inputs for slot 1)         │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### Stuck Input Problem & Solution

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    STUCK INPUT PROBLEM                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  SCENARIO:                                                                  │
│  ─────────                                                                  │
│                                                                             │
│  Frame 1-30: Recording, user holds D (moving right)                         │
│  Frame 30:   User presses L to stop playback                                │
│  Frame 31+:  Game continues... but D is still "ended_down = true"!          │
│                                                                             │
│  WHY THIS HAPPENS:                                                          │
│  ─────────────────                                                          │
│                                                                             │
│  The last recorded input frame had:                                         │
│    controller.move_right.ended_down = true                                  │
│    controller.move_right.half_transition_count = 0                          │
│                                                                             │
│  When playback stops, the game still sees this state.                       │
│  No "key release" event ever came because we stopped mid-recording.         │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  SOLUTION: Game Decides Policy                                              │
│  ─────────────────────────────                                              │
│                                                                             │
│  Engine returns result code:                                                │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ INPUT_RECORDING_TOGGLE_RESULT_CODE result =                         │   │
│  │     input_recording_toggle(exe_dir, &memory_state);                 │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  Game handles it:                                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ if (result == INPUT_RECORDING_TOGGLE_STOPPED_PLAYBACK) {            │   │
│  │     // Reset current inputs                                         │   │
│  │     for (u32 c = 0; c < MAX_CONTROLLER_COUNT; c++) {             │   │
│  │         GameControllerInput *ctrl = &inputs->controllers[c];        │   │
│  │         for (u32 b = 0; b < ArraySize(ctrl->buttons); b++) {     │   │
│  │             ctrl->buttons[b].ended_down = false;                    │   │
│  │             ctrl->buttons[b].half_transition_count = 0;             │   │
│  │         }                                                           │   │
│  │         ctrl->stick_avg_x = 0.0f;                                   │   │
│  │         ctrl->stick_avg_y = 0.0f;                                   │   │
│  │     }                                                               │   │
│  │     // Also reset old_inputs (prevents prepare_input_frame bleed)   │   │
│  │     // ... same loop for old_inputs ...                             │   │
│  │ }                                                                   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  WHY RESET BOTH inputs AND old_inputs?                                      │
│  ─────────────────────────────────────                                      │
│                                                                             │
│  prepare_input_frame() copies ended_down from old → new:                    │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ If you only reset current_input:                                    │   │
│  │                                                                     │   │
│  │ Frame N:   Reset current_input to all false ✓                       │   │
│  │ Frame N+1: prepare_input_frame() copies old_input (still D=true!)   │   │
│  │            new_input.move_right.ended_down = true  ← STUCK AGAIN!   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ If you reset BOTH:                                                  │   │
│  │                                                                     │   │
│  │ Frame N:   Reset both inputs to all false ✓                         │   │
│  │ Frame N+1: prepare_input_frame() copies old_input (all false) ✓     │   │
│  │            Real input polling detects actual key state ✓            │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  DESIGN PHILOSOPHY:                                                         │
│  ──────────────────                                                         │
│                                                                             │
│  ✅ Engine provides information (what happened)                             │
│  ✅ Game decides policy (what to do about it)                               │
│  ✅ Different games can handle it differently                               │
│  ✅ Engine stays generic, doesn't know about GameInput structure            │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### Performance Comparison

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    PERFORMANCE COMPARISON                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  WHY MEMCPY IS FASTER THAN FILE I/O:                                        │
│  ───────────────────────────────────                                        │
│                                                                             │
│  memcpy (RAM → RAM):                                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ • Direct memory bus transfer                                        │   │
│  │ • ~20-50 GB/s on modern systems                                     │   │
│  │ • 1GB ÷ 20GB/s = 50ms                                               │   │
│  │ • No system calls                                                   │   │
│  │ • No kernel involvement                                             │   │
│  │ • CPU just moves bytes                                              │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  File I/O (RAM → Disk):                                                     │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ • System call overhead                                              │   │
│  │ • Kernel buffer copies                                              │   │
│  │ • File system overhead                                              │   │
│  │ • Disk seek time (HDD) or controller latency (SSD)                  │   │
│  │ • ~100-500 MB/s typical                                             │   │
│  │ • 1GB ÷ 200MB/s = 5 seconds                                         │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  EXPECTED RESULTS:                                                          │
│  ─────────────────                                                          │
│                                                                             │
│  │ Operation              │ Day 24        │ Day 25       │ Improvement │   │
│  │────────────────────────┼───────────────┼──────────────┼─────────────│   │
│  │ Start recording        │ 2-5 sec       │ 50-100ms     │ 20-50x      │   │
│  │ Start playback         │ 2-5 sec       │ 50-100ms     │ 20-50x      │   │
│  │ Loop iteration         │ 2-5 sec       │ 50-100ms     │ 20-50x      │   │
│  │ Record input frame     │ <1ms          │ <1ms         │ Same        │   │
│  │ Playback input frame   │ <1ms          │ <1ms         │ Same        │   │
│  │ Engine startup         │ ~0ms          │ ~100-500ms   │ Slower*     │   │
│                                                                             │
│  * Engine startup is slower because we pre-create and mmap 4 files          │
│    (~4GB total). This is a one-time cost that enables smooth looping.       │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  USER EXPERIENCE:                                                           │
│  ────────────────                                                           │
│                                                                             │
│  Day 24:                                                                    │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ [Play 5 sec][FREEZE 3 sec][Play 5 sec][FREEZE 3 sec][Play 5 sec]... │   │
│  │                                                                     │   │
│  │ "This is unusable for live code editing!"                           │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  Day 25:                                                                    │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ [Play 5 sec][tiny hiccup][Play 5 sec][tiny hiccup][Play 5 sec]...   │   │
│  │                                                                     │   │
│  │ "Smooth! I can edit code and see changes instantly!"                │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### Common Mistakes

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    COMMON MISTAKES                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  MISTAKE 1: Forgetting ftruncate() on Linux                                 │
│  ──────────────────────────────────────────                                 │
│                                                                             │
│  ❌ WRONG:                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ int fd = open("file.bin", O_RDWR | O_CREAT, 0644);                  │   │
│  │ void *ptr = mmap(NULL, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);│  │
│  │ // FAILS! File is 0 bytes, mmap has nothing to map!                 │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ✅ CORRECT:                                                                │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ int fd = open("file.bin", O_RDWR | O_CREAT | O_TRUNC, 0644);        │   │
│  │ ftruncate(fd, size);  // ← CRITICAL!                                │   │
│  │ void *ptr = mmap(NULL, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);│  │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  MISTAKE 2: Using MAP_PRIVATE instead of MAP_SHARED                         │
│  ──────────────────────────────────────────────────                         │
│                                                                             │
│  ❌ WRONG:                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ void *ptr = mmap(NULL, size, PROT_READ|PROT_WRITE,                  │   │
│  │                  MAP_PRIVATE, fd, 0);                               │   │
│  │ // Changes are copy-on-write, NOT written to file!                  │   │
│  │ // Each process gets its own copy.                                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ✅ CORRECT:                                                                │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ void *ptr = mmap(NULL, size, PROT_READ|PROT_WRITE,                  │   │
│  │                  MAP_SHARED, fd, 0);                                │   │
│  │ // Changes visible to file (and other processes mapping same file) │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  NOTE: For our use case (single process, RAM-to-RAM copy), MAP_PRIVATE      │
│        would actually work fine. But MAP_SHARED is more correct and         │
│        matches Casey's Windows implementation semantics.                    │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  MISTAKE 3: Not checking mmap return value                                  │
│  ─────────────────────────────────────────                                  │
│                                                                             │
│  ❌ WRONG:                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ void *ptr = mmap(NULL, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);│  │
│  │ memcpy(ptr, data, size);  // CRASH if mmap failed!                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ✅ CORRECT:                                                                │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ void *ptr = mmap(NULL, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);│  │
│  │ if (ptr == MAP_FAILED) {                                            │   │
│  │     fprintf(stderr, "mmap failed: %s\n", strerror(errno));          │   │
│  │     close(fd);                                                      │   │
│  │     return false;                                                   │   │
│  │ }                                                                   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  MISTAKE 4: Forgetting to munmap before close                               │
│  ────────────────────────────────────────────                               │
│                                                                             │
│  ❌ WRONG:                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ close(fd);  // File closed but memory still mapped!                 │   │
│  │ // ptr is now a dangling pointer to unmapped memory                 │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ✅ CORRECT:                                                                │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ munmap(ptr, size);  // Unmap first                                  │   │
│  │ close(fd);          // Then close file                              │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  MISTAKE 5: Not resetting both input buffers on playback stop               │
│  ───────────────────────────────────────────────────────────                │
│                                                                             │
│  ❌ WRONG:                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ if (result == INPUT_RECORDING_TOGGLE_STOPPED_PLAYBACK) {            │   │
│  │     // Only reset current inputs                                    │   │
│  │     reset_inputs(game_state->inputs);                               │   │
│  │     // OOPS! old_inputs still has D key down!                       │   │
│  │     // Next frame: prepare_input_frame copies old → new             │   │
│  │     // Result: D key is "stuck" again!                              │   │
│  │ }                                                                   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ✅ CORRECT:                                                                │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ if (result == INPUT_RECORDING_TOGGLE_STOPPED_PLAYBACK) {            │   │
│  │     reset_inputs(game_state->inputs);      // Reset current         │   │
│  │     reset_inputs(platform_state->old_inputs);  // Reset old too!    │   │
│  │ }                                                                   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  MISTAKE 6: Initializing replay buffers before game memory                  │
│  ─────────────────────────────────────────────────────────                  │
│                                                                             │
│  ❌ WRONG:                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ replay_buffers_init(exe_dir, &memory_state);  // total_size is 0!   │   │
│  │ memory_state.total_size = permanent + transient;                    │   │
│  │ memory_state.game_memory = allocate_memory(total_size);             │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ✅ CORRECT:                                                                │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ memory_state.total_size = permanent + transient;                    │   │
│  │ memory_state.game_memory = allocate_memory(total_size);             │   │
│  │ replay_buffers_init(exe_dir, &memory_state);  // Now total_size set!│   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### Quick Reference

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    QUICK REFERENCE                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  HEADERS TO INCLUDE:                                                        │
│  ───────────────────                                                        │
│                                                                             │
│  #include "platforms/_common/input-recording.h"  // Toggle, record, play    │
│  #include "platforms/_common/replay-buffer.h"    // Init, shutdown, buffers │
│  #include "game/memory.h"                        // GameMemoryState          │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  STARTUP SEQUENCE:                                                          │
│  ─────────────────                                                          │
│                                                                             │
│  1. Allocate game memory                                                    │
│  2. Set memory_state.total_size and memory_state.game_memory                │
│  3. Call replay_buffers_init()                                              │
│  4. Initialize recording_fd = -1, playback_fd = -1                          │
│  5. Initialize input_recording_index = 0, input_playing_index = 0           │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  MAIN LOOP SEQUENCE:                                                        │
│  ───────────────────                                                        │
│                                                                             │
│  1. prepare_input_frame(old, new)                                           │
│  2. Poll real inputs                                                        │
│  3. if (is_recording) record_frame()                                        │
│  4. if (is_playing) playback_frame()  // Overwrites inputs!                 │
│  5. game_update_and_render()                                                │
│  6. swap(old, new)                                                          │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  SHUTDOWN SEQUENCE:                                                         │
│  ──────────────────                                                         │
│                                                                             │
│  1. input_recording_end()                                                   │
│  2. input_recording_playback_end()                                          │
│  3. replay_buffers_shutdown()                                               │
│  4. Free game memory                                                        │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  KEY BINDINGS:                                                              │
│  ─────────────                                                              │
│                                                                             │
│  L key: Toggle recording state                                              │
│         IDLE → RECORDING → PLAYBACK → IDLE                                  │
│                                                                             │
│  P key: Pause/unpause game (independent of recording)                       │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  FILES CREATED:                                                             │
│  ──────────────                                                             │
│                                                                             │
│  loop_edit_N_state.hmi  - Memory-mapped state snapshot (~1GB each)          │
│  loop_edit_N_input.hmi  - Input frames (small, regular file)                │
│                                                                             │
│  Where N = slot index (0-3, default is 1)                                   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### Summary

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    DAY 25 SUMMARY                                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  PROBLEM SOLVED:                                                            │
│  ───────────────                                                            │
│  Day 24's file I/O caused 2-5 second freezes when saving/restoring          │
│  1GB+ of game state, making live code editing painful.                      │
│                                                                             │
│  SOLUTION:                                                                  │
│  ─────────                                                                  │
│  Memory-mapped files allow RAM-to-RAM copies (~100ms) instead of            │
│  disk I/O (2-5 seconds), providing 20-50x speedup.                          │
│                                                                             │
│  KEY CHANGES FROM DAY 24:                                                   │
│  ────────────────────────                                                   │
│                                                                             │
│  1. ReplayBuffer struct added to GameMemoryState                            │
│  2. Separate files for state (mmap'd) and inputs (regular)                  │
│  3. replay_buffer_save_state() uses memcpy, not write()                     │
│  4. replay_buffer_restore_state() uses memcpy, not read()                   │
│  5. Can now exit playback by pressing L (returns result code)               │
│  6. Game handles stuck input reset based on result code                     │
│                                                                             │
│  LINUX-SPECIFIC NOTES:                                                      │
│  ─────────────────────                                                      │
│                                                                             │
│  • Must call ftruncate() before mmap() to set file size                     │
│  • Use MAP_SHARED for changes to persist to file                            │
│  • Check for MAP_FAILED, not NULL                                           │
│  • munmap() before close()                                                  │
│                                                                             │
│  RESULT:                                                                    │
│  ───────                                                                    │
│  Smooth looping playback enables effective live code editing.               │
│  Edit code → save → hot reload → see changes in next loop iteration!       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

## Day 25 notes

### Replay Buffer Initial Recording Delay Analysis

#### The Problem

First recording: ~2 seconds
Subsequent recordings: Instantaneous

This is **expected behavior** due to how memory-mapped files work!

---

#### Root Cause: Page Fault on First Write

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    MEMORY-MAPPED FILE BEHAVIOR                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  FIRST RECORDING (Slow ~2s):                                                │
│  ───────────────────────────                                                │
│                                                                             │
│  1. mmap() returns immediately (just sets up page tables)                   │
│     └─→ NO physical memory allocated yet!                                   │
│     └─→ Pages are marked as "not present"                                   │
│                                                                             │
│  2. memcpy() starts writing to mapped region                                │
│     └─→ CPU tries to write to page 0                                        │
│     └─→ PAGE FAULT! (page not in RAM)                                       │
│     └─→ OS must:                                                            │
│         a) Allocate physical RAM page                                       │
│         b) Zero the page (security)                                         │
│         c) Update page tables                                               │
│         d) Resume memcpy                                                    │
│     └─→ Repeat for EVERY page (~262,144 faults for 1GB!)                   │
│                                                                             │
│  Time breakdown for 1GB:                                                    │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Pages: 1GB / 4KB = 262,144 pages                                    │   │
│  │ Page fault overhead: ~5-10μs per fault                              │   │
│  │ Total: 262,144 × 7.5μs ≈ 2 seconds!                                 │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  SUBSEQUENT RECORDINGS (Fast ~100ms):                                       │
│  ────────────────────────────────────                                       │
│                                                                             │
│  1. Pages are ALREADY in RAM from first recording                           │
│     └─→ No page faults needed!                                              │
│                                                                             │
│  2. memcpy() is pure RAM-to-RAM copy                                        │
│     └─→ ~10-15 GB/s on modern systems                                       │
│     └─→ 1GB / 12GB/s ≈ 80-100ms                                            │
│                                                                             │
│  This is the EXPECTED behavior and matches Casey's experience!              │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

#### Visual Timeline

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    RECORDING TIMELINE                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  STARTUP:                                                                   │
│  ────────                                                                   │
│  replay_buffers_init() called                                               │
│  ├─→ open() creates file                    (~1ms)                          │
│  ├─→ ftruncate() sets file size to 1GB      (~1ms)                          │
│  └─→ mmap() maps file into address space    (~1ms)                          │
│      └─→ Returns pointer immediately!                                       │
│      └─→ But NO physical RAM allocated yet (lazy allocation)                │
│                                                                             │
│  Memory state after init:                                                   │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Virtual Address Space:  [mapped region 1GB]                         │   │
│  │ Physical RAM:           [nothing allocated!]                        │   │
│  │ Page Tables:            [all pages marked "not present"]            │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  FIRST RECORDING (Press L):                                                 │
│  ──────────────────────────                                                 │
│                                                                             │
│  replay_buffer_save_state() calls memcpy()                                  │
│                                                                             │
│  Time: 0ms────100ms────500ms────1000ms────1500ms────2000ms                  │
│        │       │        │         │         │         │                     │
│        ▼       ▼        ▼         ▼         ▼         ▼                     │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ [====PAGE FAULTS + ALLOCATION============================] memcpy   │   │
│  │  ↑                                                              ↑    │   │
│  │  First page fault                              Last page fault  │    │   │
│  │  (page 0)                                      (page 262143)    │    │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  Memory state after first recording:                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Virtual Address Space:  [mapped region 1GB]                         │   │
│  │ Physical RAM:           [1GB ALLOCATED AND POPULATED!]              │   │
│  │ Page Tables:            [all pages marked "present"]                │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  SECOND RECORDING (Press L again after playback):                           │
│  ────────────────────────────────────────────────                           │
│                                                                             │
│  replay_buffer_save_state() calls memcpy()                                  │
│                                                                             │
│  Time: 0ms────100ms                                                         │
│        │       │                                                            │
│        ▼       ▼                                                            │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ [===] memcpy (pure RAM-to-RAM, no page faults!)                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  Pages already in RAM → No allocation needed → FAST!                        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

#### The Fix: Pre-fault Pages at Startup

Casey mentions this in Day 25 - you can **pre-fault** the pages during initialization so the first recording is also fast:

```c:project/engine/platforms/_common/replay-buffer.c
// ═══════════════════════════════════════════════════════════════════════════
// OPTION 1: Pre-fault by touching every page (simple but blocking)
// ═══════════════════════════════════════════════════════════════════════════

de100_file_scoped_fn void prefault_mapped_memory(void *ptr, size_t size) {
    // Touch every page to force allocation
    // Page size is typically 4KB on x86/x64
    volatile char *p = (volatile char *)ptr;
    size_t page_size = 4096;

    for (size_t offset = 0; offset < size; offset += page_size) {
        // Read then write to ensure page is fully faulted
        char tmp = p[offset];
        p[offset] = tmp;
    }
}

// In replay_buffers_init(), after successful mmap:
ReplayBufferInitResult replay_buffers_init(const char *exe_directory,
                                           void *game_memory, u64 total_size,
                                           ReplayBuffer *out_buffers) {
    // ... existing code ...

    for (i32 slot = 0; slot < MAX_REPLAY_BUFFERS; ++slot) {
        ReplayBuffer *buffer = &out_buffers[slot];

        // ... existing mmap code ...

        if (buffer->memory_block) {
            // ─────────────────────────────────────────────────────────────
            // PRE-FAULT: Touch all pages now so first recording is fast
            // ─────────────────────────────────────────────────────────────
            // This moves the 2-second delay from "first L press" to
            // "game startup", which is more acceptable.
            // ─────────────────────────────────────────────────────────────
#if DE100_INTERNAL
            printf("[REPLAY BUFFER] Pre-faulting slot %d (%zu MB)...\n",
                   slot, (size_t)(total_size / (1024 * 1024)));
#endif
            prefault_mapped_memory(buffer->memory_block, (size_t)total_size);
#if DE100_INTERNAL
            printf("[REPLAY BUFFER] ✅ Slot %d pre-faulted\n", slot);
#endif

            buffer->mapped_size = (size_t)total_size;
            buffer->is_valid = true;
            // ...
        }
    }

    // ...
}
```

---

#### Option 2: Use MAP_POPULATE (Linux-specific, better)

Linux has a flag that tells the kernel to pre-fault all pages:

```c:project/engine/platforms/_common/replay-buffer.c
#if defined(__linux__)

de100_file_scoped_fn void *
platform_mmap_file(i32 fd, u64 size, ReplayBufferErrorCode *out_error) {
    *out_error = REPLAY_BUFFER_SUCCESS;

    // MAP_POPULATE: Pre-fault all pages during mmap()
    // This makes mmap() slower but subsequent access instant
    void *ptr = mmap(NULL,
                     (size_t)size,
                     PROT_READ | PROT_WRITE,
                     MAP_SHARED | MAP_POPULATE,  // ← ADD MAP_POPULATE
                     fd,
                     0);

    if (ptr == MAP_FAILED) {
#if DE100_INTERNAL && DE100_SLOW
        fprintf(stderr, "[REPLAY BUFFER] mmap failed: %s\n", strerror(errno));
#endif
        *out_error = REPLAY_BUFFER_ERROR_MMAP_FAILED;
        return NULL;
    }

    return ptr;
}

#endif
```

---

#### Option 3: Casey's Approach - Accept the Delay

Casey actually **doesn't fix this** in Day 25. He notes:

> "The first time you press L, it takes a moment because Windows has to actually commit those pages. After that, it's instant."

This is acceptable because:

1. It only happens once per session
2. The delay is at a user-initiated action (pressing L)
3. Subsequent recordings are instant

---

#### Comparison of Options

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    FIX OPTIONS COMPARISON                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  OPTION 1: Manual Pre-fault Loop                                            │
│  ───────────────────────────────                                            │
│  Pros: Works on all platforms                                               │
│  Cons: Adds ~2s to startup per buffer (8s total for 4 buffers!)            │
│        Blocking - game doesn't start until done                             │
│                                                                             │
│  OPTION 2: MAP_POPULATE (Linux only)                                        │
│  ───────────────────────────────────                                        │
│  Pros: Kernel handles it efficiently, may use readahead                     │
│  Cons: Linux-specific, still adds delay to mmap() call                      │
│        Not available on macOS/Windows                                       │
│                                                                             │
│  OPTION 3: Accept First-Recording Delay (Casey's approach)                  │
│  ─────────────────────────────────────────────────────────                  │
│  Pros: No startup delay, simple code                                        │
│  Cons: First L press has 2s delay                                           │
│        User might think it's broken                                         │
│                                                                             │
│  OPTION 4: Background Pre-fault Thread (Best UX)                            │
│  ───────────────────────────────────────────────                            │
│  Pros: No blocking, game starts immediately                                 │
│        First recording fast if thread finished                              │
│  Cons: More complex, need thread synchronization                            │
│        If L pressed before done, still delays                               │
│                                                                             │
│  RECOMMENDATION:                                                            │
│  ───────────────                                                            │
│  For learning: Use Option 3 (Casey's approach) - simplest                   │
│  For polish: Use Option 2 on Linux, Option 1 on other platforms             │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

#### Quick Fix: Add MAP_POPULATE

Here's the minimal change to make first recording fast on Linux:

```c:project/engine/platforms/_common/replay-buffer.c
#else // POSIX

de100_file_scoped_fn void *
platform_mmap_file(i32 fd, u64 size, ReplayBufferErrorCode *out_error) {
    *out_error = REPLAY_BUFFER_SUCCESS;

    int mmap_flags = MAP_SHARED;

#if defined(__linux__)
    // MAP_POPULATE: Pre-fault pages during mmap() for faster first access
    // This makes initialization slower but first recording instant
    mmap_flags |= MAP_POPULATE;
#endif

    void *ptr = mmap(NULL,
                     (size_t)size,
                     PROT_READ | PROT_WRITE,
                     mmap_flags,
                     fd,
                     0);

    if (ptr == MAP_FAILED) {
#if DE100_INTERNAL && DE100_SLOW
        fprintf(stderr, "[REPLAY BUFFER] mmap failed: %s\n", strerror(errno));
#endif
        *out_error = REPLAY_BUFFER_ERROR_MMAP_FAILED;
        return NULL;
    }

    return ptr;
}

#endif // Platform selection
```

**Trade-off:** This moves the ~2s delay from "first L press" to "game startup" (during `replay_buffers_init()`). The game will take longer to start, but recording will always be instant.

---

#### Summary

| Behavior                            | Cause                                                   | Fix                       |
| ----------------------------------- | ------------------------------------------------------- | ------------------------- |
| First recording slow (~2s)          | Page faults - OS allocating physical RAM on first touch | Add `MAP_POPULATE` flag   |
| Subsequent recordings fast (~100ms) | Pages already in RAM, pure memcpy                       | N/A - working as intended |

**This is expected behavior, not a bug.** Casey experiences the same thing on Windows. The question is just whether you want the delay at startup or at first recording.

### Why Multiple Replay Buffers?

#### Short Answer

**You don't need them for basic functionality.** One buffer is enough for the L-key loop editing Casey demonstrates.

Casey creates 4 buffers for **future flexibility**, but only uses slot 1 in Day 25.

---

#### What Casey Actually Uses

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    CASEY'S DAY 25 USAGE                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  win32_state struct:                                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ win32_replay_buffer ReplayBuffers[4];  // ← 4 slots defined         │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  Actual usage in Day 25:                                                    │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Win32BeginRecordingInput(State, 1);  // ← Always slot 1!            │   │
│  │ Win32BeginInputPlayBack(State, 1);   // ← Always slot 1!            │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  Slots 0, 2, 3: NEVER USED in the Handmade Hero series!                    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

#### Why Casey Defined 4 Slots (Speculation)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    POTENTIAL USE CASES (Never Implemented)                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  IDEA 1: Multiple Save Points                                               │
│  ────────────────────────────                                               │
│  F1 = Record/Play slot 1 (test jumping)                                     │
│  F2 = Record/Play slot 2 (test combat)                                      │
│  F3 = Record/Play slot 3 (test edge case)                                   │
│  F4 = Record/Play slot 4 (test performance)                                 │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  IDEA 2: A/B Comparison                                                     │
│  ──────────────────────                                                     │
│  Slot 1: Record behavior with old code                                      │
│  Slot 2: Record behavior with new code                                      │
│  Compare side-by-side                                                       │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  IDEA 3: Undo Levels                                                        │
│  ───────────────────                                                        │
│  Slot 1: State 5 seconds ago                                                │
│  Slot 2: State 10 seconds ago                                               │
│  Slot 3: State 15 seconds ago                                               │
│  Slot 4: State 20 seconds ago                                               │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  REALITY: None of these were implemented!                                   │
│  Casey just used slot 1 with the L key.                                     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

#### The Cost of Multiple Buffers

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    MEMORY COST                                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Game Memory Size: ~1 GB (64MB permanent + 1GB transient)                   │
│                                                                             │
│  With 4 replay buffers:                                                     │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Slot 0: 1 GB  ─┐                                                    │   │
│  │ Slot 1: 1 GB   │                                                    │   │
│  │ Slot 2: 1 GB   ├─→ 4 GB total for replay buffers!                   │   │
│  │ Slot 3: 1 GB  ─┘                                                    │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  Total memory footprint:                                                    │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Game memory:     1 GB                                               │   │
│  │ Replay buffers:  4 GB                                               │   │
│  │ ─────────────────────                                               │   │
│  │ Total:           5 GB (just for debug feature!)                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  With 1 replay buffer:                                                      │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Game memory:     1 GB                                               │   │
│  │ Replay buffer:   1 GB                                               │   │
│  │ ─────────────────────                                               │   │
│  │ Total:           2 GB (much more reasonable!)                       │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

#### My Recommendation: Use 1 Buffer

For your learning project, **simplify to 1 buffer**:

```c:project/engine/game/memory.h
// Change from:
#define MAX_REPLAY_BUFFERS 4

// To:
#define MAX_REPLAY_BUFFERS 1
```

Or even simpler - just embed the single buffer directly:

```c:project/engine/game/memory.h
typedef struct {
    // Memory tracking
    u64 total_size;
    void* game_memory;

    // Recording state
    i32 recording_fd;
    i32 input_recording_index;

    // Playback state
    i32 playback_fd;
    i32 input_playing_index;

    // Single replay buffer (no array needed!)
    ReplayBuffer replay_buffer;

} GameMemoryState;
```

And simplify the API:

```c:project/engine/platforms/_common/replay-buffer.h
// Instead of:
bool replay_buffers_init(const char *exe_directory, GameMemoryState *state);
bool replay_buffer_save_state(GameMemoryState *state, i32 slot_index);
bool replay_buffer_restore_state(GameMemoryState *state, i32 slot_index);

// Just:
bool replay_buffer_init(const char *exe_directory, GameMemoryState *state);
bool replay_buffer_save_state(GameMemoryState *state);
bool replay_buffer_restore_state(GameMemoryState *state);
```

---

#### When You WOULD Want Multiple Buffers

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    LEGITIMATE USE CASES                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. AUTOMATED TESTING                                                       │
│     ─────────────────                                                       │
│     Record multiple test scenarios, replay them automatically               │
│     to verify game behavior after code changes.                             │
│                                                                             │
│  2. DEMO/REPLAY SYSTEM                                                      │
│     ──────────────────                                                      │
│     Save interesting gameplay moments for later playback.                   │
│     (But you'd want to save to disk, not keep in RAM)                       │
│                                                                             │
│  3. NETWORK ROLLBACK                                                        │
│     ─────────────────                                                       │
│     Fighting games keep multiple past states for rollback netcode.          │
│     (But typically only a few frames, not full game state)                  │
│                                                                             │
│  4. BRANCHING TIMELINES                                                     │
│     ───────────────────                                                     │
│     "What if I had gone left instead of right?"                             │
│     Save state, try one path, restore, try another.                         │
│                                                                             │
│  FOR HANDMADE HERO DAY 25: None of these apply!                             │
│  One buffer is sufficient for the L-key loop editing feature.               │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

#### Summary

| Question                           | Answer                          |
| ---------------------------------- | ------------------------------- |
| Why did Casey define 4 buffers?    | Future flexibility (never used) |
| How many does Day 25 actually use? | Just 1 (slot index 1)           |
| How many do you need?              | **1 is enough**                 |
| Cost of 4 buffers?                 | 4 GB RAM + 4 GB disk            |
| Cost of 1 buffer?                  | 1 GB RAM + 1 GB disk            |

**Recommendation:** Simplify to 1 buffer. You can always add more later if you find a real use case. This is Casey's own philosophy: _"Solve problems you have, not problems you might have."_
